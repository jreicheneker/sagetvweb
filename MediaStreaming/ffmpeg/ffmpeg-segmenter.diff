diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/_configure ffmpeg-for-2.2.5/_configure
--- ffmpeg-r21659/_configure	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/_configure	2009-12-30 17:14:02.000000000 -0700
@@ -0,0 +1,6 @@
+#!/bin/sh
+sed s/posix_memalign/posix_memalign_disabled/ configure.orig > configure.orig.fixed
+chmod u+x configure.orig.fixed
+export MACOSX_DEPLOYMENT_TARGET="10.5"
+export CFLAGS="-mmacosx-version-min=10.5 -isysroot /Developer/SDKs/MacOSX10.5.sdk -I/usr/local/include"
+./configure.orig.fixed --enable-pthreads --disable-shared --enable-static --enable-gpl --enable-libx264 --enable-libmp3lame --enable-libfaad --disable-decoder=aac
\ No newline at end of file
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/_configure.mingw ffmpeg-for-2.2.5/_configure.mingw
--- ffmpeg-r21659/_configure.mingw	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/_configure.mingw	2009-12-30 17:13:55.000000000 -0700
@@ -0,0 +1,2 @@
+#!/bin/sh
+./configure --enable-memalign-hack --prefix=/mingw --target-os=mingw32 --arch=i686 --cpu=i686 --enable-gpl --enable-libx264 --enable-static --disable-shared --enable-pthreads --enable-libmp3lame --enable-libfaad --disable-decoder=aac
\ No newline at end of file
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/_make ffmpeg-for-2.2.5/_make
--- ffmpeg-r21659/_make	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/_make	2009-11-08 20:21:26.000000000 -0700
@@ -0,0 +1,3 @@
+#!/bin/sh
+export MACOSX_DEPLOYMENT_TARGET="10.5"
+make
\ No newline at end of file
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/_overlay.c ffmpeg-for-2.2.5/_overlay.c
--- ffmpeg-r21659/_overlay.c	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/_overlay.c	2010-02-07 13:02:52.000000000 -0700
@@ -0,0 +1,477 @@
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+#include "libavcodec/avcodec.h"
+#include "libavcodec/colorspace.h"
+#if HAVE_WINSOCK2_H == 1
+#include <errno.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <io.h>
+#define EWOULDBLOCK WSAEWOULDBLOCK
+#define ECONNREFUSED WSAECONNREFUSED
+#else
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#define closesocket close
+#endif   
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "_segmenter.c"
+
+static inline int socket_error()
+{
+#if HAVE_WINSOCK2_H == 1
+	return WSAGetLastError();
+#else
+	return errno;
+#endif
+}
+
+static void init_sockets()
+{
+#if HAVE_WINSOCK2_H == 1
+    WORD wVersionRequested;
+    WSADATA wsaData;
+    int err;
+
+    wVersionRequested = MAKEWORD(2, 2);
+
+    err = WSAStartup(wVersionRequested, &wsaData);
+    if (err != 0) 
+    {
+        fprintf(stderr, "WSAStartup failed with error: %d\n", err);    
+    }
+
+#endif
+}
+
+typedef struct
+{
+	const char *conversion_id;
+	int width;
+	int height;
+	int timestamp;
+}
+OverlayRequest;
+
+typedef struct
+{
+	int left;
+	int top;
+	int width;
+	int height;
+	uint8_t *data;
+}
+Overlay;
+
+typedef struct
+{
+	Overlay **overlays;
+	int overlay_count;
+	int valid_until_timestamp;
+}
+OverlayResponse;
+
+static OverlayResponse *overlay_response_init()
+{
+	OverlayResponse *resp = av_mallocz(sizeof(OverlayResponse));
+	return resp;
+}
+
+static void overlay_response_free(OverlayResponse *resp)
+{
+	if (resp != NULL)
+	{
+		if (resp->overlays != NULL)
+		{
+			for (int i = 0; i < resp->overlay_count; ++i)
+			{
+				if (resp->overlays[i] != NULL)
+				{
+					if (resp->overlays[i]->data != NULL)
+					{
+						av_free(resp->overlays[i]->data);
+					}
+					
+					av_free(resp->overlays[i]);
+				}				
+			}
+			resp->overlays = NULL;
+		}
+		
+		av_free(resp);
+	}
+}
+
+static int recv_fully(int socket, void *buf, int size)
+{
+	uint8_t *byte_buffer = buf;
+	int remaining = size;
+	
+	while (remaining > 0)
+	{
+		int numread = recv(socket, byte_buffer, remaining, 0);
+		if (numread <= 0)
+		{
+			return numread;
+		}
+		byte_buffer += numread;
+		remaining -= numread;
+	}
+	return size;
+}
+
+static int send_fully(int socket, const void *buf, int size)
+{
+	const uint8_t *byte_buffer = buf;
+	int remaining = size;
+	
+	while (remaining > 0)
+	{
+		int numsent = send(socket, byte_buffer, remaining, 0);
+		if (numsent <= 0)
+		{
+			return numsent;
+		}
+		byte_buffer += numsent;
+		remaining -= numsent;
+	}
+	return size;
+}
+
+static inline int send_int(int socket, int value)
+{
+	value = htonl(value);
+	return send_fully(socket, &value, sizeof(int));
+}
+
+#define __BAIL(condition) if ((condition) < 0) return -1;
+
+static int send_overlay_request(int socket, OverlayRequest *req)
+{
+	if (req->conversion_id == NULL)
+	{
+		__BAIL(send_int(socket, 0));		
+	}
+	else 
+	{
+		int len = strlen(req->conversion_id);
+		__BAIL(send_int(socket, len));
+		if (len > 0)
+		{
+			__BAIL(send_fully(socket, req->conversion_id, len));
+		}
+	}
+	__BAIL(send_int(socket, req->width));
+	__BAIL(send_int(socket, req->height));
+	__BAIL(send_int(socket, req->timestamp));
+	return 0;
+}
+
+static inline int read_int(int socket, int *value)
+{
+	int i;
+	int res = recv_fully(socket, &i, sizeof(int));
+	*value = ntohl(i);
+	return res;
+}
+
+static int read_overlay_response(int socket, OverlayResponse *resp)
+{
+	__BAIL(read_int(socket, &resp->valid_until_timestamp));
+	__BAIL(read_int(socket, &resp->overlay_count));
+	
+	if (resp->overlay_count == 0)
+	{
+		resp->overlays = NULL;
+	}
+	else 
+	{
+		int size;
+		resp->overlays = av_mallocz(resp->overlay_count * sizeof(Overlay));
+		
+		for (int i = 0; i < resp->overlay_count; ++i)
+		{
+			Overlay *overlay = av_mallocz(sizeof(Overlay));
+			resp->overlays[i] = overlay;
+			__BAIL(read_int(socket, &overlay->left));
+			__BAIL(read_int(socket, &overlay->top));
+			__BAIL(read_int(socket, &overlay->width));
+			__BAIL(read_int(socket, &overlay->height));
+			
+			size = overlay->width * overlay->height * 4;			
+			
+			if (size == 0)
+			{
+				overlay->data = NULL;
+			}
+			else 
+			{
+				overlay->data = av_mallocz(size);
+				__BAIL(recv_fully(socket, overlay->data, size));
+			}
+		}
+		
+	}
+
+	return 0;
+}
+
+static int overlay_port_number = -1;
+static int overlay_sock = -1;
+static const char *overlay_conversion_id;
+
+static int get_socket()
+{
+	if (overlay_sock != -1)
+	{
+		return overlay_sock;
+	}
+	else if (overlay_port_number != -1)
+	{
+		struct hostent *host;
+		struct sockaddr_in server_addr;  
+		
+		host = gethostbyname("127.0.0.1");
+		
+		if ((overlay_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) 
+		{
+			fprintf(stderr, "Error creating socket: %i\n", socket_error());
+			overlay_port_number = -1;
+			return -1;
+		}
+		
+		server_addr.sin_family = AF_INET;     
+		server_addr.sin_port = htons(overlay_port_number);   
+		server_addr.sin_addr = *((struct in_addr *)host->h_addr_list[0]);
+		memset(&(server_addr.sin_zero), 0, 8); 
+		
+		if (connect(overlay_sock, (struct sockaddr *)&server_addr,
+					sizeof(struct sockaddr)) == -1) 
+		{
+			fprintf(stderr, "Error connecting to server: %i\n", socket_error());
+			overlay_port_number = -1;
+			return -1;
+		}
+		
+		return overlay_sock;
+	}
+	else 
+	{
+		return -1;
+	}
+}
+
+static void close_socket()
+{
+	closesocket(overlay_sock);
+	overlay_sock = -1;
+}
+
+static OverlayResponse *last_response;
+
+static OverlayResponse *get_overlay(OverlayRequest *request)
+{
+	int sock;
+	
+	if (last_response != NULL && last_response->valid_until_timestamp >= request->timestamp)
+	{
+		return last_response;
+	}
+	overlay_response_free(last_response);
+	last_response = NULL;
+	
+	sock = get_socket();
+	
+	if (sock != -1)
+	{
+		if (send_overlay_request(sock, request) == -1)
+		{
+			fprintf(stderr, "Error sending overlay request: %i\n", socket_error());
+			overlay_port_number = -1;
+			close_socket();
+		}
+		else 
+		{
+			last_response = overlay_response_init();
+			if (read_overlay_response(sock, last_response) == -1)
+			{
+				fprintf(stderr, "Error reading overlay request: %i\n", socket_error());
+				overlay_response_free(last_response);
+				last_response = NULL;
+				overlay_port_number = -1;
+				close_socket();
+			}
+		}
+	}
+
+	
+	return last_response;
+}
+
+
+static inline unsigned char blend(unsigned char v1, unsigned char v2, unsigned alpha)
+{
+	if (alpha == 0)
+	{
+		return v1;
+	}
+	else if (alpha == 255)
+	{
+		return v2;
+	}
+	else if (alpha == 127)
+	{
+		return (v1 >> 1) + (v2 >> 1);		
+	}
+	else 
+	{
+		return (v1 * (255 - alpha) + v2 * alpha) >> 8;
+	}
+	
+}
+
+#define MIN(a,b) ((a) < (b) ? (a) : (b))
+
+static void blend_overlay(AVPicture *pic, enum PixelFormat pf, int width, int height, Overlay *overlay)
+{
+    int channel;
+	int stride;
+    unsigned char *row[4];
+	int max_x = MIN(overlay->width, width - overlay->left);
+	int max_y = MIN(overlay->height, height - overlay->top);
+
+	int vsub, hsub;
+	
+	avcodec_get_chroma_sub_sample(pf, &hsub, &vsub);
+	
+	stride = overlay->width * 4;
+	
+	for (int y = 0; y < max_y; ++y)
+	{
+		int dest_y = y + overlay->top;
+		row[0] = pic->data[0] + dest_y  * pic->linesize[0];
+
+		for (channel = 1; channel < 3; ++channel)
+		{
+			row[channel] = pic->data[channel] +
+			pic->linesize[channel] * (dest_y >> vsub);
+		}
+
+		for (int x = 0; x < max_x; ++x)
+		{
+			uint8_t *rgba_color = overlay->data +  y * stride + x * 4;			
+			uint8_t alpha = rgba_color[0];
+
+			if (alpha > 0)
+			{			
+				uint8_t _y  = RGB_TO_Y(rgba_color[1], rgba_color[2], rgba_color[3]);
+				uint8_t _cb = RGB_TO_U(rgba_color[1], rgba_color[2], rgba_color[3], 0);
+				uint8_t _cr = RGB_TO_V(rgba_color[1], rgba_color[2], rgba_color[3], 0);
+
+				int dest_x = x + overlay->left;
+
+				int hx = 1 << hsub;
+				int hy = 1 << vsub;
+
+				row[0][dest_x] = blend(row[0][dest_x], _y, alpha);
+
+				if (dest_y % hy == 0 && dest_x % hx == 0)
+				{
+					row[1][dest_x >> hsub] = blend(row[1][dest_x >> hsub], _cb, alpha);
+					row[2][dest_x >> hsub] = blend(row[2][dest_x >> hsub], _cr, alpha);
+				}
+			}
+		}
+	}
+}
+
+static void process_frame(AVPicture *pic, enum PixelFormat pf, int width, int height, uint64_t timestamp)
+{
+	OverlayRequest req;
+	OverlayResponse *resp;
+	
+	req.conversion_id = overlay_conversion_id;
+	req.width = width;
+	req.height = height;
+	req.timestamp = timestamp;
+
+	resp = get_overlay(&req);
+
+	if (resp != NULL && resp->overlay_count > 0)
+	{
+		for (int i = 0; i < resp->overlay_count; ++i)
+		{
+			blend_overlay(pic, pf, width, height, resp->overlays[i]);
+		}
+	}
+}
+
+int64_t seeked_to = 0;
+
+int av_seek_frame2(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
+{
+	seeked_to = timestamp;
+	return av_seek_frame(s, stream_index, timestamp, flags);
+}
+
+#define av_seek_frame av_seek_frame2
+
+#define fix_resample() ost->video_resample = 1;
+
+#define blend_subtitle() process_frame((AVPicture*)final_picture, enc->pix_fmt, enc->width, enc->height, (ist->pts + seeked_to) * 1000 / AV_TIME_BASE);
+
+int ffmpeg_main(int argc, char **argv);
+
+void preprocess_arguments(int *argc, char ***argv)
+{
+	char **res = av_malloc(*argc * sizeof(char*));
+	int index = 0;
+	
+	for (int i = 0; i < *argc; ++i)
+	{
+		if (strcmp((*argv)[i], "--conversion-id") == 0)
+		{
+			overlay_conversion_id = (*argv)[i+1];
+			i += 1;
+			continue;
+		} 
+		else if (strcmp((*argv)[i], "--port-number") == 0)
+		{
+			sscanf((*argv)[i+1], "%i", &overlay_port_number);
+			i += 1;
+			continue;
+		}
+		
+		res[index++] = (*argv)[i];
+		
+	}	
+	*argv = res;
+	*argc = index;
+}
+
+int main(int argc, char **argv)
+{
+	int res;
+	if (argc > 1 && strcmp(argv[1], "segmenter") == 0)
+	{
+	    return segmenter_main(argc, argv);
+	}
+	
+	init_sockets();
+	preprocess_arguments(&argc, &argv);
+	res = ffmpeg_main(argc, argv);
+	close_socket();
+	return res;
+}
+
+#define main ffmpeg_main
+
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/_resample.c ffmpeg-for-2.2.5/_resample.c
--- ffmpeg-r21659/_resample.c	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/_resample.c	2010-02-07 13:03:00.000000000 -0700
@@ -0,0 +1,40 @@
+#define stereo_split2(output1, output2, input, samples) \
+    do {\
+	stereo_split(output1, output2, input, samples); /* prevent "unused" warning */ \
+	stereo_split2_a(output1, output2, input, samples, s->input_channels);\
+    } while(0);
+
+static void stereo_split2_a(short *output1, short *output2, short *input, int samples, int channels)
+{
+    int i;
+    short l = 0;
+    short r = 0;
+    
+    if (channels == 2) {
+        for(i=0;i<samples;i++) {
+            /* stereo to stereo */
+            l = input[0];
+            r = input[1];
+        } 
+    } else if (channels == 5 || channels == 6) {
+        int fl_index = 0;
+        int fr_index = 1;            
+        int c_index = 2;
+        int bl_index = 3;
+        int br_index = 4;
+        
+        for(i=0;i<samples;i++) {
+            int fl = fl_index != -1 ? input[fl_index] : 0;
+            int fr = fr_index != -1 ? input[fr_index] : 0;
+            int c = c_index != -1 ? input[c_index] : 0;
+            int bl = bl_index != -1 ? input[bl_index] : 0;
+            int br = br_index != -1 ? input[br_index] : 0;
+            
+            l = av_clip_int16(fl + (0.707 * bl) + (0.707 * c));
+            r = av_clip_int16(fr + (0.707 * br) + (0.707 * c));
+            *output1++ = l;
+            *output2++ = r;
+            input += channels;
+        }         
+    }    
+}
\ No newline at end of file
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/_segmenter.c ffmpeg-for-2.2.5/_segmenter.c
--- ffmpeg-r21659/_segmenter.c	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/_segmenter.c	2010-02-06 15:53:59.000000000 -0700
@@ -0,0 +1,393 @@
+/*
+ * Copyright (c) 2009 Chase Douglas
+ *
+ * Modifications (c) 2009 Matej Knopp, InMethod s.r.o.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#if 0
+#include <stdio.h>
+#include <libavformat/avformat.h>
+#include <libavcodec/opt.h>
+#endif 
+
+#ifdef WIN32
+#include <io.h>
+#include <fcntl.h>
+#include <stdio.h>
+#endif
+
+static AVStream *segmenter_add_output_stream(AVFormatContext *output_format_context, AVStream *input_stream) 
+{
+    AVCodecContext *input_codec_context;
+    AVCodecContext *output_codec_context;
+    AVStream *output_stream;
+
+    output_stream = av_new_stream(output_format_context, 0);
+    if (!output_stream) 
+    {
+        fprintf(stderr, "Could not allocate stream\n");
+        exit(1);
+    }
+
+    input_codec_context = input_stream->codec;
+    output_codec_context = output_stream->codec;
+
+    output_codec_context->codec_id = input_codec_context->codec_id;
+    output_codec_context->codec_type = input_codec_context->codec_type;
+    output_codec_context->codec_tag = input_codec_context->codec_tag;
+    output_codec_context->bit_rate = input_codec_context->bit_rate;
+    output_codec_context->extradata = input_codec_context->extradata;
+    output_codec_context->extradata_size = input_codec_context->extradata_size;
+
+    if (av_q2d(input_codec_context->time_base) * input_codec_context->ticks_per_frame > av_q2d(input_stream->time_base) && 
+        av_q2d(input_stream->time_base) < 1.0/1000) 
+    {
+        output_codec_context->time_base = input_codec_context->time_base;
+        output_codec_context->time_base.num *= input_codec_context->ticks_per_frame;
+    }
+    else 
+    {
+        output_codec_context->time_base = input_stream->time_base;
+    }
+
+    switch (input_codec_context->codec_type) 
+    {
+        case CODEC_TYPE_AUDIO:
+            output_codec_context->channel_layout = input_codec_context->channel_layout;
+            output_codec_context->sample_rate = input_codec_context->sample_rate;
+            output_codec_context->channels = input_codec_context->channels;
+
+            output_codec_context->frame_size = input_codec_context->frame_size;
+
+            if ((input_codec_context->block_align == 1 && input_codec_context->codec_id == CODEC_ID_MP3) || input_codec_context->codec_id == CODEC_ID_AC3) 
+            {
+                output_codec_context->block_align = 0;
+            }
+            else 
+            {
+                output_codec_context->block_align = input_codec_context->block_align;
+            }
+            break;
+        case CODEC_TYPE_VIDEO:
+            output_codec_context->pix_fmt = input_codec_context->pix_fmt;
+            output_codec_context->width = input_codec_context->width;
+            output_codec_context->height = input_codec_context->height;
+            output_codec_context->has_b_frames = input_codec_context->has_b_frames;
+
+            if (output_format_context->oformat->flags & AVFMT_GLOBALHEADER) 
+            {
+                output_codec_context->flags |= CODEC_FLAG_GLOBAL_HEADER;
+            }
+            break;
+        default:
+            break;
+    }
+
+    return output_stream;
+}
+
+static void segmenter_close_io(ByteIOContext *context, uint8_t finished)
+{
+    uint8_t *result_buffer;
+
+    uint32_t len = url_close_dyn_buf(context, &result_buffer);
+
+    if (len > 0 || finished)
+    {
+        uint32_t network = htonl(finished);
+        fwrite(&network, 4, 1, stdout);
+
+        network = htonl(len);
+        fwrite(&network, 4, 1, stdout);
+
+        fwrite(result_buffer, len, 1, stdout);
+        fflush(stdout);
+    }
+    av_free(result_buffer);
+}
+
+static int segmenter_main(int argc, char **argv)
+{
+    const char *input;
+    unsigned int segment_duration;
+    char *segment_duration_check;
+    double prev_segment_time = 0;
+    unsigned int output_index = 0;
+    unsigned int segment_offset = 0;
+    AVInputFormat *ifmt;
+    AVOutputFormat *ofmt;
+    AVFormatContext *ic = NULL;
+    AVFormatContext *oc;
+    AVStream *video_st = NULL;
+    AVStream *audio_st = NULL;
+    AVCodec *codec;
+    int video_index;
+    int audio_index;
+    int decode_done;
+    int ret;
+    int i;
+
+    int err;
+    int shift = 1;
+    double ts_offset = 0;
+
+    av_log_set_level(AV_LOG_VERBOSE);
+
+    if (argc != 4) 
+    {
+        fprintf(stderr, "Usage: %s segmenter <segment duration in seconds> <first-segment-index>\n", argv[shift + 0]);
+        exit(1);
+    }
+
+#ifdef WIN32
+	setmode(STDOUT_FILENO, O_BINARY);
+#endif
+    
+    av_register_all();
+
+    input = "pipe:";
+
+    segment_duration = strtoll(argv[shift + 1], &segment_duration_check, 10);
+    if (segment_duration_check == argv[shift + 1]) 
+    {
+        fprintf(stderr, "Segment duration time (%s) invalid\n", argv[shift + 1]);
+        exit(1);
+    }
+
+    output_index = strtoll(argv[shift + 2], &segment_duration_check, 10);
+    segment_offset = output_index;
+    if (segment_duration_check == argv[shift + 2]) 
+    {
+        fprintf(stderr, "First segment index (%s) invalid\n", argv[shift + 2]);
+        exit(1);
+    }
+
+    ifmt = av_find_input_format("mpegts");
+    if (!ifmt) 
+    {
+        fprintf(stderr, "Could not find MPEG-TS demuxer\n");
+        exit(1);
+    }
+
+    ret = av_open_input_file(&ic, input, ifmt, 0, NULL);
+    if (ret != 0) 
+    {
+        fprintf(stderr, "Could not open input file, make sure it is an mpegts file: %d\n", ret);
+        exit(1);
+    }
+
+//    av_set_int(ic, "analyzeduration", 10000000);
+
+    if (av_find_stream_info(ic) < 0) 
+    {
+        fprintf(stderr, "Could not read stream information\n");
+        exit(1);
+    }
+
+    ofmt = guess_format("mpegts", NULL, NULL);
+    if (!ofmt) 
+    {
+        fprintf(stderr, "Could not find MPEG-TS muxer\n");
+        exit(1);
+    }
+    
+    oc = avformat_alloc_context();
+    if (!oc) 
+    {
+        fprintf(stderr, "Could not allocated output context");
+        exit(1);
+    }
+    oc->oformat = ofmt;
+
+    ofmt->flags |= AVFMT_NOTIMESTAMPS;
+//    ofmt->flags |= AVFMT_TS_DISCONT;
+
+    video_index = -1;
+    audio_index = -1;
+
+    for (i = 0; i < ic->nb_streams && (video_index < 0 || audio_index < 0); i++) 
+    {
+        switch (ic->streams[i]->codec->codec_type) 
+        {
+            case CODEC_TYPE_VIDEO:
+                video_index = i;
+                ic->streams[i]->discard = AVDISCARD_NONE;
+                video_st = segmenter_add_output_stream(oc, ic->streams[i]);
+                break;
+            case CODEC_TYPE_AUDIO:
+                audio_index = i;
+                ic->streams[i]->discard = AVDISCARD_NONE;
+                audio_st = segmenter_add_output_stream(oc, ic->streams[i]);
+                break;
+            default:
+                ic->streams[i]->discard = AVDISCARD_ALL;
+                break;
+        }
+    }
+
+    if (av_set_parameters(oc, NULL) < 0)
+    {
+        fprintf(stderr, "Invalid output format parameters\n");
+        exit(1);
+    }
+
+    dump_format(oc, 0, "", 1);
+
+    if (video_st)
+    {
+        codec = avcodec_find_decoder(video_st->codec->codec_id);
+        if (!codec) 
+        {
+            fprintf(stderr, "Could not find video decoder, key frames will not be honored\n");
+        }
+
+        if (avcodec_open(video_st->codec, codec) < 0) 
+        {
+            fprintf(stderr, "Could not open video decoder, key frames will not be honored\n");
+        }
+    }
+
+    ++output_index;
+
+    if (url_open_dyn_buf(&oc->pb) < 0) 
+    {
+        fprintf(stderr, "Could not open dynamic buffer\n");
+        exit(1);
+    }
+
+    if ((err = av_write_header(oc)) != 0) 
+    {
+        fprintf(stderr, "Could not write mpegts header to first output file: %i\n", err);
+        exit(1);
+    }
+
+    // fprintf(stderr, "Input context has timestamp:%lld, start_time:%lld\n", ic->timestamp, ic->start_time);
+
+    if (video_index != -1)
+    {
+        ts_offset = (double)(segment_offset * segment_duration) * video_st->time_base.den / video_st->time_base.num;
+    }
+    else if (audio_index != -1)
+    {
+        ts_offset = (double)(segment_offset * segment_duration) * audio_st->time_base.den / audio_st->time_base.num;
+    }
+
+    fprintf(stderr, "Offsetting timestamps by:%f\n", ts_offset);
+    prev_segment_time += segment_offset * segment_duration;
+
+    do 
+    {
+        double segment_time;
+        AVPacket packet;
+
+        decode_done = av_read_frame(ic, &packet);
+        if (decode_done < 0) 
+        {
+            break;
+        }
+
+        if (av_dup_packet(&packet) < 0) 
+        {
+            fprintf(stderr, "Could not duplicate packet");
+            av_free_packet(&packet);
+            break;
+        }
+
+        packet.pts += ts_offset;
+        packet.dts += ts_offset;
+        // fprintf(stderr, "Packet pts: %f\n", (double)packet.pts * audio_st->time_base.num / audio_st->time_base.den);
+
+        if (video_st && packet.stream_index == video_index && (packet.flags & PKT_FLAG_KEY)) 
+        {
+            segment_time = (double)video_st->pts.val * video_st->time_base.num / video_st->time_base.den;
+        }
+        else if (video_index == -1) 
+        {
+            segment_time = (double)audio_st->pts.val * audio_st->time_base.num / audio_st->time_base.den;
+        }
+        else 
+        {
+            segment_time = prev_segment_time;
+        }
+
+        if (segment_time - prev_segment_time >= segment_duration) 
+        {
+            put_flush_packet(oc->pb);
+
+            if ((output_index -1) % 5 == 0)
+            {
+                fprintf(stderr, "Wrote segment %d\n", output_index - 1);
+                fflush(stderr);
+            }
+
+            ++output_index;
+
+            prev_segment_time += segment_duration;
+            
+            segmenter_close_io(oc->pb, 1);
+        }
+        else
+        {
+            segmenter_close_io(oc->pb, 0);
+        }
+
+
+        if (url_open_dyn_buf(&oc->pb) < 0) 
+        {
+            fprintf(stderr, "Could not open dynamic buffer\n");
+            break;
+	}   
+
+        ret = av_interleaved_write_frame(oc, &packet);
+        if (ret < 0) 
+        {
+            fprintf(stderr, "Could not write frame of stream\n");
+            av_free_packet(&packet);
+            break;
+        }
+        else if (ret > 0) 
+        {
+            fprintf(stderr, "End of stream requested\n");
+            av_free_packet(&packet);
+            break;
+        }
+
+        av_free_packet(&packet);
+    } 
+    while (!decode_done);
+
+    av_write_trailer(oc);
+
+    if (video_st)
+    {
+        avcodec_close(video_st->codec);
+    }
+
+    for(i = 0; i < oc->nb_streams; i++) 
+    {
+        av_freep(&oc->streams[i]->codec);
+        av_freep(&oc->streams[i]);
+    }
+
+    segmenter_close_io(oc->pb, 1);
+    av_free(oc);
+
+    fprintf(stderr, "Wrote segment %d -- final\n", output_index - 1);
+    fflush(stderr);
+
+    return 0;
+}
+
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/_snapshot ffmpeg-for-2.2.5/_snapshot
--- ffmpeg-r21659/_snapshot	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/_snapshot	2010-02-07 11:46:15.000000000 -0700
@@ -0,0 +1,12 @@
+#!/bin/sh
+mkdir ../ffmpeg.tmp
+mkdir ../ffmpeg.tmp/ffmpeg
+cp -R * ../ffmpeg.tmp/ffmpeg
+cd ../ffmpeg.tmp/ffmpeg
+rm -Rf .git
+rm -rf `find . -type d -name .svn`
+make distclean
+cd ..
+tar -c -L ffmpeg > ../ffmpeg.tar
+cd ..
+rm -Rf ffmpeg.tmp
\ No newline at end of file
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/_unicode.c ffmpeg-for-2.2.5/_unicode.c
--- ffmpeg-r21659/_unicode.c	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/_unicode.c	2010-02-07 13:03:10.000000000 -0700
@@ -0,0 +1,36 @@
+
+#if HAVE_WINSOCK2_H == 1 
+
+wchar_t * __s2ws(char *s)
+{	
+	int len = strlen(s);
+	wchar_t *res = av_malloc((len + 1) * sizeof(wchar_t));
+	int i = 0;
+	while (*s != 0)
+	{
+		if (s[0] == '\\' && s[1] == 'u')
+		{
+			char number [5];			
+			int value;
+			strncpy(number, s + 2, 4);
+			sscanf(number, "%x", &value);
+			res[i] = value;
+			s+=5;
+		}
+		else if (s[0] == '\\' && s[1] == '\\')
+		{
+			res[i] = s[0];
+			s += 1;
+		}
+		else
+		{
+			res[i] = s[0];	
+		}
+		++i;
+		++s;
+	}
+	res[i] = 0;
+	return res;
+}
+
+#endif
\ No newline at end of file
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/_unicode.h ffmpeg-for-2.2.5/_unicode.h
--- ffmpeg-r21659/_unicode.h	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/_unicode.h	2010-02-07 13:03:13.000000000 -0700
@@ -0,0 +1,13 @@
+
+#ifndef __unicode_h__
+#define __unicode_h__
+
+#if HAVE_WINSOCK2_H == 1 
+
+extern wchar_t * __s2ws(char *s);
+
+#define open(name, flags, mode) _wopen(__s2ws(name), flags, mode);
+
+#endif
+
+#endif 
\ No newline at end of file
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/configure ffmpeg-for-2.2.5/configure
--- ffmpeg-r21659/configure	2010-08-03 08:01:05.000000000 -0600
+++ ffmpeg-for-2.2.5/configure	2010-02-07 11:46:26.000000000 -0700
@@ -2500,6 +2500,8 @@
         add_extralibs -pthreads
     elif check_func pthread_create -lpthreadGC2; then
         add_extralibs -lpthreadGC2
+    elif check_func pthread_create -lpthreadGC2 -lwsock32; then
+        add_extralibs -lpthreadGC2 -lwsock32
     elif ! check_lib pthread.h pthread_create -lpthread; then
         die "ERROR: can't find pthreads library"
     fi
@@ -2545,7 +2547,7 @@
 enabled libspeex   && require  libspeex speex/speex.h speex_decoder_init -lspeex
 enabled libtheora  && require  libtheora theora/theoraenc.h th_info_init -ltheoraenc -ltheoradec -logg
 enabled libvorbis  && require  libvorbis vorbis/vorbisenc.h vorbis_info_init -lvorbisenc -lvorbis -logg
-enabled libx264    && require  libx264 x264.h x264_encoder_encode -lx264 -lm &&
+enabled libx264    && require  libx264 x264.h x264_encoder_encode $(pkg-config --libs x264) &&
                       { check_cpp_condition x264.h "X264_BUILD >= 83" ||
                         die "ERROR: libx264 version must be >= 0.83."; }
 enabled libxvid    && require  libxvid xvid.h xvid_global -lxvidcore
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/configure.orig ffmpeg-for-2.2.5/configure.orig
--- ffmpeg-r21659/configure.orig	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/configure.orig	2010-02-07 11:46:26.000000000 -0700
@@ -0,0 +1,3087 @@
+#!/bin/sh
+#
+# FFmpeg configure script
+#
+# Copyright (c) 2000-2002 Fabrice Bellard
+# Copyright (c) 2005-2008 Diego Biurrun
+# Copyright (c) 2005-2008 Mans Rullgard
+#
+
+# Prevent locale nonsense from breaking basic text processing.
+LC_ALL=C
+export LC_ALL
+
+# make sure we are running under a compatible shell
+# try to make this part work with most shells
+
+try_exec(){
+    echo "Trying shell $1"
+    type "$1" > /dev/null 2>&1 && exec "$@"
+}
+
+unset foo
+(: ${foo%%bar}) 2> /dev/null
+E1="$?"
+
+(: ${foo?}) 2> /dev/null
+E2="$?"
+
+if test "$E1" != 0 || test "$E2" = 0; then
+    echo "Broken shell detected.  Trying alternatives."
+    export FF_CONF_EXEC
+    if test "0$FF_CONF_EXEC" -lt 1; then
+        FF_CONF_EXEC=1
+        try_exec bash "$0" "$@"
+    fi
+    if test "0$FF_CONF_EXEC" -lt 2; then
+        FF_CONF_EXEC=2
+        try_exec ksh "$0" "$@"
+    fi
+    if test "0$FF_CONF_EXEC" -lt 3; then
+        FF_CONF_EXEC=3
+        try_exec /usr/xpg4/bin/sh "$0" "$@"
+    fi
+    echo "No compatible shell script interpreter found."
+    echo "This configure script requires a POSIX-compatible shell"
+    echo "such as bash or ksh."
+    echo "THIS IS NOT A BUG IN FFMPEG, DO NOT REPORT IT AS SUCH."
+    echo "Instead, install a working POSIX-compatible shell."
+    echo "Disabling this configure test will create a broken FFmpeg."
+    if test "$BASH_VERSION" = '2.04.0(1)-release'; then
+        echo "This bash version ($BASH_VERSION) is broken on your platform."
+        echo "Upgrade to a later version if available."
+    fi
+    exit 1
+fi
+
+show_help(){
+cat <<EOF
+Usage: configure [options]
+Options: [defaults in brackets after descriptions]
+
+Standard options:
+  --help                   print this message
+  --logfile=FILE           log tests and output to FILE [config.err]
+  --disable-logging        do not log configure debug information
+  --prefix=PREFIX          install in PREFIX [$prefix]
+  --bindir=DIR             install binaries in DIR [PREFIX/bin]
+  --datadir=DIR            install data files in DIR [PREFIX/share/ffmpeg]
+  --libdir=DIR             install libs in DIR [PREFIX/lib]
+  --shlibdir=DIR           install shared libs in DIR [PREFIX/lib]
+  --incdir=DIR             install includes in DIR [PREFIX/include]
+  --mandir=DIR             install man page in DIR [PREFIX/share/man]
+
+Configuration options:
+  --disable-static         do not build static libraries [no]
+  --enable-shared          build shared libraries [no]
+  --enable-gpl             allow use of GPL code, the resulting libs
+                           and binaries will be under GPL [no]
+  --enable-version3        upgrade (L)GPL to version 3 [no]
+  --enable-nonfree         allow use of nonfree code, the resulting libs
+                           and binaries will be unredistributable [no]
+  --disable-doc            do not build documentation
+  --disable-ffmpeg         disable ffmpeg build
+  --disable-ffplay         disable ffplay build
+  --disable-ffserver       disable ffserver build
+  --disable-avdevice       disable libavdevice build
+  --disable-avcodec        disable libavcodec build
+  --disable-avformat       disable libavformat build
+  --disable-swscale        disable libswscale build
+  --enable-postproc        enable GPLed postprocessing support [no]
+  --enable-avfilter        video filter support [no]
+  --enable-avfilter-lavf   video filters dependent on avformat [no]
+  --enable-beosthreads     use BeOS threads [no]
+  --enable-os2threads      use OS/2 threads [no]
+  --enable-pthreads        use pthreads [no]
+  --enable-w32threads      use Win32 threads [no]
+  --enable-x11grab         enable X11 grabbing [no]
+  --disable-network        disable network support [no]
+  --disable-mpegaudio-hp   faster (but less accurate) MPEG audio decoding [no]
+  --enable-gray            enable full grayscale support (slower color)
+  --disable-swscale-alpha  disable alpha channel support in swscale
+  --disable-fastdiv        disable table-based division
+  --enable-small           optimize for size instead of speed
+  --disable-aandct         disable AAN DCT code
+  --disable-dct            disable DCT code
+  --disable-fft            disable FFT code
+  --disable-golomb         disable Golomb code
+  --disable-lpc            disable LPC code
+  --disable-mdct           disable MDCT code
+  --disable-rdft           disable RDFT code
+  --disable-vaapi          disable VAAPI code
+  --disable-vdpau          disable VDPAU code
+  --disable-dxva2          disable DXVA2 code
+  --enable-runtime-cpudetect detect cpu capabilities at runtime (bigger binary)
+  --enable-hardcoded-tables use hardcoded tables instead of runtime generation
+  --enable-memalign-hack   emulate memalign, interferes with memory debuggers
+  --enable-beos-netserver  enable BeOS netserver
+  --disable-encoder=NAME   disable encoder NAME
+  --enable-encoder=NAME    enable encoder NAME
+  --disable-encoders       disable all encoders
+  --disable-decoder=NAME   disable decoder NAME
+  --enable-decoder=NAME    enable decoder NAME
+  --disable-decoders       disable all decoders
+  --disable-hwaccel=NAME   disable hwaccel NAME
+  --enable-hwaccel=NAME    enable hwaccel NAME
+  --disable-hwaccels       disable all hwaccels
+  --disable-muxer=NAME     disable muxer NAME
+  --enable-muxer=NAME      enable muxer NAME
+  --disable-muxers         disable all muxers
+  --disable-demuxer=NAME   disable demuxer NAME
+  --enable-demuxer=NAME    enable demuxer NAME
+  --disable-demuxers       disable all demuxers
+  --enable-parser=NAME     enable parser NAME
+  --disable-parser=NAME    disable parser NAME
+  --disable-parsers        disable all parsers
+  --enable-bsf=NAME        enable bitstream filter NAME
+  --disable-bsf=NAME       disable bitstream filter NAME
+  --disable-bsfs           disable all bitstream filters
+  --enable-protocol=NAME   enable protocol NAME
+  --disable-protocol=NAME  disable protocol NAME
+  --disable-protocols      disable all protocols
+  --disable-indev=NAME     disable input device NAME
+  --disable-outdev=NAME    disable output device NAME
+  --disable-indevs         disable input devices
+  --disable-outdevs        disable output devices
+  --disable-devices        disable all devices
+  --enable-filter=NAME     enable filter NAME
+  --disable-filter=NAME    disable filter NAME
+  --disable-filters        disable all filters
+  --list-decoders          show all available decoders
+  --list-encoders          show all available encoders
+  --list-hwaccels          show all available hardware accelerators
+  --list-muxers            show all available muxers
+  --list-demuxers          show all available demuxers
+  --list-parsers           show all available parsers
+  --list-protocols         show all available protocols
+  --list-bsfs              show all available bitstream filters
+  --list-indevs            show all available input devices
+  --list-outdevs           show all available output devices
+  --list-filters           show all available filters
+
+External library support:
+  --enable-avisynth        enable reading of AVISynth script files [no]
+  --enable-bzlib           enable bzlib [autodetect]
+  --enable-libopencore-amrnb enable AMR-NB de/encoding via libopencore-amrnb [no]
+  --enable-libopencore-amrwb enable AMR-WB decoding via libopencore-amrwb [no]
+  --enable-libdc1394       enable IIDC-1394 grabbing using libdc1394
+                           and libraw1394 [no]
+  --enable-libdirac        enable Dirac support via libdirac [no]
+  --enable-libfaac         enable FAAC support via libfaac [no]
+  --enable-libfaad         enable FAAD support via libfaad [no]
+  --enable-libfaadbin      open libfaad.so.0 at runtime [no]
+  --enable-libgsm          enable GSM support via libgsm [no]
+  --enable-libmp3lame      enable MP3 encoding via libmp3lame [no]
+  --enable-libnut          enable NUT (de)muxing via libnut,
+                           native (de)muxer exists [no]
+  --enable-libopenjpeg     enable JPEG 2000 decoding via OpenJPEG [no]
+  --enable-libschroedinger enable Dirac support via libschroedinger [no]
+  --enable-libspeex        enable Speex decoding via libspeex [no]
+  --enable-libtheora       enable Theora encoding via libtheora [no]
+  --enable-libvorbis       enable Vorbis encoding via libvorbis,
+                           native implementation exists [no]
+  --enable-libx264         enable H.264 encoding via x264 [no]
+  --enable-libxvid         enable Xvid encoding via xvidcore,
+                           native MPEG-4/Xvid encoder exists [no]
+  --enable-mlib            enable Sun medialib [no]
+  --enable-zlib            enable zlib [autodetect]
+
+Advanced options (experts only):
+  --source-path=PATH       path to source code [$source_path]
+  --cross-prefix=PREFIX    use PREFIX for compilation tools [$cross_prefix]
+  --enable-cross-compile   assume a cross-compiler is used
+  --sysroot=PATH           root of cross-build tree
+  --sysinclude=PATH        location of cross-build system headers
+  --target-os=OS           compiler targets OS [$target_os]
+  --target-exec=CMD        command to run executables on target
+  --target-path=DIR        path to view of build directory on target
+  --nm=NM                  use nm tool
+  --as=AS                  use assembler AS [$as_default]
+  --cc=CC                  use C compiler CC [$cc_default]
+  --ld=LD                  use linker LD
+  --host-cc=HOSTCC         use host C compiler HOSTCC
+  --host-cflags=HCFLAGS    use HCFLAGS when compiling for host
+  --host-ldflags=HLDFLAGS  use HLDFLAGS when linking for host
+  --host-libs=HLIBS        use libs HLIBS when linking for host
+  --extra-cflags=ECFLAGS   add ECFLAGS to CFLAGS [$CFLAGS]
+  --extra-ldflags=ELDFLAGS add ELDFLAGS to LDFLAGS [$LDFLAGS]
+  --extra-libs=ELIBS       add ELIBS [$ELIBS]
+  --extra-version=STRING   version string suffix []
+  --build-suffix=SUFFIX    library name suffix []
+  --arch=ARCH              select architecture [$arch]
+  --cpu=CPU                select the minimum required CPU (affects
+                           instruction selection, may crash on older CPUs)
+  --enable-powerpc-perf    enable performance report on PPC
+                           (requires enabling PMC)
+  --disable-asm            disable all assembler optimizations
+  --disable-altivec        disable AltiVec optimizations
+  --disable-amd3dnow       disable 3DNow! optimizations
+  --disable-amd3dnowext    disable 3DNow! extended optimizations
+  --disable-mmx            disable MMX optimizations
+  --disable-mmx2           disable MMX2 optimizations
+  --disable-sse            disable SSE optimizations
+  --disable-ssse3          disable SSSE3 optimizations
+  --disable-armv5te        disable armv5te optimizations
+  --disable-armv6          disable armv6 optimizations
+  --disable-armv6t2        disable armv6t2 optimizations
+  --disable-armvfp         disable ARM VFP optimizations
+  --disable-iwmmxt         disable iwmmxt optimizations
+  --disable-mmi            disable MMI optimizations
+  --disable-neon           disable neon optimizations
+  --disable-vis            disable VIS optimizations
+  --disable-yasm           disable use of yasm assembler
+  --enable-pic             build position-independent code
+  --malloc-prefix=PFX      prefix malloc and related names with PFX
+  --enable-sram            allow use of on-chip SRAM
+
+Developer options (useful when working on FFmpeg itself):
+  --disable-debug          disable debugging symbols
+  --enable-debug=LEVEL     set the debug level [$debuglevel]
+  --enable-gprof           enable profiling with gprof [$gprof]
+  --disable-optimizations  disable compiler optimizations
+  --enable-extra-warnings  enable more compiler warnings
+  --disable-stripping      disable stripping of executables and shared libraries
+
+NOTE: Object files are built at the place where configure is launched.
+EOF
+  exit 0
+}
+
+log(){
+    echo "$@" >> $logfile
+}
+
+log_file(){
+    log BEGIN $1
+    pr -n -t $1 >> $logfile
+    log END $1
+}
+
+echolog(){
+    log "$@"
+    echo "$@"
+}
+
+die(){
+    echolog "$@"
+    cat <<EOF
+
+If you think configure made a mistake, make sure you are using the latest
+version from SVN.  If the latest version fails, report the problem to the
+ffmpeg-user@mplayerhq.hu mailing list or IRC #ffmpeg on irc.freenode.net.
+EOF
+    if disabled logging; then
+        cat <<EOF
+Rerun configure with logging enabled (do not use --disable-logging), and
+include the log this produces with your report.
+EOF
+    else
+cat <<EOF
+Include the log file "$logfile" produced by configure as this will help
+solving the problem.
+EOF
+    fi
+    exit 1
+}
+
+# Avoid locale weirdness, besides we really just want to translate ASCII.
+toupper(){
+    echo "$@" | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
+}
+
+tolower(){
+    echo "$@" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz
+}
+
+c_escape(){
+    echo "$*" | sed 's/["\\]/\\\0/g'
+}
+
+sh_quote(){
+    v=$(echo "$1" | sed "s/'/'\\\\''/g")
+    test "$v" = "${v#*[ |&;<>()$\`\\\"\'*?\[\]#~=%]}" || v="'$v'"
+    echo "$v"
+}
+
+filter(){
+    pat=$1
+    shift
+    for v; do
+        eval "case $v in $pat) echo $v ;; esac"
+    done
+}
+
+set_all(){
+    value=$1
+    shift
+    for var in $*; do
+        eval $var=$value
+    done
+}
+
+set_weak(){
+    value=$1
+    shift
+    for var; do
+        eval : \${$var:=$value}
+    done
+}
+
+pushvar(){
+    for var in $*; do
+        eval level=\${${var}_level:=0}
+        eval ${var}_${level}="\$$var"
+        eval ${var}_level=$(($level+1))
+    done
+}
+
+popvar(){
+    for var in $*; do
+        eval level=\${${var}_level:-0}
+        test $level = 0 && continue
+        eval level=$(($level-1))
+        eval $var="\${${var}_${level}}"
+        eval ${var}_level=$level
+        eval unset ${var}_${level}
+    done
+}
+
+enable(){
+    set_all yes $*
+}
+
+disable(){
+    set_all no $*
+}
+
+enable_weak(){
+    set_weak yes $*
+}
+
+disable_weak(){
+    set_weak no $*
+}
+
+enable_safe(){
+    for var; do
+        enable $(echo "$var" | sed 's/[^A-Za-z0-9_]/_/g')
+    done
+}
+
+disable_safe(){
+    for var; do
+        disable $(echo "$var" | sed 's/[^A-Za-z0-9_]/_/g')
+    done
+}
+
+do_enable_deep(){
+    for var; do
+        enabled $var && continue
+        eval sel="\$${var}_select"
+        eval sgs="\$${var}_suggest"
+        pushvar var sgs
+        enable_deep $sel
+        popvar sgs
+        enable_deep_weak $sgs
+        popvar var
+    done
+}
+
+enable_deep(){
+    do_enable_deep $*
+    enable $*
+}
+
+enable_deep_weak(){
+    do_enable_deep $*
+    enable_weak $*
+}
+
+enabled(){
+    test "${1#!}" = "$1" && op== || op=!=
+    eval test "x\$${1#!}" $op "xyes"
+}
+
+disabled(){
+    test "${1#!}" = "$1" && op== || op=!=
+    eval test "x\$${1#!}" $op "xno"
+}
+
+enabled_all(){
+    for opt; do
+        enabled $opt || return 1
+    done
+}
+
+disabled_all(){
+    for opt; do
+        disabled $opt || return 1
+    done
+}
+
+enabled_any(){
+    for opt; do
+        enabled $opt && return 0
+    done
+}
+
+disabled_any(){
+    for opt; do
+        disabled $opt && return 0
+    done
+    return 1
+}
+
+set_default(){
+    for opt; do
+        eval : \${$opt:=\$${opt}_default}
+    done
+}
+
+is_in(){
+    value=$1
+    shift
+    for var in $*; do
+        [ $var = $value ] && return 0
+    done
+    return 1
+}
+
+check_deps(){
+    for cfg; do
+        cfg="${cfg#!}"
+        enabled ${cfg}_checking && die "Circular dependency for $cfg."
+        disabled ${cfg}_checking && continue
+        enable ${cfg}_checking
+
+        eval dep_all="\$${cfg}_deps"
+        eval dep_any="\$${cfg}_deps_any"
+        eval dep_sel="\$${cfg}_select"
+        eval dep_sgs="\$${cfg}_suggest"
+        eval dep_ifa="\$${cfg}_if"
+        eval dep_ifn="\$${cfg}_if_any"
+
+        pushvar cfg dep_all dep_any dep_sel dep_sgs dep_ifa dep_ifn
+        check_deps $dep_all $dep_any $dep_sel $dep_sgs $dep_ifa $dep_ifn
+        popvar cfg dep_all dep_any dep_sel dep_sgs dep_ifa dep_ifn
+
+        [ -n "$dep_ifa" ] && { enabled_all $dep_ifa && enable_weak $cfg; }
+        [ -n "$dep_ifn" ] && { enabled_any $dep_ifn && enable_weak $cfg; }
+        enabled_all  $dep_all || disable $cfg
+        enabled_any  $dep_any || disable $cfg
+        disabled_any $dep_sel && disable $cfg
+
+        if enabled $cfg; then
+            eval dep_extralibs="\$${cfg}_extralibs"
+            test -n "$dep_extralibs" && add_extralibs $dep_extralibs
+            enable_deep $dep_sel
+            enable_deep_weak $dep_sgs
+        fi
+
+        disable ${cfg}_checking
+    done
+}
+
+print_config(){
+    pfx=$1
+    header=$2
+    makefile=$3
+    shift 3
+    for cfg; do
+        ucname="$(toupper $cfg)"
+        if enabled $cfg; then
+            echo "#define ${pfx}${ucname} 1" >> $header
+            echo "${pfx}${ucname}=yes" >> $makefile
+        else
+            echo "#define ${pfx}${ucname} 0" >> $header
+            echo "!${pfx}${ucname}=yes" >> $makefile
+        fi
+    done
+}
+
+flags_saved(){
+    (: ${SAVE_CFLAGS?}) 2> /dev/null
+}
+
+save_flags(){
+    flags_saved && return
+    SAVE_CFLAGS="$CFLAGS"
+    SAVE_LDFLAGS="$LDFLAGS"
+    SAVE_extralibs="$extralibs"
+}
+
+restore_flags(){
+    flags_saved || return
+    CFLAGS="$SAVE_CFLAGS"
+    LDFLAGS="$SAVE_LDFLAGS"
+    extralibs="$SAVE_extralibs"
+    unset SAVE_CFLAGS
+    unset SAVE_LDFLAGS
+    unset SAVE_extralibs
+}
+
+temp_cflags(){
+    save_flags
+    CFLAGS="$CFLAGS $*"
+}
+
+temp_ldflags(){
+    save_flags
+    LDFLAGS="$LDFLAGS $*"
+}
+
+temp_extralibs(){
+    save_flags
+    extralibs="$extralibs $*"
+}
+
+append(){
+    var=$1
+    shift
+    flags_saved && eval "SAVE_$var=\"\$SAVE_$var $*\""
+    eval "$var=\"\$$var $*\""
+}
+
+add_cppflags(){
+    append CPPFLAGS $($filter_cppflags "$@")
+}
+
+add_cflags(){
+    append CFLAGS $($filter_cflags "$@")
+}
+
+add_asflags(){
+    append ASFLAGS $($filter_asflags "$@")
+}
+
+add_ldflags(){
+    append LDFLAGS "$@"
+}
+
+add_extralibs(){
+    append extralibs "$@"
+}
+
+check_cmd(){
+    log "$@"
+    "$@" >> $logfile 2>&1
+}
+
+check_cc(){
+    log check_cc "$@"
+    cat > $TMPC
+    log_file $TMPC
+    check_cmd $cc $CPPFLAGS $CFLAGS "$@" -c -o $TMPO $TMPC
+}
+
+check_cpp(){
+    log check_cpp "$@"
+    cat > $TMPC
+    log_file $TMPC
+    check_cmd $cc $CPPFLAGS $CFLAGS "$@" -E -o $TMPO $TMPC
+}
+
+check_as(){
+    log check_as "$@"
+    cat > $TMPC
+    log_file $TMPC
+    check_cmd $as $CPPFLAGS $ASFLAGS "$@" -c -o $TMPO $TMPC
+}
+
+check_asm(){
+    log check_asm "$@"
+    name="$1"
+    code="$2"
+    shift 2
+    disable $name
+    check_as "$@" <<EOF && enable $name
+void foo(void){ __asm__ volatile($code); }
+EOF
+}
+
+check_yasm(){
+    log check_yasm "$@"
+    echo "$1" > $TMPS
+    log_file $TMPS
+    shift 1
+    check_cmd $yasmexe $YASMFLAGS "$@" -o $TMPO $TMPS
+}
+
+check_ld(){
+    log check_ld "$@"
+    flags=''
+    libs=''
+    for f; do
+        test "${f}" = "${f#-l}" && flags="$flags $f" || libs="$libs $f"
+    done
+    check_cc $($filter_cflags $flags) || return
+    check_cmd $ld $LDFLAGS $flags -o $TMPE $TMPO $extralibs $libs
+}
+
+check_cppflags(){
+    log check_cppflags "$@"
+    set -- $($filter_cppflags "$@")
+    check_cc "$@" <<EOF && append CPPFLAGS "$@"
+int x;
+EOF
+}
+
+check_cflags(){
+    log check_cflags "$@"
+    set -- $($filter_cflags "$@")
+    check_cc "$@" <<EOF && append CFLAGS "$@"
+int x;
+EOF
+}
+
+test_ldflags(){
+    log test_ldflags "$@"
+    check_ld "$@" <<EOF
+int main(void){ return 0; }
+EOF
+}
+
+check_ldflags(){
+    log check_ldflags "$@"
+    test_ldflags "$@" && add_ldflags "$@"
+}
+
+check_header(){
+    log check_header "$@"
+    header=$1
+    shift
+    disable_safe $header
+    check_cpp "$@" <<EOF && enable_safe $header
+#include <$header>
+int x;
+EOF
+}
+
+check_func(){
+    log check_func "$@"
+    func=$1
+    shift
+    disable $func
+    check_ld "$@" <<EOF && enable $func
+extern int $func();
+int main(void){ $func(); }
+EOF
+}
+
+check_func_headers(){
+    log check_func_headers "$@"
+    headers=$1
+    func=$2
+    shift 2
+    disable $func
+    incs=""
+    for hdr in $headers; do
+        incs="$incs
+#include <$hdr>"
+    done
+    check_ld "$@" <<EOF && enable $func && enable_safe $headers
+$incs
+int main(int argc, char **argv){
+    return (long) $func;
+}
+EOF
+}
+
+check_cpp_condition(){
+    log check_cpp_condition "$@"
+    header=$1
+    condition=$2
+    shift 2
+    check_cpp $($filter_cppflags "$@") <<EOF
+#include <$header>
+#if !($condition)
+#error "unsatisfied condition: $condition"
+#endif
+EOF
+}
+
+check_lib(){
+    log check_lib "$@"
+    header="$1"
+    func="$2"
+    shift 2
+    temp_extralibs "$@"
+    check_header $header && check_func $func && add_extralibs "$@"
+    err=$?
+    restore_flags
+    return $err
+}
+
+check_lib2(){
+    log check_lib2 "$@"
+    headers="$1"
+    func="$2"
+    shift 2
+    check_func_headers "$headers" $func "$@" && add_extralibs "$@"
+}
+
+check_exec(){
+    check_ld "$@" && { enabled cross_compile || $TMPE >> $logfile 2>&1; }
+}
+
+check_exec_crash(){
+    code=$(cat)
+
+    # exit() is not async signal safe.  _Exit (C99) and _exit (POSIX)
+    # are safe but may not be available everywhere.  Thus we use
+    # raise(SIGTERM) instead.  The check is run in a subshell so we
+    # can redirect the "Terminated" message from the shell.  SIGBUS
+    # is not defined by standard C so it is used conditionally.
+
+    (check_exec "$@") >> $logfile 2>&1 <<EOF
+#include <signal.h>
+static void sighandler(int sig){
+    raise(SIGTERM);
+}
+int main(void){
+    signal(SIGILL, sighandler);
+    signal(SIGFPE, sighandler);
+    signal(SIGSEGV, sighandler);
+#ifdef SIGBUS
+    signal(SIGBUS, sighandler);
+#endif
+    { $code }
+}
+EOF
+}
+
+check_type(){
+    log check_type "$@"
+    headers=$1
+    type=$2
+    shift 2
+    disable_safe "$type"
+    incs=""
+    for hdr in $headers; do
+        incs="$incs
+#include <$hdr>"
+    done
+    check_cc "$@" <<EOF && enable_safe "$type"
+$incs
+$type v;
+EOF
+}
+
+check_struct(){
+    log check_type "$@"
+    headers=$1
+    struct=$2
+    member=$3
+    shift 3
+    disable_safe "${struct}_${member}"
+    incs=""
+    for hdr in $headers; do
+        incs="$incs
+#include <$hdr>"
+    done
+    check_cc "$@" <<EOF && enable_safe "${struct}_${member}"
+$incs
+const void *p = &(($struct *)0)->$member;
+EOF
+}
+
+require(){
+    name="$1"
+    header="$2"
+    func="$3"
+    shift 3
+    check_lib $header $func "$@" || die "ERROR: $name not found"
+}
+
+require2(){
+    name="$1"
+    headers="$2"
+    func="$3"
+    shift 3
+    check_lib2 "$headers" $func "$@" || die "ERROR: $name not found"
+}
+
+check_foo_config(){
+    cfg=$1
+    pkg=$2
+    header=$3
+    func=$4
+    shift 4
+    disable $cfg
+    check_cmd ${pkg}-config --version
+    err=$?
+    if test "$err" = 0; then
+        temp_cflags $(${pkg}-config --cflags)
+        temp_extralibs $(${pkg}-config --libs)
+        check_lib "$@" $header $func && enable $cfg
+    fi
+    return $err
+}
+
+check_host_cc(){
+    log check_host_cc "$@"
+    cat > $TMPC
+    log_file $TMPC
+    check_cmd $host_cc $host_cflags "$@" -c -o $TMPO $TMPC
+}
+
+check_host_cflags(){
+    log check_host_cflags "$@"
+    check_host_cc "$@" <<EOF && append host_cflags "$@"
+int x;
+EOF
+}
+
+apply(){
+    file=$1
+    shift
+    "$@" < "$file" > "$file.tmp" && mv "$file.tmp" "$file" || rm "$file.tmp"
+}
+
+cp_if_changed(){
+    cmp -s "$1" "$2" &&
+        echo "$2 is unchanged" ||
+        cp -f "$1" "$2"
+}
+
+# CONFIG_LIST contains configurable options, while HAVE_LIST is for
+# system-dependent things.
+
+COMPONENT_LIST="
+    bsfs
+    decoders
+    demuxers
+    encoders
+    filters
+    hwaccels
+    indevs
+    muxers
+    outdevs
+    parsers
+    protocols
+"
+
+CONFIG_LIST="
+    $COMPONENT_LIST
+    aandct
+    avcodec
+    avdevice
+    avfilter
+    avfilter_lavf
+    avformat
+    avisynth
+    beos_netserver
+    bzlib
+    dct
+    doc
+    dxva2
+    fastdiv
+    ffmpeg
+    ffplay
+    ffserver
+    fft
+    golomb
+    gpl
+    gprof
+    gray
+    hardcoded_tables
+    libdc1394
+    libdirac
+    libfaac
+    libfaad
+    libfaadbin
+    libgsm
+    libmp3lame
+    libnut
+    libopencore_amrnb
+    libopencore_amrwb
+    libopenjpeg
+    libschroedinger
+    libspeex
+    libtheora
+    libvorbis
+    libx264
+    libxvid
+    lpc
+    mdct
+    memalign_hack
+    mlib
+    mpegaudio_hp
+    network
+    nonfree
+    pic
+    postproc
+    powerpc_perf
+    rdft
+    runtime_cpudetect
+    shared
+    small
+    sram
+    static
+    swscale
+    swscale_alpha
+    vaapi
+    vdpau
+    version3
+    x11grab
+    zlib
+"
+
+THREADS_LIST='
+    beosthreads
+    os2threads
+    pthreads
+    w32threads
+'
+
+ARCH_LIST='
+    alpha
+    arm
+    avr32
+    avr32_ap
+    avr32_uc
+    bfin
+    ia64
+    m68k
+    mips
+    mips64
+    parisc
+    ppc
+    ppc64
+    s390
+    sh4
+    sparc
+    sparc64
+    x86
+    x86_32
+    x86_64
+'
+
+ARCH_EXT_LIST='
+    altivec
+    amd3dnow
+    amd3dnowext
+    armv5te
+    armv6
+    armv6t2
+    armvfp
+    iwmmxt
+    mmi
+    mmx
+    mmx2
+    neon
+    ppc4xx
+    sse
+    ssse3
+    vis
+'
+
+HAVE_LIST_PUB='
+    bigendian
+'
+
+HAVE_LIST="
+    $ARCH_EXT_LIST
+    $HAVE_LIST_PUB
+    $THREADS_LIST
+    alsa_asoundlib_h
+    altivec_h
+    arpa_inet_h
+    attribute_may_alias
+    attribute_packed
+    bswap
+    closesocket
+    cmov
+    conio_h
+    dcbzl
+    dev_bktr_ioctl_bt848_h
+    dev_bktr_ioctl_meteor_h
+    dev_ic_bt8xx_h
+    dev_video_meteor_ioctl_meteor_h
+    dev_video_bktr_ioctl_bt848_h
+    dlfcn_h
+    dlopen
+    dos_paths
+    ebp_available
+    ebx_available
+    exp2
+    exp2f
+    fast_64bit
+    fast_clz
+    fast_cmov
+    fast_unaligned
+    fork
+    getaddrinfo
+    gethrtime
+    GetProcessTimes
+    getrusage
+    inet_aton
+    inline_asm
+    isatty
+    ldbrx
+    libdc1394_1
+    libdc1394_2
+    llrint
+    log2
+    log2f
+    loongson
+    lrint
+    lrintf
+    lzo1x_999_compress
+    machine_ioctl_bt848_h
+    machine_ioctl_meteor_h
+    malloc_h
+    memalign
+    mkstemp
+    pld
+    posix_memalign
+    round
+    roundf
+    sdl
+    sdl_video_size
+    setmode
+    socklen_t
+    soundcard_h
+    poll_h
+    struct_addrinfo
+    struct_ipv6_mreq
+    struct_sockaddr_in6
+    struct_sockaddr_sa_len
+    struct_sockaddr_storage
+    sys_mman_h
+    sys_resource_h
+    sys_select_h
+    sys_soundcard_h
+    sys_videoio_h
+    ten_operands
+    termios_h
+    threads
+    truncf
+    vfp_args
+    VirtualAlloc
+    winsock2_h
+    xform_asm
+    yasm
+"
+
+# options emitted with CONFIG_ prefix but not available on command line
+CONFIG_EXTRA="
+    avutil
+    gplv3
+    lgplv3
+"
+
+CMDLINE_SELECT="
+    $ARCH_EXT_LIST
+    $CONFIG_LIST
+    $THREADS_LIST
+    asm
+    cross_compile
+    debug
+    extra_warnings
+    logging
+    optimizations
+    stripping
+    yasm
+"
+
+PATHS_LIST='
+    bindir
+    datadir
+    incdir
+    libdir
+    mandir
+    prefix
+    shlibdir
+'
+
+CMDLINE_SET="
+    $PATHS_LIST
+    arch
+    as
+    build_suffix
+    cc
+    cpu
+    cross_prefix
+    dep_cc
+    extra_version
+    host_cc
+    host_cflags
+    host_ldflags
+    host_libs
+    host_os
+    ld
+    logfile
+    malloc_prefix
+    nm
+    source_path
+    sysinclude
+    sysroot
+    target_exec
+    target_os
+    target_path
+"
+
+CMDLINE_APPEND="
+    extra_cflags
+"
+
+# code dependency declarations
+
+# architecture extensions
+
+armv5te_deps="arm"
+armv6_deps="arm"
+armv6t2_deps="arm"
+armvfp_deps="arm"
+iwmmxt_deps="arm"
+neon_deps="arm"
+
+mmi_deps="mips"
+
+altivec_deps="ppc"
+ppc4xx_deps="ppc"
+
+vis_deps="sparc"
+
+x86_64_suggest="cmov fast_cmov"
+amd3dnow_deps="mmx"
+amd3dnowext_deps="amd3dnow"
+mmx_deps="x86"
+mmx2_deps="mmx"
+sse_deps="mmx"
+ssse3_deps="sse"
+
+fast_64bit_if_any="alpha ia64 mips64 parisc64 ppc64 sparc64 x86_64"
+fast_clz_if_any="alpha armv5te avr32 mips ppc x86"
+fast_unaligned_if_any="armv6 ppc x86"
+
+need_memalign="altivec neon sse"
+inline_asm_deps="!tms470"
+
+# decoders / encoders / hardware accelerators
+aac_decoder_select="fft mdct aac_parser"
+aac_encoder_select="fft mdct"
+ac3_decoder_select="fft mdct ac3_parser"
+alac_encoder_select="lpc"
+atrac3_decoder_select="fft mdct"
+binkaudio_dct_decoder_select="fft mdct rdft dct"
+binkaudio_rdft_decoder_select="fft mdct rdft"
+cavs_decoder_select="golomb"
+cook_decoder_select="fft mdct"
+cscd_decoder_suggest="zlib"
+dca_decoder_select="fft mdct"
+dnxhd_encoder_select="aandct"
+dxa_decoder_select="zlib"
+eac3_decoder_select="ac3_decoder"
+eamad_decoder_select="aandct"
+eatgq_decoder_select="aandct"
+eatqi_decoder_select="aandct"
+ffv1_decoder_select="golomb"
+flac_decoder_select="golomb"
+flac_encoder_select="golomb lpc"
+flashsv_decoder_select="zlib"
+flashsv_encoder_select="zlib"
+flv_decoder_select="h263_decoder"
+flv_encoder_select="h263_encoder"
+h261_encoder_select="aandct"
+h263_decoder_select="h263_parser"
+h263_encoder_select="aandct"
+h263_vaapi_hwaccel_deps="va_va_h"
+h263_vaapi_hwaccel_select="vaapi h263_decoder"
+h263i_decoder_select="h263_decoder"
+h263p_encoder_select="h263_encoder"
+h264_decoder_select="golomb"
+h264_dxva2_hwaccel_deps="dxva2api_h"
+h264_dxva2_hwaccel_select="dxva2 h264_decoder"
+h264_vaapi_hwaccel_deps="va_va_h"
+h264_vaapi_hwaccel_select="vaapi"
+h264_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+h264_vdpau_decoder_select="vdpau h264_decoder"
+imc_decoder_select="fft mdct"
+jpegls_decoder_select="golomb"
+jpegls_encoder_select="golomb"
+ljpeg_encoder_select="aandct"
+loco_decoder_select="golomb"
+mjpeg_encoder_select="aandct"
+mlp_decoder_select="mlp_parser"
+mpeg1video_encoder_select="aandct"
+mpeg2video_encoder_select="aandct"
+mpeg4_decoder_select="h263_decoder mpeg4video_parser"
+mpeg4_encoder_select="h263_encoder"
+mpeg_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+mpeg_vdpau_decoder_select="vdpau mpegvideo_decoder"
+mpeg1_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+mpeg1_vdpau_decoder_select="vdpau mpeg1video_decoder"
+mpeg2_vaapi_hwaccel_deps="va_va_h"
+mpeg2_vaapi_hwaccel_select="vaapi mpeg2video_decoder"
+mpeg4_vaapi_hwaccel_deps="va_va_h"
+mpeg4_vaapi_hwaccel_select="vaapi mpeg4_decoder"
+mpeg4_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+mpeg4_vdpau_decoder_select="vdpau mpeg4_decoder"
+mpeg_xvmc_decoder_deps="X11_extensions_XvMClib_h"
+mpeg_xvmc_decoder_select="mpegvideo_decoder"
+msmpeg4v1_decoder_select="h263_decoder"
+msmpeg4v1_encoder_select="h263_encoder"
+msmpeg4v2_decoder_select="h263_decoder"
+msmpeg4v2_encoder_select="h263_encoder"
+msmpeg4v3_decoder_select="h263_decoder"
+msmpeg4v3_encoder_select="h263_encoder"
+nellymoser_decoder_select="fft mdct"
+nellymoser_encoder_select="fft mdct"
+png_decoder_select="zlib"
+png_encoder_select="zlib"
+qdm2_decoder_select="fft mdct rdft"
+rv10_decoder_select="h263_decoder"
+rv10_encoder_select="h263_encoder"
+rv20_decoder_select="h263_decoder"
+rv20_encoder_select="h263_encoder"
+rv30_decoder_select="golomb"
+rv40_decoder_select="golomb"
+shorten_decoder_select="golomb"
+sonic_decoder_select="golomb"
+sonic_encoder_select="golomb"
+sonic_ls_encoder_select="golomb"
+svq3_decoder_select="golomb"
+svq3_decoder_suggest="zlib"
+theora_decoder_select="vp3_decoder"
+tiff_decoder_suggest="zlib"
+tiff_encoder_suggest="zlib"
+truehd_decoder_select="mlp_decoder"
+tscc_decoder_select="zlib"
+vc1_decoder_select="h263_decoder"
+vc1_dxva2_hwaccel_deps="dxva2api_h DXVA_PictureParameters_wDecodedPictureIndex"
+vc1_dxva2_hwaccel_select="dxva2 vc1_decoder"
+vc1_vaapi_hwaccel_deps="va_va_h"
+vc1_vaapi_hwaccel_select="vaapi vc1_decoder"
+vc1_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+vc1_vdpau_decoder_select="vdpau vc1_decoder"
+vorbis_decoder_select="fft mdct"
+vorbis_encoder_select="fft mdct"
+vp6a_decoder_select="vp6_decoder"
+vp6f_decoder_select="vp6_decoder"
+wmav1_decoder_select="fft mdct"
+wmav1_encoder_select="fft mdct"
+wmav2_decoder_select="fft mdct"
+wmav2_encoder_select="fft mdct"
+wmv1_decoder_select="h263_decoder"
+wmv1_encoder_select="h263_encoder"
+wmv2_decoder_select="h263_decoder"
+wmv2_encoder_select="h263_encoder"
+wmv3_decoder_select="vc1_decoder"
+wmv3_dxva2_hwaccel_select="vc1_dxva2_hwaccel"
+wmv3_vaapi_hwaccel_select="vc1_vaapi_hwaccel"
+wmv3_vdpau_decoder_select="vc1_vdpau_decoder"
+zlib_decoder_select="zlib"
+zlib_encoder_select="zlib"
+zmbv_decoder_select="zlib"
+zmbv_encoder_select="zlib"
+
+# parsers
+h264_parser_select="golomb"
+
+# bitstream_filters
+aac_adtstoasc_bsf_select="aac_parser"
+
+# external libraries
+libdirac_decoder_deps="libdirac !libschroedinger"
+libdirac_encoder_deps="libdirac"
+libfaac_encoder_deps="libfaac"
+libfaad_decoder_deps="libfaad"
+libfaadbin_decoder_extralibs='$ldl'
+libgsm_decoder_deps="libgsm"
+libgsm_encoder_deps="libgsm"
+libgsm_ms_decoder_deps="libgsm"
+libgsm_ms_encoder_deps="libgsm"
+libmp3lame_encoder_deps="libmp3lame"
+libopencore_amrnb_decoder_deps="libopencore_amrnb"
+libopencore_amrnb_encoder_deps="libopencore_amrnb"
+libopencore_amrwb_decoder_deps="libopencore_amrwb"
+libopenjpeg_decoder_deps="libopenjpeg"
+libschroedinger_decoder_deps="libschroedinger"
+libschroedinger_encoder_deps="libschroedinger"
+libspeex_decoder_deps="libspeex"
+libtheora_encoder_deps="libtheora"
+libvorbis_encoder_deps="libvorbis"
+libx264_encoder_deps="libx264"
+libxvid_encoder_deps="libxvid"
+
+# demuxers / muxers
+ac3_demuxer_deps="ac3_parser"
+asf_stream_muxer_select="asf_muxer"
+avisynth_demuxer_deps="avisynth"
+dirac_demuxer_deps="dirac_parser"
+eac3_demuxer_select="ac3_parser"
+ipod_muxer_select="mov_muxer"
+libnut_demuxer_deps="libnut"
+libnut_muxer_deps="libnut"
+matroska_audio_muxer_select="matroska_muxer"
+matroska_demuxer_suggest="zlib bzlib"
+mov_demuxer_suggest="zlib"
+mp3_demuxer_deps="mpegaudio_parser"
+mp4_muxer_select="mov_muxer"
+mpegtsraw_demuxer_select="mpegts_demuxer"
+mxf_d10_muxer_select="mxf_muxer"
+ogg_demuxer_select="golomb"
+psp_muxer_select="mov_muxer"
+rtsp_demuxer_deps="sdp_demuxer"
+sdp_demuxer_deps="rtp_protocol mpegts_demuxer"
+spdif_muxer_select="aac_parser"
+tg2_muxer_select="mov_muxer"
+tgp_muxer_select="mov_muxer"
+w64_demuxer_deps="wav_demuxer"
+
+# indevs / outdevs
+alsa_indev_deps="alsa_asoundlib_h snd_pcm_htimestamp"
+alsa_indev_extralibs="-lasound"
+alsa_outdev_deps="alsa_asoundlib_h"
+alsa_outdev_extralibs="-lasound"
+audio_beos_indev_deps="audio_beos"
+audio_beos_indev_extralibs="-lmedia -lbe"
+audio_beos_outdev_deps="audio_beos"
+audio_beos_outdev_extralibs="-lmedia -lbe"
+bktr_indev_deps_any="dev_bktr_ioctl_bt848_h machine_ioctl_bt848_h dev_video_bktr_ioctl_bt848_h dev_ic_bt8xx_h"
+dv1394_indev_deps="dv1394 dv_demuxer"
+jack_indev_deps="jack_jack_h"
+jack_indev_extralibs="-ljack"
+libdc1394_indev_deps="libdc1394"
+oss_indev_deps_any="soundcard_h sys_soundcard_h"
+oss_outdev_deps_any="soundcard_h sys_soundcard_h"
+v4l_indev_deps="linux_videodev_h"
+v4l2_indev_deps_any="linux_videodev2_h sys_videoio_h"
+vfwcap_indev_deps="capCreateCaptureWindow"
+vfwcap_indev_extralibs="-lavicap32"
+x11_grab_device_indev_deps="x11grab XShmCreateImage"
+x11_grab_device_indev_extralibs="-lX11 -lXext -lXfixes"
+
+# protocols
+gopher_protocol_deps="network"
+http_protocol_deps="network"
+rtmp_protocol_deps="tcp_protocol"
+rtp_protocol_deps="udp_protocol"
+tcp_protocol_deps="network"
+udp_protocol_deps="network"
+
+# filters
+movie_filter_deps="avfilter_lavf"
+avfilter_lavf_deps="avformat"
+
+# libraries
+avdevice_deps="avcodec avformat"
+avformat_deps="avcodec"
+
+# programs
+ffmpeg_deps="avcodec avformat swscale"
+ffplay_deps="avcodec avformat swscale sdl"
+ffserver_deps="avformat ffm_muxer rtp_protocol rtsp_demuxer"
+ffserver_extralibs='$ldl'
+
+doc_deps="texi2html"
+
+# default parameters
+
+logfile="config.err"
+
+# installation paths
+prefix_default="/usr/local"
+bindir_default='${prefix}/bin'
+datadir_default='${prefix}/share/ffmpeg'
+incdir_default='${prefix}/include'
+libdir_default='${prefix}/lib'
+mandir_default='${prefix}/share/man'
+shlibdir_default="$libdir_default"
+
+# toolchain
+ar="ar"
+cc_default="gcc"
+cc_version=\"unknown\"
+host_cc_default="gcc"
+ln_s="ln -sf"
+nm_default="nm"
+objformat="elf"
+ranlib="ranlib"
+strip="strip"
+yasmexe="yasm"
+
+nm_opts='-g'
+
+# machine
+arch=$(uname -m)
+cpu="generic"
+
+# OS
+target_os=$(tolower $(uname -s))
+host_os=$target_os
+
+# configurable options
+enable avcodec
+enable avdevice
+enable avformat
+enable avutil
+enable asm
+enable debug
+enable doc
+enable fastdiv
+enable ffmpeg
+enable ffplay
+enable ffserver
+enable mpegaudio_hp
+enable network
+enable optimizations
+enable protocols
+enable static
+enable stripping
+enable swscale
+enable swscale_alpha
+
+# build settings
+SHFLAGS='-shared -Wl,-soname,$$(@F)'
+FFSERVERLDFLAGS=-Wl,-E
+LIBPREF="lib"
+LIBSUF=".a"
+FULLNAME='$(NAME)$(BUILDSUF)'
+LIBNAME='$(LIBPREF)$(FULLNAME)$(LIBSUF)'
+SLIBPREF="lib"
+SLIBSUF=".so"
+SLIBNAME='$(SLIBPREF)$(FULLNAME)$(SLIBSUF)'
+SLIBNAME_WITH_VERSION='$(SLIBNAME).$(LIBVERSION)'
+SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'
+LIB_INSTALL_EXTRA_CMD='$(RANLIB) "$(LIBDIR)/$(LIBNAME)"'
+
+CC_O='-o $@'
+
+host_cflags='-D_ISOC99_SOURCE -D_POSIX_C_SOURCE=200112 -O3 -g -Wall'
+host_libs='-lm'
+
+target_path='$(CURDIR)'
+
+# gcc stupidly only outputs the basename of targets with -MM, but we need the
+# full relative path for objects in subdirectories for non-recursive Make.
+DEPEND_CMD='$(DEPCC) $(DEPFLAGS) $< | sed -e "/^\#.*/d" -e "s,^[[:space:]]*$(*F)\\.o,$(@D)/$(*F).o," > $(@:.o=.d)'
+DEPFLAGS='$(CPPFLAGS) $(CFLAGS) -MM'
+
+# find source path
+source_path="$(dirname "$0")"
+enable source_path_used
+if test -f configure; then
+    source_path="$(pwd)"
+    disable source_path_used
+else
+    source_path="$(cd "$source_path"; pwd)"
+    echo "$source_path" | grep -q '[[:blank:]]' &&
+        die "Out of tree builds are impossible with whitespace in source path."
+    test -e "$source_path/config.h" &&
+        die "Out of tree builds are impossible with config.h in source dir."
+fi
+
+for v in "$@"; do
+    r=${v#*=}
+    l=${v%"$r"}
+    r=$(sh_quote "$r")
+    FFMPEG_CONFIGURATION="${FFMPEG_CONFIGURATION# } ${l}${r}"
+done
+
+find_things(){
+    thing=$1
+    pattern=$2
+    file=$source_path/$3
+    sed -n "s/^[^#]*$pattern.*([^,]*, *\([^,]*\)\(,.*\)*).*/\1_$thing/p" "$file"
+}
+
+ENCODER_LIST=$(find_things  encoder  ENC      libavcodec/allcodecs.c)
+DECODER_LIST=$(find_things  decoder  DEC      libavcodec/allcodecs.c)
+HWACCEL_LIST=$(find_things  hwaccel  HWACCEL  libavcodec/allcodecs.c)
+PARSER_LIST=$(find_things   parser   PARSER   libavcodec/allcodecs.c)
+BSF_LIST=$(find_things      bsf      BSF      libavcodec/allcodecs.c)
+MUXER_LIST=$(find_things    muxer    _MUX     libavformat/allformats.c)
+DEMUXER_LIST=$(find_things  demuxer  DEMUX    libavformat/allformats.c)
+OUTDEV_LIST=$(find_things   outdev   OUTDEV   libavdevice/alldevices.c)
+INDEV_LIST=$(find_things    indev    _IN      libavdevice/alldevices.c)
+PROTOCOL_LIST=$(find_things protocol PROTOCOL libavformat/allformats.c)
+FILTER_LIST=$(find_things   filter   FILTER   libavfilter/allfilters.c)
+
+enable $ARCH_EXT_LIST \
+       $DECODER_LIST \
+       $ENCODER_LIST \
+       $HWACCEL_LIST \
+       $PARSER_LIST \
+       $BSF_LIST \
+       $DEMUXER_LIST \
+       $MUXER_LIST \
+       $FILTER_LIST \
+       $PROTOCOL_LIST \
+       $INDEV_LIST \
+       $OUTDEV_LIST \
+
+die_unknown(){
+    echo "Unknown option \"$1\"."
+    echo "See $0 --help for available options."
+    exit 1
+}
+
+show_list() {
+    suffix=_$1
+    shift
+    echo $* | sed s/$suffix//g | tr ' ' '\n' | sort | pr -3 -t
+    exit 0
+}
+
+for opt do
+    optval="${opt#*=}"
+    case "$opt" in
+    --extra-ldflags=*) add_ldflags $optval
+    ;;
+    --extra-libs=*) add_extralibs $optval
+    ;;
+    --disable-devices) disable $INDEV_LIST $OUTDEV_LIST
+    ;;
+    --enable-debug=*) debuglevel="$optval"
+    ;;
+    --enable-*=*|--disable-*=*)
+    eval $(echo "${opt%%=*}" | sed 's/--/action=/;s/-/ thing=/')
+    is_in "${thing}s" $COMPONENT_LIST || die_unknown "$opt"
+    eval list=\$$(toupper $thing)_LIST
+    name=$(echo "${optval}" | sed "s/,/_${thing}|/g")_${thing}
+    $action $(filter "$name" $list)
+    ;;
+    --enable-?*|--disable-?*)
+    eval $(echo "$opt" | sed 's/--/action=/;s/-/ option=/;s/-/_/g')
+    if is_in $option $COMPONENT_LIST; then
+        test $action = disable && action=unset
+        eval $action \$$(toupper ${option%s})_LIST
+    elif is_in $option $CMDLINE_SELECT; then
+        $action $option
+    else
+        die_unknown $opt
+    fi
+    ;;
+    --list-*)
+        NAME="${opt#--list-}"
+        is_in $NAME $COMPONENT_LIST || die_unknown $opt
+        NAME=${NAME%s}
+        eval show_list $NAME \$$(toupper $NAME)_LIST
+    ;;
+    --help|-h) show_help
+    ;;
+    *)
+    optname="${opt%%=*}"
+    optname="${optname#--}"
+    optname=$(echo "$optname" | sed 's/-/_/g')
+    if is_in $optname $CMDLINE_SET; then
+        eval $optname='$optval'
+    elif is_in $optname $CMDLINE_APPEND; then
+        append $optname "$optval"
+    else
+         die_unknown $opt
+    fi
+    ;;
+    esac
+done
+
+disabled logging && logfile=/dev/null
+
+echo "# $0 $FFMPEG_CONFIGURATION" > $logfile
+set >> $logfile
+
+test -n "$cross_prefix" && enable cross_compile
+
+ar="${cross_prefix}${ar}"
+cc_default="${cross_prefix}${cc_default}"
+nm_default="${cross_prefix}${nm_default}"
+ranlib="${cross_prefix}${ranlib}"
+strip="${cross_prefix}${strip}"
+
+sysinclude_default="${sysroot}/usr/include"
+
+set_default cc nm sysinclude
+enabled cross_compile || host_cc_default=$cc
+set_default host_cc
+
+exesuf() {
+    case $1 in
+        mingw32*|cygwin*|*-dos|freedos|opendos|os/2*) echo .exe ;;
+    esac
+}
+
+EXESUF=$(exesuf $target_os)
+HOSTEXESUF=$(exesuf $host_os)
+
+# set temporary file name
+: ${TMPDIR:=$TEMPDIR}
+: ${TMPDIR:=$TMP}
+: ${TMPDIR:=/tmp}
+
+if ! check_cmd type mktemp; then
+    # simple replacement for missing mktemp
+    # NOT SAFE FOR GENERAL USE
+    mktemp(){
+        echo "${2%XXX*}.${HOSTNAME}.${UID}.$$"
+    }
+fi
+
+tmpfile(){
+    tmp=$(mktemp -u "${TMPDIR}/ffconf.XXXXXXXX")$2 &&
+        (set -C; exec > $tmp) 2>/dev/null ||
+        die "Unable to create temporary file in $TMPDIR."
+    append TMPFILES $tmp
+    eval $1=$tmp
+}
+
+trap 'rm -f -- $TMPFILES' EXIT
+trap exit HUP INT TERM
+
+tmpfile TMPC  .c
+tmpfile TMPE  $EXESUF
+tmpfile TMPH  .h
+tmpfile TMPO  .o
+tmpfile TMPS  .S
+tmpfile TMPV  .ver
+tmpfile TMPSH .sh
+
+unset -f mktemp
+
+# make sure we can execute files in $TMPDIR
+cat > $TMPSH 2>> $logfile <<EOF
+#! /bin/sh
+EOF
+chmod +x $TMPSH >> $logfile 2>&1
+if ! $TMPSH >> $logfile 2>&1; then
+    cat <<EOF
+Unable to create and execute files in $TMPDIR.  Set the TMPDIR environment
+variable to another directory and make sure that it is not mounted noexec.
+EOF
+    die "Sanity test failed."
+fi
+
+filter_cflags=echo
+filter_cppflags=echo
+filter_asflags=echo
+
+if   $cc -v 2>&1 | grep -qi ^gcc; then
+    cc_type=gcc
+    cc_version=__VERSION__
+    if ! $cc -dumpversion | grep -q '^2\.'; then
+        CC_DEPFLAGS='-MMD -MF $(@:.o=.d) -MT $@'
+        AS_DEPFLAGS='-MMD -MF $(@:.o=.d) -MT $@'
+    fi
+    speed_cflags='-O3'
+    size_cflags='-Os'
+elif $cc --version 2>/dev/null | grep -q Intel; then
+    cc_type=icc
+    cc_version="AV_STRINGIFY(__INTEL_COMPILER)"
+    CC_DEPFLAGS='-MMD'
+    AS_DEPFLAGS='-MMD'
+    speed_cflags='-O3'
+    size_cflags='-Os'
+elif $cc -v 2>&1 | grep -q xlc; then
+    cc_type=xlc
+    cc_version="AV_STRINGIFY(__IBMC__)"
+    speed_cflags='-O5'
+    size_cflags='-O5 -qcompact'
+elif $cc -V 2>/dev/null | grep -q Compaq; then
+    cc_type=ccc
+    cc_version="AV_STRINGIFY(__DECC_VER)"
+    DEPFLAGS='$(CPPFLAGS) $(CFLAGS) -M'
+    debuglevel=3
+    add_ldflags -Wl,-z,now # calls to libots crash without this
+    speed_cflags='-fast'
+    size_cflags='-O1'
+elif $cc --vsn 2>/dev/null | grep -q "ARM C/C++ Compiler"; then
+    test -d "$sysroot" || die "No valid sysroot specified."
+    cc_type=armcc
+    cc_version="AV_STRINGIFY(__ARMCC_VERSION)"
+    armcc_conf="$PWD/armcc.conf"
+    $cc --arm_linux_configure                 \
+        --arm_linux_config_file="$armcc_conf" \
+        --configure_sysroot="$sysroot"        \
+        --configure_cpp_headers="$sysinclude" >>$logfile 2>&1 ||
+        die "Error creating armcc configuration file."
+    cc="$cc --arm_linux_config_file=$armcc_conf --translate_gcc"
+    as_default="${cross_prefix}gcc"
+    CC_DEPFLAGS='-MMD'
+    AS_DEPFLAGS='-MMD'
+    speed_cflags='-O3'
+    size_cflags='-Os'
+elif $cc -version 2>/dev/null | grep -q TMS470; then
+    cc_type=tms470
+    cc_version="AV_STRINGIFY(__TI_COMPILER_VERSION__)"
+    cc="$cc --gcc --abi=eabi -eo=.o -mc -me"
+    CC_O='-fr=$(@D)'
+    as_default="${cross_prefix}gcc"
+    ld_default="${cross_prefix}gcc"
+    TMPO=$(basename $TMPC .c).o
+    append TMPFILES $TMPO
+    add_cflags -D__gnuc_va_list=va_list -D__USER_LABEL_PREFIX__=
+    CC_DEPFLAGS='-ppa -ppd=$(@:.o=.d)'
+    AS_DEPFLAGS='-MMD'
+    speed_cflags='-O3 -mf=5'
+    size_cflags='-O3 -mf=2'
+    filter_cflags=tms470_flags
+    tms470_flags(){
+        for flag; do
+            case $flag in
+                -march=*|-mcpu=*)
+                    case "${flag#*=}" in
+                        armv7-a|cortex-a*)      echo -mv=7a8 ;;
+                        armv7-r|cortex-r*)      echo -mv=7r4 ;;
+                        armv7-m|cortex-m*)      echo -mv=7m3 ;;
+                        armv6*|arm11*)          echo -mv=6   ;;
+                        armv5*e|arm[79]*e*|arm9[24]6*|arm96*|arm102[26])
+                                                echo -mv=5e  ;;
+                        armv4*|arm7*|arm9[24]*) echo -mv=4   ;;
+                    esac
+                    ;;
+                -mfpu=neon)     echo --float_support=vfpv3 --neon ;;
+                -mfpu=vfp)      echo --float_support=vfpv2        ;;
+                -mfpu=vfpv3)    echo --float_support=vfpv3        ;;
+                -msoft-float)   echo --float_support=vfplib       ;;
+                -O[0-3]|-mf=*)  echo $flag                        ;;
+                -g)             echo -g -mn                       ;;
+                -pds=*)         echo $flag                        ;;
+            esac
+        done
+    }
+elif $cc -v 2>&1 | grep -q clang; then
+    cc_type=clang
+    cc_version=__VERSION__
+    CC_DEPFLAGS='-MMD'
+    AS_DEPFLAGS='-MMD'
+    speed_cflags='-O3'
+    size_cflags='-Os'
+elif $cc -V 2>&1 | grep -q Sun; then
+    cc_type=suncc
+    cc_version="AV_STRINGIFY(__SUNPRO_C)"
+    DEPEND_CMD='$(DEPCC) $(DEPFLAGS) $< | sed -e "1s,^.*: ,$@: ," -e "\$$!s,\$$, \\\," -e "1!s,^.*: , ," > $(@:.o=.d)'
+    DEPFLAGS='$(CPPFLAGS) $(CFLAGS) -xM1'
+    speed_cflags='-O5'
+    size_cflags='-O5 -xspace'
+    filter_cflags=suncc_flags
+    suncc_flags(){
+        for flag; do
+            case $flag in
+                -march=*|-mcpu=*)
+                    case "${flag#*=}" in
+                        native)                   echo -xtarget=native       ;;
+                        v9)                       echo -xarch=sparc          ;;
+                        ultrasparc)               echo -xarch=sparcvis       ;;
+                        ultrasparc3|niagara*)     echo -xarch=sparcvis2      ;;
+                        i586|pentium)             echo -xchip=pentium        ;;
+                        i686|pentiumpro|pentium2) echo -xtarget=pentium_pro  ;;
+                        pentium3*|c3-2)           echo -xtarget=pentium3     ;;
+                        pentium-m)          echo -xarch=sse2 -xchip=pentium3 ;;
+                        pentium4*)          echo -xtarget=pentium4           ;;
+                        prescott|nocona)    echo -xarch=sse3 -xchip=pentium4 ;;
+                        *-sse3)             echo -xarch=sse3                 ;;
+                        core2)              echo -xarch=ssse3 -xchip=core2   ;;
+                        amdfam10|barcelona)       echo -xarch=sse4_1         ;;
+                        athlon-4|athlon-[mx]p)    echo -xarch=ssea           ;;
+                        k8|opteron|athlon64|athlon-fx)
+                                                  echo -xarch=sse2a          ;;
+                        athlon*)                  echo -xarch=pentium_proa   ;;
+                    esac
+                    ;;
+                -std=c99)             echo -xc99              ;;
+                -fomit-frame-pointer) echo -xregs=frameptr    ;;
+                -fPIC)                echo -KPIC -xcode=pic32 ;;
+                -W*,*)                echo $flag              ;;
+                -f*-*|-W*)                                    ;;
+                *)                    echo $flag              ;;
+            esac
+        done
+    }
+fi
+
+test -n "$cc_type" && enable $cc_type || echolog "Unknown C compiler $cc"
+
+: ${as_default:=$cc}
+: ${dep_cc_default:=$cc}
+: ${ld_default:=$cc}
+set_default as dep_cc ld
+
+test -n "$CC_DEPFLAGS" || CCDEP=$DEPEND_CMD
+test -n "$AS_DEPFLAGS" || ASDEP=$DEPEND_CMD
+
+add_cflags $extra_cflags
+add_asflags $extra_cflags
+
+if test -n "$sysroot"; then
+    case "$cc_type" in
+        gcc)
+            add_cppflags --sysroot="$sysroot"
+            add_ldflags --sysroot="$sysroot"
+        ;;
+        tms470)
+            add_cppflags -I"$sysinclude"
+            add_ldflags  --sysroot="$sysroot"
+        ;;
+        clang)
+            add_cppflags -isysroot="$sysroot"
+            add_ldflags -isysroot="$sysroot"
+        ;;
+    esac
+fi
+
+if test "$cpu" = host; then
+    enabled cross_compile && die "--cpu=host makes no sense when cross-compiling."
+
+    case "$cc_type" in
+        gcc)
+            check_native(){
+                $cc $1=native -v -c -o $TMPO $TMPC >$TMPE 2>&1 || return
+                sed -n "/$1=/{
+                            s/.*$1=\\([^ ]*\\).*/\\1/
+                            p
+                            q
+                        }" $TMPE
+            }
+            cpu=$(check_native -march || check_native -mcpu)
+        ;;
+    esac
+
+    test "${cpu:-host}" = host && die "--cpu=host not supported with compiler $cc"
+fi
+
+# Deal with common $arch aliases
+case "$arch" in
+    arm*)
+        arch="arm"
+    ;;
+    mips|mipsel|IP*)
+        arch="mips"
+    ;;
+    mips64)
+        arch="mips"
+        subarch="mips64"
+    ;;
+    parisc|hppa)
+        arch="parisc"
+    ;;
+    parisc64|hppa64)
+        arch="parisc"
+        subarch="parisc64"
+    ;;
+    "Power Macintosh"|ppc|powerpc)
+        arch="ppc"
+    ;;
+    ppc64)
+        arch="ppc"
+        subarch="ppc64"
+    ;;
+    s390|s390x)
+        arch="s390"
+    ;;
+    sh4|sh)
+        arch="sh4"
+    ;;
+    sun4u|sparc64)
+        arch="sparc"
+        subarch="sparc64"
+    ;;
+    i[3-6]86|i86pc|BePC|x86_64|amd64)
+        arch="x86"
+    ;;
+esac
+
+is_in $arch $ARCH_LIST || echo "WARNING: unknown arch $arch"
+enable $arch
+
+# Add processor-specific flags
+if test "$cpu" = generic; then
+    : do nothing
+elif enabled ppc; then
+
+    case $(tolower $cpu) in
+        601|ppc601|powerpc601)
+            cpuflags="-mcpu=601"
+            disable altivec
+        ;;
+        603*|ppc603*|powerpc603*)
+            cpuflags="-mcpu=603"
+            disable altivec
+        ;;
+        604*|ppc604*|powerpc604*)
+            cpuflags="-mcpu=604"
+            disable altivec
+        ;;
+        g3|75*|ppc75*|powerpc75*)
+            cpuflags="-mcpu=750 -mpowerpc-gfxopt"
+            disable altivec
+        ;;
+        g4|745*|ppc745*|powerpc745*)
+            cpuflags="-mcpu=7450 -mpowerpc-gfxopt"
+        ;;
+        74*|ppc74*|powerpc74*)
+            cpuflags="-mcpu=7400 -mpowerpc-gfxopt"
+        ;;
+        g5|970|ppc970|powerpc970|power4*)
+            cpuflags="-mcpu=970 -mpowerpc-gfxopt -mpowerpc64"
+        ;;
+        cell)
+            cpuflags="-mcpu=cell"
+            enable ldbrx
+        ;;
+        e500v2)
+            cpuflags="-mcpu=8548 -mhard-float -mfloat-gprs=double"
+            disable altivec
+        ;;
+        e500)
+            cpuflags="-mcpu=8540 -mhard-float"
+            disable altivec
+        ;;
+    esac
+
+elif enabled x86; then
+
+    case $cpu in
+        i[345]86|pentium)
+            cpuflags="-march=$cpu"
+            disable mmx
+        ;;
+        # targets that do NOT support conditional mov (cmov)
+        pentium-mmx|k6|k6-[23]|winchip-c6|winchip2|c3)
+            cpuflags="-march=$cpu"
+            disable cmov
+        ;;
+        # targets that do support conditional mov (cmov)
+        i686|pentiumpro|pentium[23]|pentium-m|athlon|athlon-tbird|athlon-4|athlon-[mx]p|athlon64|k8|opteron|athlon-fx|core2|amdfam10)
+            cpuflags="-march=$cpu"
+            enable cmov
+            enable fast_cmov
+        ;;
+        # targets that do support conditional mov but on which it's slow
+        pentium4|pentium4m|prescott|nocona)
+            cpuflags="-march=$cpu"
+            enable cmov
+            disable fast_cmov
+        ;;
+    esac
+
+elif enabled sparc; then
+
+    case $cpu in
+        sparc64)
+            cpuflags="-mcpu=v9"
+        ;;
+    esac
+
+elif enabled arm; then
+
+    case $cpu in
+        armv*)
+            cpuflags="-march=$cpu"
+        ;;
+        *)
+            cpuflags="-mcpu=$cpu"
+        ;;
+    esac
+
+elif enabled alpha; then
+
+    enabled ccc && cpuflags="-arch $cpu" || cpuflags="-mcpu=$cpu"
+
+elif enabled bfin; then
+
+    cpuflags="-mcpu=$cpu"
+
+elif enabled mips; then
+
+    cpuflags="-march=$cpu"
+
+elif enabled avr32; then
+
+    case $cpu in
+        ap7[02]0[0-2])
+            subarch="avr32_ap"
+            cpuflags="-mpart=$cpu"
+        ;;
+        ap)
+            subarch="avr32_ap"
+            cpuflags="-march=$cpu"
+        ;;
+        uc3[ab]*)
+            subarch="avr32_uc"
+            cpuflags="-mcpu=$cpu"
+        ;;
+        uc)
+            subarch="avr32_uc"
+            cpuflags="-march=$cpu"
+        ;;
+    esac
+
+fi
+
+add_cflags $cpuflags
+add_asflags $cpuflags
+
+# compiler sanity check
+check_exec <<EOF
+int main(void){ return 0; }
+EOF
+if test "$?" != 0; then
+    echo "$cc is unable to create an executable file."
+    if test -z "$cross_prefix" && ! enabled cross_compile ; then
+        echo "If $cc is a cross-compiler, use the --enable-cross-compile option."
+        echo "Only do this if you know what cross compiling means."
+    fi
+    die "C compiler test failed."
+fi
+
+add_cppflags -D_ISOC99_SOURCE -D_POSIX_C_SOURCE=200112
+check_cflags -std=c99
+check_cc -D_FILE_OFFSET_BITS=64 <<EOF && add_cppflags -D_FILE_OFFSET_BITS=64
+#include <stdlib.h>
+EOF
+check_cc -D_LARGEFILE_SOURCE <<EOF && add_cppflags -D_LARGEFILE_SOURCE
+#include <stdlib.h>
+EOF
+
+check_host_cflags -std=c99
+
+case "$arch" in
+    alpha|ia64|mips|parisc|sparc)
+        spic=$shared
+    ;;
+    x86)
+        subarch="x86_32"
+        check_cc <<EOF && subarch="x86_64"
+        int test[(int)sizeof(char*) - 7];
+EOF
+        if test "$subarch" = "x86_64"; then
+            spic=$shared
+        fi
+    ;;
+esac
+
+enable $subarch
+enabled spic && enable pic
+check_cpp_condition stdlib.h "defined(__PIC__) || defined(__pic__) || defined(PIC)" && enable pic
+
+# OS specific
+case $target_os in
+    beos|haiku|zeta)
+        prefix_default="$HOME/config"
+        # 3 gcc releases known for BeOS, each with ugly bugs
+        gcc_version="$($cc -v 2>&1 | grep version | cut -d ' ' -f3-)"
+        case "$gcc_version" in
+          2.9-beos-991026*|2.9-beos-000224*) echo "R5/GG gcc"
+            disable mmx
+            ;;
+          *20010315*) echo "BeBits gcc"
+            add_cflags -fno-expensive-optimizations
+            ;;
+        esac
+        SHFLAGS=-nostart
+        # enable BeOS things
+        enable audio_beos
+        # no need for libm, but the inet stuff
+        # Check for BONE
+        # XXX: actually should check for NOT net_server
+        if echo $BEINCLUDES | grep -q 'headers/be/bone'; then
+            network_extralibs="-lbind -lsocket"
+        else
+            enable beos_netserver
+            network_extralibs="-lnet"
+        fi ;;
+    sunos)
+        FFSERVERLDFLAGS=""
+        SHFLAGS='-shared -Wl,-h,$$(@F)'
+        enabled x86 && SHFLAGS="-mimpure-text $SHFLAGS"
+        network_extralibs="-lsocket -lnsl"
+        add_cppflags -D__EXTENSIONS__
+        nm_opts='-P -g'
+        ;;
+    netbsd)
+        oss_indev_extralibs="-lossaudio"
+        oss_outdev_extralibs="-lossaudio"
+        ;;
+    openbsd)
+        enable malloc_aligned
+        # On OpenBSD 4.5. the compiler does not use PIC unless
+        # explicitly using -fPIC. FFmpeg builds fine without PIC,
+        # however the generated executable will not do anything
+        # (simply quits with exit-code 1, no crash, no output).
+        # Thus explicitly enable PIC here.
+        enable pic
+        SHFLAGS='-shared'
+        oss_indev_extralibs="-lossaudio"
+        oss_outdev_extralibs="-lossaudio"
+        ;;
+    freebsd|dragonfly)
+        enable malloc_aligned
+        ;;
+    bsd/os)
+        osextralibs="-lpoll -lgnugetopt"
+        strip="strip -d"
+        ;;
+    darwin)
+        enable malloc_aligned
+        SHFLAGS='-dynamiclib -Wl,-single_module -Wl,-install_name,$(SHLIBDIR)/$(SLIBNAME),-current_version,$(LIBVERSION),-compatibility_version,$(LIBMAJOR) -Wl,-read_only_relocs,suppress'
+        strip="strip -x"
+        FFLDFLAGS="-Wl,-dynamic,-search_paths_first"
+        SLIBSUF=".dylib"
+        SLIBNAME_WITH_VERSION='$(SLIBPREF)$(FULLNAME).$(LIBVERSION)$(SLIBSUF)'
+        SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME).$(LIBMAJOR)$(SLIBSUF)'
+        FFSERVERLDFLAGS=-Wl,-bind_at_load
+        objformat="macho"
+        enabled x86_64 && objformat="macho64"
+        enabled_any pic shared ||
+            { check_cflags -mdynamic-no-pic && add_asflags -mdynamic-no-pic; }
+        ;;
+    mingw32*)
+        if test $target_os = "mingw32ce"; then
+            disable network
+        else
+            target_os=mingw32
+        fi
+        LIBTARGET=i386
+        if enabled x86_64; then
+            enable malloc_aligned
+            LIBTARGET=x64
+        elif enabled arm; then
+            LIBTARGET=arm
+        fi
+        shlibdir_default="$bindir_default"
+        disable ffserver
+        SLIBPREF=""
+        SLIBSUF=".dll"
+        SLIBNAME_WITH_VERSION='$(SLIBPREF)$(FULLNAME)-$(LIBVERSION)$(SLIBSUF)'
+        SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'
+        SLIB_EXTRA_CMD='-lib.exe /machine:$(LIBTARGET) /def:$$(@:$(SLIBSUF)=.def) /out:$(SUBDIR)$(SLIBNAME_WITH_MAJOR:$(SLIBSUF)=.lib)'
+        SLIB_INSTALL_EXTRA_CMD='-install -m 644 $(SUBDIR)$(SLIBNAME_WITH_MAJOR:$(SLIBSUF)=.lib) "$(SHLIBDIR)/$(SLIBNAME:$(SLIBSUF)=.lib)"; \
+            install -m 644 $(SUBDIR)$(SLIBNAME_WITH_MAJOR:$(SLIBSUF)=.lib) "$(SHLIBDIR)/$(SLIBNAME_WITH_MAJOR:$(SLIBSUF)=.lib)"; \
+            install -d "$(LIBDIR)"; \
+            install -m 644 $(SUBDIR)lib$(SLIBNAME:$(SLIBSUF)=.dll.a) "$(LIBDIR)/lib$(SLIBNAME:$(SLIBSUF)=.dll.a)"'
+        SLIB_UNINSTALL_EXTRA_CMD='rm -f "$(SHLIBDIR)/$(SLIBNAME:$(SLIBSUF)=.lib)"'
+        SHFLAGS='-shared -Wl,--output-def,$$(@:$(SLIBSUF)=.def) -Wl,--out-implib,$(SUBDIR)lib$(SLIBNAME:$(SLIBSUF)=.dll.a) -Wl,--enable-runtime-pseudo-reloc -Wl,--enable-auto-image-base'
+        objformat="win32"
+        enable dos_paths
+        check_cflags -fno-common
+        if ! enabled x86_64; then
+            check_cpp_condition _mingw.h "(__MINGW32_MAJOR_VERSION > 3) || (__MINGW32_MAJOR_VERSION == 3 && __MINGW32_MINOR_VERSION >= 15)" ||
+                die "ERROR: MinGW runtime version must be >= 3.15."
+            enabled_any avisynth vfwcap_indev &&
+                { check_cpp_condition w32api.h "(__W32API_MAJOR_VERSION > 3) || (__W32API_MAJOR_VERSION == 3 && __W32API_MINOR_VERSION >= 13)" ||
+                  die "ERROR: avisynth and vfwcap_indev require w32api version 3.13 or later."; }
+        fi
+        ;;
+    cygwin*)
+        target_os=cygwin
+        shlibdir_default="$bindir_default"
+        SLIBPREF="cyg"
+        SLIBSUF=".dll"
+        SLIBNAME_WITH_VERSION='$(SLIBPREF)$(FULLNAME)-$(LIBVERSION)$(SLIBSUF)'
+        SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'
+        SHFLAGS='-shared -Wl,--enable-auto-image-base'
+        objformat="win32"
+        enable dos_paths
+        check_cflags -fno-common
+        ;;
+    *-dos|freedos|opendos)
+        disable ffplay ffserver
+        disable $INDEV_LIST $OUTDEV_LIST
+        network_extralibs="-lsocket"
+        objformat="coff"
+        enable dos_paths
+        ;;
+    linux)
+        enable dv1394
+        ;;
+    irix*)
+        target_os=irix
+        ranlib="echo ignoring ranlib"
+        ;;
+    os/2*)
+        strip="lxlite"
+        ln_s="cp -f"
+        FFLDFLAGS="-Zomf -Zbin-files -Zargs-wild -Zmap"
+        SHFLAGS='$(SUBDIR)$(NAME).def -Zdll -Zomf'
+        FFSERVERLDFLAGS=""
+        LIBSUF="_s.a"
+        SLIBPREF=""
+        SLIBSUF=".dll"
+        SLIBNAME_WITH_VERSION='$(SLIBPREF)$(NAME)-$(LIBVERSION)$(SLIBSUF)'
+        SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(shell echo $(NAME) | cut -c1-6)$(LIBMAJOR)$(SLIBSUF)'
+        SLIB_CREATE_DEF_CMD='echo LIBRARY $(SLIBNAME_WITH_MAJOR) INITINSTANCE TERMINSTANCE > $(SUBDIR)$(NAME).def; \
+          echo PROTMODE >> $(SUBDIR)$(NAME).def; \
+          echo CODE PRELOAD MOVEABLE DISCARDABLE >> $(SUBDIR)$(NAME).def; \
+          echo DATA PRELOAD MOVEABLE MULTIPLE NONSHARED >> $(SUBDIR)$(NAME).def; \
+          echo EXPORTS >> $(SUBDIR)$(NAME).def; \
+          emxexp -o $(OBJS) >> $(SUBDIR)$(NAME).def'
+        SLIB_EXTRA_CMD='emximp -o $(SUBDIR)$(LIBPREF)$(NAME)_dll.a $(SUBDIR)$(NAME).def; \
+          emximp -o $(SUBDIR)$(LIBPREF)$(NAME)_dll.lib $(SUBDIR)$(NAME).def;'
+        SLIB_INSTALL_EXTRA_CMD='install -m 644 $(SUBDIR)$(LIBPREF)$(NAME)_dll.a $(SUBDIR)$(LIBPREF)$(NAME)_dll.lib "$(LIBDIR)"'
+        SLIB_UNINSTALL_EXTRA_CMD='rm -f "$(LIBDIR)"/$(LIBPREF)$(NAME)_dll.a "$(LIBDIR)"/$(LIBPREF)$(NAME)_dll.lib'
+        enable dos_paths
+        ;;
+    gnu/kfreebsd)
+        ;;
+    gnu)
+        ;;
+
+    *)
+        die "Unknown OS '$target_os'."
+        ;;
+esac
+
+set_default $PATHS_LIST
+
+add_extralibs $osextralibs
+
+# Combine FFLDFLAGS and the LDFLAGS environment variable.
+LDFLAGS="$FFLDFLAGS $LDFLAGS"
+
+# we need to build at least one lib type
+if ! enabled_any static shared; then
+    cat <<EOF
+At least one library type must be built.
+Specify --enable-static to build the static libraries or --enable-shared to
+build the shared libraries as well. To only build the shared libraries specify
+--disable-static in addition to --enable-shared.
+EOF
+    exit 1;
+fi
+
+disabled static && LIBNAME=""
+
+if enabled_any libfaad libfaadbin ; then
+    if check_header faad.h; then
+        check_cc <<EOF
+#include <faad.h>
+#ifndef FAAD2_VERSION
+ok faad1
+#endif
+int main(void) { return 0; }
+EOF
+        test $? = 0 && enable libfaad2
+    else
+        die "FAAD test failed."
+    fi
+fi
+
+
+die_license_disabled() {
+    enabled $1 || { enabled $2 && die "$2 is $1 and --enable-$1 is not specified."; }
+}
+
+die_license_disabled gpl libfaad2
+die_license_disabled gpl libx264
+die_license_disabled gpl libxvid
+die_license_disabled gpl postproc
+die_license_disabled gpl x11grab
+
+die_license_disabled nonfree libfaac
+
+die_license_disabled version3 libopencore_amrnb
+die_license_disabled version3 libopencore_amrwb
+
+enabled version3 && { enabled gpl && enable gplv3 || enable lgplv3; }
+
+check_deps $ARCH_EXT_LIST
+
+disabled optimizations || check_cflags -fomit-frame-pointer
+
+enable_pic() {
+    enable pic
+    add_cppflags -DPIC
+    add_cflags   -fPIC
+    add_asflags  -fPIC
+}
+
+enabled pic && enable_pic
+
+check_cc <<EOF || die "Symbol mangling check failed."
+int ff_extern;
+EOF
+sym=$($nm $nm_opts $TMPO | awk '/ff_extern/{ print substr($0, match($0, /[^ \t]*ff_extern/)) }')
+extern_prefix=${sym%%ff_extern*}
+
+check_cc <<EOF && enable inline_asm
+void foo(void) { __asm__ volatile ("" ::); }
+EOF
+
+_restrict=
+for restrict_keyword in restrict __restrict__ __restrict; do
+    check_cc <<EOF && _restrict=$restrict_keyword && break
+void foo(char * $restrict_keyword p);
+EOF
+done
+
+check_cc <<EOF && enable attribute_packed
+struct { int x; } __attribute__((packed)) x;
+EOF
+
+check_cc <<EOF && enable attribute_may_alias
+union { int x; } __attribute__((may_alias)) x;
+EOF
+
+check_cc <<EOF || die "endian test failed"
+unsigned int endian = 'B' << 24 | 'I' << 16 | 'G' << 8 | 'E';
+EOF
+od -t x1 $TMPO | grep -q '42 *49 *47 *45' && enable bigendian
+
+if enabled alpha; then
+
+    check_cflags -mieee
+
+elif enabled arm; then
+
+    check_cflags -marm
+
+    check_ld <<EOF && enable vfp_args
+__asm__ (".eabi_attribute 28, 1");
+int main(void) { return 0; }
+EOF
+
+    # We have to check if pld is a nop and disable it.
+    check_asm pld '"pld [r0]"'
+
+    enabled armv5te && check_asm armv5te '"qadd r0, r0, r0"'
+    enabled armv6   && check_asm armv6   '"sadd16 r0, r0, r0"'
+    enabled armv6t2 && check_asm armv6t2 '"movt r0, #0"'
+    enabled armvfp  && check_asm armvfp  '"fadds s0, s0, s0"'
+    enabled iwmmxt  && check_asm iwmmxt  '"wunpckelub wr6, wr4"'
+    enabled neon    && check_asm neon    '"vadd.i16 q0, q0, q0"'
+
+    enabled_all armv6t2 shared !pic && enable_pic
+
+elif enabled ia64; then
+
+    # HACK: currently fails to build if .bss is > 4MB and shared libs are built
+    enabled shared && enable_weak hardcoded_tables
+
+elif enabled mips; then
+
+    check_asm loongson '"dmult.g $1, $2, $3"'
+    enabled mmi     && check_asm mmi     '"lq $2, 0($2)"'
+
+elif enabled ppc; then
+
+    check_asm dcbzl     '"dcbzl 0, 1"'
+    check_asm ppc4xx    '"maclhw r10, r11, r12"'
+    check_asm xform_asm '"lwzx %1, %y0" :: "Z"(*(int*)0), "r"(0)'
+
+    # AltiVec flags: The FSF version of GCC differs from the Apple version
+    if enabled altivec; then
+        check_cflags -maltivec -mabi=altivec &&
+        { check_header altivec.h && inc_altivec_h="#include <altivec.h>" ; } ||
+        check_cflags -faltivec
+
+        # check if our compiler supports Motorola AltiVec C API
+        check_cc <<EOF || disable altivec
+$inc_altivec_h
+int main(void) {
+    vector signed int v1, v2, v3;
+    v1 = vec_add(v2,v3);
+    return 0;
+}
+EOF
+
+        # check if our compiler supports braces for vector declarations
+        check_cc <<EOF || die "You need a compiler that supports {} in AltiVec vector declarations."
+$inc_altivec_h
+int main (void) { (vector int) {1}; return 0; }
+EOF
+    fi
+
+elif enabled sparc; then
+
+    enabled vis && check_asm vis '"pdist %f0, %f0, %f0"' -mcpu=ultrasparc &&
+        add_cflags -mcpu=ultrasparc -mtune=ultrasparc
+
+elif enabled x86; then
+
+    # check whether EBP is available on x86
+    # As 'i' is stored on the stack, this program will crash
+    # if the base pointer is used to access it because the
+    # base pointer is cleared in the inline assembly code.
+    check_exec_crash <<EOF && enable ebp_available
+    volatile int i=0;
+    __asm__ volatile (
+        "xorl %%ebp, %%ebp"
+    ::: "%ebp");
+    return i;
+EOF
+
+    # check whether EBX is available on x86
+    check_asm ebx_available '""::"b"(0)' &&
+        check_asm ebx_available '"":::"%ebx"'
+
+    # check whether more than 10 operands are supported
+    check_cc <<EOF && enable ten_operands
+int main(void) {
+    int x=0;
+    __asm__ volatile(
+        ""
+        :"+&rm"(x), "+&rm"(x), "+&rm"(x), "+&rm"(x), "+&rm"(x), "+&rm"(x)
+    );
+    return 0;
+}
+EOF
+
+    # check whether binutils is new enough to compile SSSE3/MMX2
+    enabled ssse3 && check_asm ssse3 '"pabsw %xmm0, %xmm0"'
+    enabled mmx2  && check_asm mmx2  '"pmaxub %mm0, %mm1"'
+
+    check_asm bswap '"bswap %%eax" ::: "%eax"'
+
+    YASMFLAGS="-f $objformat -DARCH_$(toupper $subarch)"
+    enabled     x86_64        && append YASMFLAGS "-m amd64"
+    enabled     pic           && append YASMFLAGS "-DPIC"
+    test -n "$extern_prefix"  && append YASMFLAGS "-DPREFIX"
+    case "$objformat" in
+        elf) enabled debug && append YASMFLAGS "-g dwarf2" ;;
+    esac
+    disabled yasm || { check_yasm "pabsw xmm0, xmm0" && enable yasm; }
+
+    case "$cpu" in
+        athlon*|opteron*|k8*|pentium|pentium-mmx|prescott|nocona|atom|geode)
+            disable fast_clz
+        ;;
+    esac
+
+fi
+
+if check_func dlopen; then
+    ldl=
+elif check_func dlopen -ldl; then
+    ldl=-ldl
+fi
+
+# Solaris has nanosleep in -lrt, OpenSolaris no longer needs that
+check_func nanosleep || { check_func nanosleep -lrt && add_extralibs -lrt; }
+
+check_func  fork
+check_func  getaddrinfo $network_extralibs
+check_func  gethrtime
+check_func  getrusage
+check_func  inet_aton $network_extralibs
+check_func  isatty
+check_func  ${malloc_prefix}memalign            && enable memalign
+check_func  mkstemp
+check_func  ${malloc_prefix}posix_memalign      && enable posix_memalign
+check_func_headers io.h setmode
+check_func_headers lzo/lzo1x.h lzo1x_999_compress
+check_func_headers windows.h GetProcessTimes
+check_func_headers windows.h VirtualAlloc
+
+check_header conio.h
+check_header dlfcn.h
+check_header dxva2api.h
+check_header malloc.h
+check_header poll.h
+check_header sys/mman.h
+check_header sys/resource.h
+check_header sys/select.h
+check_header termios.h
+check_header vdpau/vdpau.h
+check_header vdpau/vdpau_x11.h
+check_header X11/extensions/XvMClib.h
+
+check_struct dxva2api.h DXVA_PictureParameters wDecodedPictureIndex
+
+if ! enabled_any memalign memalign_hack posix_memalign malloc_aligned &&
+     enabled_any $need_memalign ; then
+    die "Error, no aligned memory allocator but SSE enabled, disable it or use --enable-memalign-hack."
+fi
+
+disabled  zlib || check_lib   zlib.h      zlibVersion -lz   || disable  zlib
+disabled bzlib || check_lib2 bzlib.h BZ2_bzlibVersion -lbz2 || disable bzlib
+
+# check for some common methods of building with pthread support
+# do this before the optional library checks as some of them require pthreads
+if enabled pthreads; then
+    if check_func pthread_create; then
+        :
+    elif check_func pthread_create -pthread; then
+        add_cflags -pthread
+        add_extralibs -pthread
+    elif check_func pthread_create -pthreads; then
+        add_cflags -pthreads
+        add_extralibs -pthreads
+    elif check_func pthread_create -lpthreadGC2; then
+        add_extralibs -lpthreadGC2
+    elif ! check_lib pthread.h pthread_create -lpthread; then
+        die "ERROR: can't find pthreads library"
+    fi
+fi
+
+for thread in $THREADS_LIST; do
+    if enabled $thread; then
+        test -n "$thread_type" &&
+            die "ERROR: Only one thread type must be selected." ||
+            thread_type="$thread"
+    fi
+done
+
+check_lib math.h sin -lm
+check_lib va/va.h vaInitialize -lva
+
+check_func exp2
+check_func exp2f
+check_func llrint
+check_func log2
+check_func log2f
+check_func lrint
+check_func lrintf
+check_func round
+check_func roundf
+check_func truncf
+
+# these are off by default, so fail if requested and not available
+enabled avisynth   && require2 vfw32 "windows.h vfw.h" AVIFileInit -lavifil32
+enabled libdirac   && add_cflags $(pkg-config --cflags dirac) &&
+                      require  libdirac libdirac_decoder/dirac_parser.h dirac_decoder_init $(pkg-config --libs dirac) &&
+                      require  libdirac libdirac_encoder/dirac_encoder.h dirac_encoder_init $(pkg-config --libs dirac)
+enabled libfaac    && require2 libfaac "stdint.h faac.h" faacEncGetVersion -lfaac
+enabled libfaad    && require2 libfaad faad.h faacDecOpen -lfaad
+enabled libgsm     && require  libgsm gsm/gsm.h gsm_create -lgsm
+enabled libmp3lame && require  libmp3lame lame/lame.h lame_init -lmp3lame -lm
+enabled libnut     && require  libnut libnut.h nut_demuxer_init -lnut
+enabled libopencore_amrnb  && require libopencore_amrnb opencore-amrnb/interf_dec.h Decoder_Interface_init -lopencore-amrnb -lm
+enabled libopencore_amrwb  && require libopencore_amrwb opencore-amrwb/dec_if.h D_IF_init -lopencore-amrwb -lm
+enabled libopenjpeg && require libopenjpeg openjpeg.h opj_version -lopenjpeg
+enabled libschroedinger && add_cflags $(pkg-config --cflags schroedinger-1.0) &&
+                           require libschroedinger schroedinger/schro.h schro_init $(pkg-config --libs schroedinger-1.0)
+enabled libspeex   && require  libspeex speex/speex.h speex_decoder_init -lspeex
+enabled libtheora  && require  libtheora theora/theoraenc.h th_info_init -ltheoraenc -ltheoradec -logg
+enabled libvorbis  && require  libvorbis vorbis/vorbisenc.h vorbis_info_init -lvorbisenc -lvorbis -logg
+enabled libx264    && require  libx264 x264.h x264_encoder_encode -lx264 -lm &&
+                      { check_cpp_condition x264.h "X264_BUILD >= 83" ||
+                        die "ERROR: libx264 version must be >= 0.83."; }
+enabled libxvid    && require  libxvid xvid.h xvid_global -lxvidcore
+enabled mlib       && require  mediaLib mlib_types.h mlib_VectorSub_S16_U8_Mod -lmlib
+
+# libdc1394 check
+if enabled libdc1394; then
+    { check_lib dc1394/dc1394.h dc1394_new -ldc1394 -lraw1394 &&
+        enable libdc1394_2; } ||
+    { check_lib libdc1394/dc1394_control.h dc1394_create_handle -ldc1394_control -lraw1394 &&
+        enable libdc1394_1; } ||
+    die "ERROR: No version of libdc1394 found "
+fi
+
+SDL_CONFIG="${cross_prefix}sdl-config"
+if "${SDL_CONFIG}" --version > /dev/null 2>&1; then
+    sdl_cflags=$("${SDL_CONFIG}" --cflags)
+    sdl_libs=$("${SDL_CONFIG}" --libs)
+    check_func_headers SDL.h SDL_Init $sdl_cflags $sdl_libs &&
+    check_cpp_condition SDL.h "(SDL_MAJOR_VERSION<<16 | SDL_MINOR_VERSION<<8 | SDL_PATCHLEVEL) >= 0x010201" $sdl_cflags &&
+    enable sdl &&
+    check_struct SDL.h SDL_VideoInfo current_w $sdl_cflags && enable sdl_video_size
+fi
+
+texi2html -version > /dev/null 2>&1 && enable texi2html || disable texi2html
+
+if enabled network; then
+    check_type "sys/types.h sys/socket.h" socklen_t
+    check_type netdb.h "struct addrinfo"
+    check_type netinet/in.h "struct ipv6_mreq"
+    check_type netinet/in.h "struct sockaddr_in6"
+    check_type "sys/types.h sys/socket.h" "struct sockaddr_storage"
+    check_struct "sys/types.h sys/socket.h" "struct sockaddr" sa_len
+    # Prefer arpa/inet.h over winsock2
+    if check_header arpa/inet.h ; then
+        check_func closesocket
+    elif check_header winsock2.h ; then
+        check_func_headers winsock2.h closesocket -lws2 && \
+            network_extralibs="-lws2" || \
+        { check_func_headers winsock2.h closesocket -lws2_32 && \
+            network_extralibs="-lws2_32"; }
+        check_type ws2tcpip.h socklen_t
+        check_type ws2tcpip.h "struct addrinfo"
+        check_type ws2tcpip.h "struct ipv6_mreq"
+        check_type ws2tcpip.h "struct sockaddr_in6"
+        check_type ws2tcpip.h "struct sockaddr_storage"
+        check_struct winsock2.h "struct sockaddr" sa_len
+    else
+        disable network
+    fi
+fi
+
+check_header linux/videodev.h
+check_header linux/videodev2.h
+check_header sys/videoio.h
+
+check_func_headers "windows.h vfw.h" capCreateCaptureWindow "$vfwcap_indev_extralibs"
+
+# check for ioctl_meteor.h, ioctl_bt848.h and alternatives
+{ check_header dev/bktr/ioctl_meteor.h &&
+  check_header dev/bktr/ioctl_bt848.h; } ||
+{ check_header machine/ioctl_meteor.h &&
+  check_header machine/ioctl_bt848.h; } ||
+{ check_header dev/video/meteor/ioctl_meteor.h &&
+  check_header dev/video/bktr/ioctl_bt848.h; } ||
+check_header dev/ic/bt8xx.h
+
+check_header sys/soundcard.h
+check_header soundcard.h
+
+enabled_any alsa_indev alsa_outdev && check_lib2 alsa/asoundlib.h snd_pcm_htimestamp -lasound
+
+enabled jack_indev && check_lib2 jack/jack.h jack_client_open -ljack
+
+enabled x11grab                         &&
+check_header X11/Xlib.h                 &&
+check_header X11/extensions/XShm.h      &&
+check_header X11/extensions/Xfixes.h    &&
+check_func XOpenDisplay -lX11           &&
+check_func XShmCreateImage -lX11 -lXext &&
+check_func XFixesGetCursorImage -lX11 -lXext -lXfixes
+
+if ! disabled vdpau && enabled vdpau_vdpau_h; then
+check_cpp_condition \
+    vdpau/vdpau.h "defined VDP_DECODER_PROFILE_MPEG4_PART2_ASP" ||
+    { echolog "Please upgrade to libvdpau >= 0.2 if you would like vdpau support." &&
+      disable vdpau; }
+fi
+
+enabled debug && add_cflags -g"$debuglevel" && add_asflags -g"$debuglevel"
+
+# add some useful compiler flags if supported
+check_cflags -Wdeclaration-after-statement
+check_cflags -Wall
+check_cflags -Wno-switch
+check_cflags -Wdisabled-optimization
+check_cflags -Wpointer-arith
+check_cflags -Wredundant-decls
+check_cflags -Wno-pointer-sign
+check_cflags -Wcast-qual
+check_cflags -Wwrite-strings
+check_cflags -Wtype-limits
+check_cflags -Wundef
+enabled extra_warnings && check_cflags -Winline
+
+# add some linker flags
+check_ldflags -Wl,--warn-common
+check_ldflags -Wl,--as-needed
+check_ldflags '-Wl,-rpath-link,\$(BUILD_ROOT)/libpostproc -Wl,-rpath-link,\$(BUILD_ROOT)/libswscale -Wl,-rpath-link,\$(BUILD_ROOT)/libavfilter -Wl,-rpath-link,\$(BUILD_ROOT)/libavdevice -Wl,-rpath-link,\$(BUILD_ROOT)/libavformat -Wl,-rpath-link,\$(BUILD_ROOT)/libavcodec -Wl,-rpath-link,\$(BUILD_ROOT)/libavutil'
+check_ldflags -Wl,-Bsymbolic
+
+echo "X{};" > $TMPV
+test_ldflags -Wl,--version-script,$TMPV &&
+    append SHFLAGS '-Wl,--version-script,\$(SUBDIR)lib\$(NAME).ver'
+
+if enabled small; then
+    add_cflags $size_cflags
+    optimizations="small"
+elif enabled optimizations; then
+    add_cflags $speed_cflags
+fi
+check_cflags -fno-math-errno
+check_cflags -fno-signed-zeros
+
+if enabled icc; then
+    # Just warnings, no remarks
+    check_cflags -w1
+    # -wd: Disable following warnings
+    # 144, 167, 556: -Wno-pointer-sign
+    # 10006: ignoring unknown option -fno-signed-zeros
+    # 10156: ignoring option '-W'; no argument required
+    check_cflags -wd144,167,556,10006,10156
+    # 11030: Warning unknown option --as-needed
+    # 10156: ignoring option '-export'; no argument required
+    check_ldflags -wd10156,11030
+    # Allow to compile with optimizations
+    check_ldflags -march=$cpu
+    # icc 11.0 and 11.1 work with ebp_available, but don't pass the test
+    enable ebp_available
+elif enabled ccc; then
+    # disable some annoying warnings
+    add_cflags -msg_disable cvtu32to64
+    add_cflags -msg_disable embedcomment
+    add_cflags -msg_disable needconstext
+    add_cflags -msg_disable nomainieee
+    add_cflags -msg_disable ptrmismatch1
+    add_cflags -msg_disable unreachcode
+elif enabled gcc; then
+    check_cflags -fno-tree-vectorize
+elif enabled clang; then
+    check_cflags -Qunused-arguments
+elif enabled armcc; then
+    # 2523: use of inline assembler is deprecated
+    add_cflags -Wrvct,--diag_suppress=2523
+elif enabled tms470; then
+    add_cflags -pds=824 -pds=837
+fi
+
+if enabled gprof; then
+    add_cflags  -p
+    add_ldflags -p
+fi
+
+# Find out if the .align argument is a power of two or not.
+check_asm asmalign_pot '".align 3"'
+
+enabled_any $DECODER_LIST      && enable decoders
+enabled_any $ENCODER_LIST      && enable encoders
+enabled_any $HWACCEL_LIST      && enable hwaccels
+enabled_any $BSF_LIST          && enable bsfs
+enabled_any $DEMUXER_LIST      && enable demuxers
+enabled_any $MUXER_LIST        && enable muxers
+enabled_any $FILTER_LIST       && enable filters
+enabled_any $INDEV_LIST        && enable indevs
+enabled_any $OUTDEV_LIST       && enable outdevs
+enabled_any $PROTOCOL_LIST     && enable protocols
+
+enabled_any $THREADS_LIST      && enable threads
+
+check_deps $CONFIG_LIST       \
+           $CONFIG_EXTRA      \
+           $HAVE_LIST         \
+           $DECODER_LIST      \
+           $ENCODER_LIST      \
+           $HWACCEL_LIST      \
+           $PARSER_LIST       \
+           $BSF_LIST          \
+           $DEMUXER_LIST      \
+           $MUXER_LIST        \
+           $FILTER_LIST       \
+           $INDEV_LIST        \
+           $OUTDEV_LIST       \
+           $PROTOCOL_LIST     \
+
+enabled asm || disable $ARCH_LIST $ARCH_EXT_LIST
+
+echo "install prefix            $prefix"
+echo "source path               $source_path"
+echo "C compiler                $cc"
+echo ".align is power-of-two    $asmalign_pot"
+echo "ARCH                      $arch ($cpu)"
+if test "$build_suffix" != ""; then
+    echo "build suffix              $build_suffix"
+fi
+if test "$extra_version" != ""; then
+    echo "version string suffix     $extra_version"
+fi
+echo "big-endian                ${bigendian-no}"
+echo "runtime cpu detection     ${runtime_cpudetect-no}"
+if enabled x86; then
+    echo "yasm                      ${yasm-no}"
+    echo "MMX enabled               ${mmx-no}"
+    echo "MMX2 enabled              ${mmx2-no}"
+    echo "3DNow! enabled            ${amd3dnow-no}"
+    echo "3DNow! extended enabled   ${amd3dnowext-no}"
+    echo "SSE enabled               ${sse-no}"
+    echo "SSSE3 enabled             ${ssse3-no}"
+    echo "CMOV enabled              ${cmov-no}"
+    echo "CMOV is fast              ${fast_cmov-no}"
+    echo "EBX available             ${ebx_available-no}"
+    echo "EBP available             ${ebp_available-no}"
+    echo "10 operands supported     ${ten_operands-no}"
+fi
+if enabled arm; then
+    echo "ARMv5TE enabled           ${armv5te-no}"
+    echo "ARMv6 enabled             ${armv6-no}"
+    echo "ARMv6T2 enabled           ${armv6t2-no}"
+    echo "ARM VFP enabled           ${armvfp-no}"
+    echo "IWMMXT enabled            ${iwmmxt-no}"
+    echo "NEON enabled              ${neon-no}"
+fi
+if enabled mips; then
+    echo "MMI enabled               ${mmi-no}"
+fi
+if enabled ppc; then
+    echo "AltiVec enabled           ${altivec-no}"
+    echo "PPC 4xx optimizations     ${ppc4xx-no}"
+    echo "dcbzl available           ${dcbzl-no}"
+    echo "performance report        ${powerpc_perf-no}"
+fi
+if enabled sparc; then
+    echo "VIS enabled               ${vis-no}"
+fi
+echo "gprof enabled             ${gprof-no}"
+echo "debug symbols             ${debug-no}"
+echo "strip symbols             ${stripping-no}"
+echo "optimizations             ${optimizations-no}"
+echo "static                    ${static-no}"
+echo "shared                    ${shared-no}"
+echo "postprocessing support    ${postproc-no}"
+echo "new filter support        ${avfilter-no}"
+echo "filters using lavformat   ${avfilter_lavf-no}"
+echo "network support           ${network-no}"
+echo "threading support         ${thread_type-no}"
+echo "SDL support               ${sdl-no}"
+echo "Sun medialib support      ${mlib-no}"
+echo "AVISynth enabled          ${avisynth-no}"
+echo "libdc1394 support         ${libdc1394-no}"
+echo "libdirac enabled          ${libdirac-no}"
+echo "libfaac enabled           ${libfaac-no}"
+echo "libfaad enabled           ${libfaad-no}"
+echo "libfaad dlopened          ${libfaadbin-no}"
+echo "libgsm enabled            ${libgsm-no}"
+echo "libmp3lame enabled        ${libmp3lame-no}"
+echo "libnut enabled            ${libnut-no}"
+echo "libopencore-amrnb support ${libopencore_amrnb-no}"
+echo "libopencore-amrwb support ${libopencore_amrwb-no}"
+echo "libopenjpeg enabled       ${libopenjpeg-no}"
+echo "libschroedinger enabled   ${libschroedinger-no}"
+echo "libspeex enabled          ${libspeex-no}"
+echo "libtheora enabled         ${libtheora-no}"
+echo "libvorbis enabled         ${libvorbis-no}"
+echo "libx264 enabled           ${libx264-no}"
+echo "libxvid enabled           ${libxvid-no}"
+echo "zlib enabled              ${zlib-no}"
+echo "bzlib enabled             ${bzlib-no}"
+echo
+
+for type in decoder encoder hwaccel parser demuxer muxer protocol filter bsf indev outdev; do
+    echo "Enabled ${type}s:"
+    eval list=\$$(toupper $type)_LIST
+    for part in $list; do
+        enabled $part && echo ${part%_*}
+    done | sort | pr -3 -t
+    echo
+done
+
+license="LGPL version 2.1 or later"
+if enabled nonfree; then
+    license="nonfree and unredistributable"
+elif enabled gplv3; then
+    license="GPL version 3 or later"
+elif enabled lgplv3; then
+    license="LGPL version 3 or later"
+elif enabled gpl; then
+    license="GPL version 2 or later"
+fi
+
+echo "License: $license"
+
+echo "Creating config.mak and config.h..."
+
+# build tree in object directory if source path is different from current one
+if enabled source_path_used; then
+    DIRS="
+        doc
+        libavcodec
+        libavcodec/$arch
+        libavdevice
+        libavfilter
+        libavformat
+        libavutil
+        libavutil/$arch
+        libpostproc
+        libswscale
+        libswscale/$arch
+        tests
+        tools
+    "
+    FILES="
+        Makefile
+        common.mak
+        subdir.mak
+        doc/texi2pod.pl
+        libavcodec/Makefile
+        libavdevice/Makefile
+        libavfilter/Makefile
+        libavformat/Makefile
+        libavutil/Makefile
+        libpostproc/Makefile
+        libswscale/Makefile
+    "
+    for dir in $DIRS ; do
+        mkdir -p $dir
+    done
+    for f in $FILES ; do
+        $ln_s "$source_path/$f" $f
+    done
+fi
+
+enabled stripping || strip="echo skipping strip"
+
+cat > config.mak <<EOF
+# Automatically generated by configure - do not modify!
+ifndef FFMPEG_CONFIG_MAK
+FFMPEG_CONFIG_MAK=1
+FFMPEG_CONFIGURATION=$FFMPEG_CONFIGURATION
+prefix=$prefix
+LIBDIR=\$(DESTDIR)$libdir
+SHLIBDIR=\$(DESTDIR)$shlibdir
+INCDIR=\$(DESTDIR)$incdir
+BINDIR=\$(DESTDIR)$bindir
+DATADIR=\$(DESTDIR)$datadir
+MANDIR=\$(DESTDIR)$mandir
+SRC_PATH="$source_path"
+SRC_PATH_BARE=$source_path
+BUILD_ROOT="$PWD"
+ARCH=$arch
+CC=$cc
+AS=$as
+LD=$ld
+DEPCC=$dep_cc
+YASM=$yasmexe
+AR=$ar
+RANLIB=$ranlib
+LN_S=$ln_s
+STRIP=$strip
+CPPFLAGS=$CPPFLAGS
+CFLAGS=$CFLAGS
+ASFLAGS=$ASFLAGS
+CC_O=$CC_O
+LDFLAGS=$LDFLAGS
+FFSERVERLDFLAGS=$FFSERVERLDFLAGS
+SHFLAGS=$SHFLAGS
+YASMFLAGS=$YASMFLAGS
+BUILDSUF=$build_suffix
+FULLNAME=$FULLNAME
+LIBPREF=$LIBPREF
+LIBSUF=$LIBSUF
+LIBNAME=$LIBNAME
+SLIBPREF=$SLIBPREF
+SLIBSUF=$SLIBSUF
+EXESUF=$EXESUF
+EXTRA_VERSION=$extra_version
+DEPFLAGS=$DEPFLAGS
+CCDEP=$CCDEP
+ASDEP=$ASDEP
+CC_DEPFLAGS=$CC_DEPFLAGS
+AS_DEPFLAGS=$AS_DEPFLAGS
+HOSTCC=$host_cc
+HOSTCFLAGS=$host_cflags
+HOSTEXESUF=$HOSTEXESUF
+HOSTLDFLAGS=$host_ldflags
+HOSTLIBS=$host_libs
+TARGET_EXEC=$target_exec
+TARGET_PATH=$target_path
+SDL_LIBS=$sdl_libs
+SDL_CFLAGS=$sdl_cflags
+LIB_INSTALL_EXTRA_CMD=$LIB_INSTALL_EXTRA_CMD
+EXTRALIBS=$extralibs
+EOF
+
+get_version(){
+    name=$1
+    file=$source_path/$2
+    eval $(grep "#define ${name}_VERSION_M" "$file" | awk '{ print $2"="$3 }')
+    eval ${name}_VERSION=\$${name}_VERSION_MAJOR.\$${name}_VERSION_MINOR.\$${name}_VERSION_MICRO
+    lcname=$(tolower $name)
+    eval echo "${lcname}_VERSION=\$${name}_VERSION" >> config.mak
+    eval echo "${lcname}_VERSION_MAJOR=\$${name}_VERSION_MAJOR" >> config.mak
+}
+
+get_version LIBSWSCALE  libswscale/swscale.h
+get_version LIBPOSTPROC libpostproc/postprocess.h
+get_version LIBAVCODEC  libavcodec/avcodec.h
+get_version LIBAVDEVICE libavdevice/avdevice.h
+get_version LIBAVFORMAT libavformat/avformat.h
+get_version LIBAVUTIL   libavutil/avutil.h
+get_version LIBAVFILTER libavfilter/avfilter.h
+
+enabled shared && cat >> config.mak <<EOF
+LIBTARGET=${LIBTARGET}
+SLIBNAME=${SLIBNAME}
+SLIBNAME_WITH_VERSION=${SLIBNAME_WITH_VERSION}
+SLIBNAME_WITH_MAJOR=${SLIBNAME_WITH_MAJOR}
+SLIB_CREATE_DEF_CMD=${SLIB_CREATE_DEF_CMD}
+SLIB_EXTRA_CMD=${SLIB_EXTRA_CMD}
+SLIB_INSTALL_EXTRA_CMD=${SLIB_INSTALL_EXTRA_CMD}
+SLIB_UNINSTALL_EXTRA_CMD=${SLIB_UNINSTALL_EXTRA_CMD}
+EOF
+
+enabled asmalign_pot || align_shift="1 <<"
+
+cat > $TMPH <<EOF
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+#define FFMPEG_CONFIGURATION "$(c_escape $FFMPEG_CONFIGURATION)"
+#define FFMPEG_LICENSE "$(c_escape $license)"
+#define FFMPEG_DATADIR "$(eval c_escape $datadir)"
+#define CC_TYPE "$cc_type"
+#define CC_VERSION $cc_version
+#define restrict $_restrict
+#define ASMALIGN(ZEROBITS) ".align $align_shift " #ZEROBITS "\\n\\t"
+#define EXTERN_PREFIX "${extern_prefix}"
+#define EXTERN_ASM ${extern_prefix}
+EOF
+
+test -n "$malloc_prefix" &&
+    echo "#define MALLOC_PREFIX $malloc_prefix" >>$TMPH
+
+if enabled small || disabled optimizations; then
+    echo "#define av_always_inline"  >> $TMPH
+fi
+
+print_config ARCH_   $TMPH config.mak $ARCH_LIST
+print_config HAVE_   $TMPH config.mak $HAVE_LIST
+print_config CONFIG_ $TMPH config.mak $CONFIG_LIST       \
+                                      $CONFIG_EXTRA      \
+                                      $DECODER_LIST      \
+                                      $ENCODER_LIST      \
+                                      $HWACCEL_LIST      \
+                                      $PARSER_LIST       \
+                                      $BSF_LIST          \
+                                      $DEMUXER_LIST      \
+                                      $MUXER_LIST        \
+                                      $FILTER_LIST       \
+                                      $PROTOCOL_LIST     \
+                                      $INDEV_LIST        \
+                                      $OUTDEV_LIST       \
+
+echo "#endif /* FFMPEG_CONFIG_H */" >> $TMPH
+echo "endif # FFMPEG_CONFIG_MAK" >> config.mak
+
+# Do not overwrite an unchanged config.h to avoid superfluous rebuilds.
+cp_if_changed $TMPH config.h
+
+cat > $TMPH <<EOF
+/* Generated by ffconf */
+#ifndef AVUTIL_AVCONFIG_H
+#define AVUTIL_AVCONFIG_H
+EOF
+
+print_config AV_HAVE_ $TMPH /dev/null $HAVE_LIST_PUB
+
+echo "#endif /* AVUTIL_AVCONFIG_H */" >> $TMPH
+
+cp_if_changed $TMPH libavutil/avconfig.h
+
+# build pkg-config files
+
+pkgconfig_generate(){
+name=$1
+shortname=${name#lib}${build_suffix}
+comment=$2
+version=$3
+libs=$4
+requires=$5
+cat <<EOF > $name/$name.pc
+prefix=$prefix
+exec_prefix=\${prefix}
+libdir=$libdir
+includedir=$incdir
+
+Name: $name
+Description: $comment
+Version: $version
+Requires: $(enabled shared || echo $requires)
+Requires.private: $(enabled shared && echo $requires)
+Conflicts:
+Libs: -L\${libdir} -l${shortname} $(enabled shared || echo $libs)
+Libs.private: $(enabled shared && echo $libs)
+Cflags: -I\${includedir}
+EOF
+cat <<EOF > $name/$name-uninstalled.pc
+prefix=
+exec_prefix=
+libdir=\${pcfiledir}
+includedir=${source_path}
+
+Name: $name
+Description: $comment
+Version: $version
+Requires: $requires
+Conflicts:
+Libs: \${libdir}/${LIBPREF}${shortname}${LIBSUF} $libs
+Cflags: -I\${includedir}
+EOF
+}
+
+pkgconfig_generate libavutil "FFmpeg utility library" "$LIBAVUTIL_VERSION"
+pkgconfig_generate libavcodec "FFmpeg codec library" "$LIBAVCODEC_VERSION" "$extralibs" "libavutil = $LIBAVUTIL_VERSION"
+pkgconfig_generate libavformat "FFmpeg container format library" "$LIBAVFORMAT_VERSION" "$extralibs" "libavcodec = $LIBAVCODEC_VERSION"
+pkgconfig_generate libavdevice "FFmpeg device handling library" "$LIBAVDEVICE_VERSION" "$extralibs" "libavformat = $LIBAVFORMAT_VERSION"
+enabled avfilter &&
+    pkgconfig_generate libavfilter "FFmpeg video filtering library" "$LIBAVFILTER_VERSION" "$extralibs" "libavutil = $LIBAVUTIL_VERSION"
+enabled postproc &&
+    pkgconfig_generate libpostproc "FFmpeg post processing library" "$LIBPOSTPROC_VERSION"
+pkgconfig_generate libswscale "FFmpeg image rescaling library" "$LIBSWSCALE_VERSION" "" "libavutil = $LIBAVUTIL_VERSION"
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/configure.orig.fixed ffmpeg-for-2.2.5/configure.orig.fixed
--- ffmpeg-r21659/configure.orig.fixed	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/configure.orig.fixed	2010-02-07 11:46:26.000000000 -0700
@@ -0,0 +1,3087 @@
+#!/bin/sh
+#
+# FFmpeg configure script
+#
+# Copyright (c) 2000-2002 Fabrice Bellard
+# Copyright (c) 2005-2008 Diego Biurrun
+# Copyright (c) 2005-2008 Mans Rullgard
+#
+
+# Prevent locale nonsense from breaking basic text processing.
+LC_ALL=C
+export LC_ALL
+
+# make sure we are running under a compatible shell
+# try to make this part work with most shells
+
+try_exec(){
+    echo "Trying shell $1"
+    type "$1" > /dev/null 2>&1 && exec "$@"
+}
+
+unset foo
+(: ${foo%%bar}) 2> /dev/null
+E1="$?"
+
+(: ${foo?}) 2> /dev/null
+E2="$?"
+
+if test "$E1" != 0 || test "$E2" = 0; then
+    echo "Broken shell detected.  Trying alternatives."
+    export FF_CONF_EXEC
+    if test "0$FF_CONF_EXEC" -lt 1; then
+        FF_CONF_EXEC=1
+        try_exec bash "$0" "$@"
+    fi
+    if test "0$FF_CONF_EXEC" -lt 2; then
+        FF_CONF_EXEC=2
+        try_exec ksh "$0" "$@"
+    fi
+    if test "0$FF_CONF_EXEC" -lt 3; then
+        FF_CONF_EXEC=3
+        try_exec /usr/xpg4/bin/sh "$0" "$@"
+    fi
+    echo "No compatible shell script interpreter found."
+    echo "This configure script requires a POSIX-compatible shell"
+    echo "such as bash or ksh."
+    echo "THIS IS NOT A BUG IN FFMPEG, DO NOT REPORT IT AS SUCH."
+    echo "Instead, install a working POSIX-compatible shell."
+    echo "Disabling this configure test will create a broken FFmpeg."
+    if test "$BASH_VERSION" = '2.04.0(1)-release'; then
+        echo "This bash version ($BASH_VERSION) is broken on your platform."
+        echo "Upgrade to a later version if available."
+    fi
+    exit 1
+fi
+
+show_help(){
+cat <<EOF
+Usage: configure [options]
+Options: [defaults in brackets after descriptions]
+
+Standard options:
+  --help                   print this message
+  --logfile=FILE           log tests and output to FILE [config.err]
+  --disable-logging        do not log configure debug information
+  --prefix=PREFIX          install in PREFIX [$prefix]
+  --bindir=DIR             install binaries in DIR [PREFIX/bin]
+  --datadir=DIR            install data files in DIR [PREFIX/share/ffmpeg]
+  --libdir=DIR             install libs in DIR [PREFIX/lib]
+  --shlibdir=DIR           install shared libs in DIR [PREFIX/lib]
+  --incdir=DIR             install includes in DIR [PREFIX/include]
+  --mandir=DIR             install man page in DIR [PREFIX/share/man]
+
+Configuration options:
+  --disable-static         do not build static libraries [no]
+  --enable-shared          build shared libraries [no]
+  --enable-gpl             allow use of GPL code, the resulting libs
+                           and binaries will be under GPL [no]
+  --enable-version3        upgrade (L)GPL to version 3 [no]
+  --enable-nonfree         allow use of nonfree code, the resulting libs
+                           and binaries will be unredistributable [no]
+  --disable-doc            do not build documentation
+  --disable-ffmpeg         disable ffmpeg build
+  --disable-ffplay         disable ffplay build
+  --disable-ffserver       disable ffserver build
+  --disable-avdevice       disable libavdevice build
+  --disable-avcodec        disable libavcodec build
+  --disable-avformat       disable libavformat build
+  --disable-swscale        disable libswscale build
+  --enable-postproc        enable GPLed postprocessing support [no]
+  --enable-avfilter        video filter support [no]
+  --enable-avfilter-lavf   video filters dependent on avformat [no]
+  --enable-beosthreads     use BeOS threads [no]
+  --enable-os2threads      use OS/2 threads [no]
+  --enable-pthreads        use pthreads [no]
+  --enable-w32threads      use Win32 threads [no]
+  --enable-x11grab         enable X11 grabbing [no]
+  --disable-network        disable network support [no]
+  --disable-mpegaudio-hp   faster (but less accurate) MPEG audio decoding [no]
+  --enable-gray            enable full grayscale support (slower color)
+  --disable-swscale-alpha  disable alpha channel support in swscale
+  --disable-fastdiv        disable table-based division
+  --enable-small           optimize for size instead of speed
+  --disable-aandct         disable AAN DCT code
+  --disable-dct            disable DCT code
+  --disable-fft            disable FFT code
+  --disable-golomb         disable Golomb code
+  --disable-lpc            disable LPC code
+  --disable-mdct           disable MDCT code
+  --disable-rdft           disable RDFT code
+  --disable-vaapi          disable VAAPI code
+  --disable-vdpau          disable VDPAU code
+  --disable-dxva2          disable DXVA2 code
+  --enable-runtime-cpudetect detect cpu capabilities at runtime (bigger binary)
+  --enable-hardcoded-tables use hardcoded tables instead of runtime generation
+  --enable-memalign-hack   emulate memalign, interferes with memory debuggers
+  --enable-beos-netserver  enable BeOS netserver
+  --disable-encoder=NAME   disable encoder NAME
+  --enable-encoder=NAME    enable encoder NAME
+  --disable-encoders       disable all encoders
+  --disable-decoder=NAME   disable decoder NAME
+  --enable-decoder=NAME    enable decoder NAME
+  --disable-decoders       disable all decoders
+  --disable-hwaccel=NAME   disable hwaccel NAME
+  --enable-hwaccel=NAME    enable hwaccel NAME
+  --disable-hwaccels       disable all hwaccels
+  --disable-muxer=NAME     disable muxer NAME
+  --enable-muxer=NAME      enable muxer NAME
+  --disable-muxers         disable all muxers
+  --disable-demuxer=NAME   disable demuxer NAME
+  --enable-demuxer=NAME    enable demuxer NAME
+  --disable-demuxers       disable all demuxers
+  --enable-parser=NAME     enable parser NAME
+  --disable-parser=NAME    disable parser NAME
+  --disable-parsers        disable all parsers
+  --enable-bsf=NAME        enable bitstream filter NAME
+  --disable-bsf=NAME       disable bitstream filter NAME
+  --disable-bsfs           disable all bitstream filters
+  --enable-protocol=NAME   enable protocol NAME
+  --disable-protocol=NAME  disable protocol NAME
+  --disable-protocols      disable all protocols
+  --disable-indev=NAME     disable input device NAME
+  --disable-outdev=NAME    disable output device NAME
+  --disable-indevs         disable input devices
+  --disable-outdevs        disable output devices
+  --disable-devices        disable all devices
+  --enable-filter=NAME     enable filter NAME
+  --disable-filter=NAME    disable filter NAME
+  --disable-filters        disable all filters
+  --list-decoders          show all available decoders
+  --list-encoders          show all available encoders
+  --list-hwaccels          show all available hardware accelerators
+  --list-muxers            show all available muxers
+  --list-demuxers          show all available demuxers
+  --list-parsers           show all available parsers
+  --list-protocols         show all available protocols
+  --list-bsfs              show all available bitstream filters
+  --list-indevs            show all available input devices
+  --list-outdevs           show all available output devices
+  --list-filters           show all available filters
+
+External library support:
+  --enable-avisynth        enable reading of AVISynth script files [no]
+  --enable-bzlib           enable bzlib [autodetect]
+  --enable-libopencore-amrnb enable AMR-NB de/encoding via libopencore-amrnb [no]
+  --enable-libopencore-amrwb enable AMR-WB decoding via libopencore-amrwb [no]
+  --enable-libdc1394       enable IIDC-1394 grabbing using libdc1394
+                           and libraw1394 [no]
+  --enable-libdirac        enable Dirac support via libdirac [no]
+  --enable-libfaac         enable FAAC support via libfaac [no]
+  --enable-libfaad         enable FAAD support via libfaad [no]
+  --enable-libfaadbin      open libfaad.so.0 at runtime [no]
+  --enable-libgsm          enable GSM support via libgsm [no]
+  --enable-libmp3lame      enable MP3 encoding via libmp3lame [no]
+  --enable-libnut          enable NUT (de)muxing via libnut,
+                           native (de)muxer exists [no]
+  --enable-libopenjpeg     enable JPEG 2000 decoding via OpenJPEG [no]
+  --enable-libschroedinger enable Dirac support via libschroedinger [no]
+  --enable-libspeex        enable Speex decoding via libspeex [no]
+  --enable-libtheora       enable Theora encoding via libtheora [no]
+  --enable-libvorbis       enable Vorbis encoding via libvorbis,
+                           native implementation exists [no]
+  --enable-libx264         enable H.264 encoding via x264 [no]
+  --enable-libxvid         enable Xvid encoding via xvidcore,
+                           native MPEG-4/Xvid encoder exists [no]
+  --enable-mlib            enable Sun medialib [no]
+  --enable-zlib            enable zlib [autodetect]
+
+Advanced options (experts only):
+  --source-path=PATH       path to source code [$source_path]
+  --cross-prefix=PREFIX    use PREFIX for compilation tools [$cross_prefix]
+  --enable-cross-compile   assume a cross-compiler is used
+  --sysroot=PATH           root of cross-build tree
+  --sysinclude=PATH        location of cross-build system headers
+  --target-os=OS           compiler targets OS [$target_os]
+  --target-exec=CMD        command to run executables on target
+  --target-path=DIR        path to view of build directory on target
+  --nm=NM                  use nm tool
+  --as=AS                  use assembler AS [$as_default]
+  --cc=CC                  use C compiler CC [$cc_default]
+  --ld=LD                  use linker LD
+  --host-cc=HOSTCC         use host C compiler HOSTCC
+  --host-cflags=HCFLAGS    use HCFLAGS when compiling for host
+  --host-ldflags=HLDFLAGS  use HLDFLAGS when linking for host
+  --host-libs=HLIBS        use libs HLIBS when linking for host
+  --extra-cflags=ECFLAGS   add ECFLAGS to CFLAGS [$CFLAGS]
+  --extra-ldflags=ELDFLAGS add ELDFLAGS to LDFLAGS [$LDFLAGS]
+  --extra-libs=ELIBS       add ELIBS [$ELIBS]
+  --extra-version=STRING   version string suffix []
+  --build-suffix=SUFFIX    library name suffix []
+  --arch=ARCH              select architecture [$arch]
+  --cpu=CPU                select the minimum required CPU (affects
+                           instruction selection, may crash on older CPUs)
+  --enable-powerpc-perf    enable performance report on PPC
+                           (requires enabling PMC)
+  --disable-asm            disable all assembler optimizations
+  --disable-altivec        disable AltiVec optimizations
+  --disable-amd3dnow       disable 3DNow! optimizations
+  --disable-amd3dnowext    disable 3DNow! extended optimizations
+  --disable-mmx            disable MMX optimizations
+  --disable-mmx2           disable MMX2 optimizations
+  --disable-sse            disable SSE optimizations
+  --disable-ssse3          disable SSSE3 optimizations
+  --disable-armv5te        disable armv5te optimizations
+  --disable-armv6          disable armv6 optimizations
+  --disable-armv6t2        disable armv6t2 optimizations
+  --disable-armvfp         disable ARM VFP optimizations
+  --disable-iwmmxt         disable iwmmxt optimizations
+  --disable-mmi            disable MMI optimizations
+  --disable-neon           disable neon optimizations
+  --disable-vis            disable VIS optimizations
+  --disable-yasm           disable use of yasm assembler
+  --enable-pic             build position-independent code
+  --malloc-prefix=PFX      prefix malloc and related names with PFX
+  --enable-sram            allow use of on-chip SRAM
+
+Developer options (useful when working on FFmpeg itself):
+  --disable-debug          disable debugging symbols
+  --enable-debug=LEVEL     set the debug level [$debuglevel]
+  --enable-gprof           enable profiling with gprof [$gprof]
+  --disable-optimizations  disable compiler optimizations
+  --enable-extra-warnings  enable more compiler warnings
+  --disable-stripping      disable stripping of executables and shared libraries
+
+NOTE: Object files are built at the place where configure is launched.
+EOF
+  exit 0
+}
+
+log(){
+    echo "$@" >> $logfile
+}
+
+log_file(){
+    log BEGIN $1
+    pr -n -t $1 >> $logfile
+    log END $1
+}
+
+echolog(){
+    log "$@"
+    echo "$@"
+}
+
+die(){
+    echolog "$@"
+    cat <<EOF
+
+If you think configure made a mistake, make sure you are using the latest
+version from SVN.  If the latest version fails, report the problem to the
+ffmpeg-user@mplayerhq.hu mailing list or IRC #ffmpeg on irc.freenode.net.
+EOF
+    if disabled logging; then
+        cat <<EOF
+Rerun configure with logging enabled (do not use --disable-logging), and
+include the log this produces with your report.
+EOF
+    else
+cat <<EOF
+Include the log file "$logfile" produced by configure as this will help
+solving the problem.
+EOF
+    fi
+    exit 1
+}
+
+# Avoid locale weirdness, besides we really just want to translate ASCII.
+toupper(){
+    echo "$@" | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
+}
+
+tolower(){
+    echo "$@" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz
+}
+
+c_escape(){
+    echo "$*" | sed 's/["\\]/\\\0/g'
+}
+
+sh_quote(){
+    v=$(echo "$1" | sed "s/'/'\\\\''/g")
+    test "$v" = "${v#*[ |&;<>()$\`\\\"\'*?\[\]#~=%]}" || v="'$v'"
+    echo "$v"
+}
+
+filter(){
+    pat=$1
+    shift
+    for v; do
+        eval "case $v in $pat) echo $v ;; esac"
+    done
+}
+
+set_all(){
+    value=$1
+    shift
+    for var in $*; do
+        eval $var=$value
+    done
+}
+
+set_weak(){
+    value=$1
+    shift
+    for var; do
+        eval : \${$var:=$value}
+    done
+}
+
+pushvar(){
+    for var in $*; do
+        eval level=\${${var}_level:=0}
+        eval ${var}_${level}="\$$var"
+        eval ${var}_level=$(($level+1))
+    done
+}
+
+popvar(){
+    for var in $*; do
+        eval level=\${${var}_level:-0}
+        test $level = 0 && continue
+        eval level=$(($level-1))
+        eval $var="\${${var}_${level}}"
+        eval ${var}_level=$level
+        eval unset ${var}_${level}
+    done
+}
+
+enable(){
+    set_all yes $*
+}
+
+disable(){
+    set_all no $*
+}
+
+enable_weak(){
+    set_weak yes $*
+}
+
+disable_weak(){
+    set_weak no $*
+}
+
+enable_safe(){
+    for var; do
+        enable $(echo "$var" | sed 's/[^A-Za-z0-9_]/_/g')
+    done
+}
+
+disable_safe(){
+    for var; do
+        disable $(echo "$var" | sed 's/[^A-Za-z0-9_]/_/g')
+    done
+}
+
+do_enable_deep(){
+    for var; do
+        enabled $var && continue
+        eval sel="\$${var}_select"
+        eval sgs="\$${var}_suggest"
+        pushvar var sgs
+        enable_deep $sel
+        popvar sgs
+        enable_deep_weak $sgs
+        popvar var
+    done
+}
+
+enable_deep(){
+    do_enable_deep $*
+    enable $*
+}
+
+enable_deep_weak(){
+    do_enable_deep $*
+    enable_weak $*
+}
+
+enabled(){
+    test "${1#!}" = "$1" && op== || op=!=
+    eval test "x\$${1#!}" $op "xyes"
+}
+
+disabled(){
+    test "${1#!}" = "$1" && op== || op=!=
+    eval test "x\$${1#!}" $op "xno"
+}
+
+enabled_all(){
+    for opt; do
+        enabled $opt || return 1
+    done
+}
+
+disabled_all(){
+    for opt; do
+        disabled $opt || return 1
+    done
+}
+
+enabled_any(){
+    for opt; do
+        enabled $opt && return 0
+    done
+}
+
+disabled_any(){
+    for opt; do
+        disabled $opt && return 0
+    done
+    return 1
+}
+
+set_default(){
+    for opt; do
+        eval : \${$opt:=\$${opt}_default}
+    done
+}
+
+is_in(){
+    value=$1
+    shift
+    for var in $*; do
+        [ $var = $value ] && return 0
+    done
+    return 1
+}
+
+check_deps(){
+    for cfg; do
+        cfg="${cfg#!}"
+        enabled ${cfg}_checking && die "Circular dependency for $cfg."
+        disabled ${cfg}_checking && continue
+        enable ${cfg}_checking
+
+        eval dep_all="\$${cfg}_deps"
+        eval dep_any="\$${cfg}_deps_any"
+        eval dep_sel="\$${cfg}_select"
+        eval dep_sgs="\$${cfg}_suggest"
+        eval dep_ifa="\$${cfg}_if"
+        eval dep_ifn="\$${cfg}_if_any"
+
+        pushvar cfg dep_all dep_any dep_sel dep_sgs dep_ifa dep_ifn
+        check_deps $dep_all $dep_any $dep_sel $dep_sgs $dep_ifa $dep_ifn
+        popvar cfg dep_all dep_any dep_sel dep_sgs dep_ifa dep_ifn
+
+        [ -n "$dep_ifa" ] && { enabled_all $dep_ifa && enable_weak $cfg; }
+        [ -n "$dep_ifn" ] && { enabled_any $dep_ifn && enable_weak $cfg; }
+        enabled_all  $dep_all || disable $cfg
+        enabled_any  $dep_any || disable $cfg
+        disabled_any $dep_sel && disable $cfg
+
+        if enabled $cfg; then
+            eval dep_extralibs="\$${cfg}_extralibs"
+            test -n "$dep_extralibs" && add_extralibs $dep_extralibs
+            enable_deep $dep_sel
+            enable_deep_weak $dep_sgs
+        fi
+
+        disable ${cfg}_checking
+    done
+}
+
+print_config(){
+    pfx=$1
+    header=$2
+    makefile=$3
+    shift 3
+    for cfg; do
+        ucname="$(toupper $cfg)"
+        if enabled $cfg; then
+            echo "#define ${pfx}${ucname} 1" >> $header
+            echo "${pfx}${ucname}=yes" >> $makefile
+        else
+            echo "#define ${pfx}${ucname} 0" >> $header
+            echo "!${pfx}${ucname}=yes" >> $makefile
+        fi
+    done
+}
+
+flags_saved(){
+    (: ${SAVE_CFLAGS?}) 2> /dev/null
+}
+
+save_flags(){
+    flags_saved && return
+    SAVE_CFLAGS="$CFLAGS"
+    SAVE_LDFLAGS="$LDFLAGS"
+    SAVE_extralibs="$extralibs"
+}
+
+restore_flags(){
+    flags_saved || return
+    CFLAGS="$SAVE_CFLAGS"
+    LDFLAGS="$SAVE_LDFLAGS"
+    extralibs="$SAVE_extralibs"
+    unset SAVE_CFLAGS
+    unset SAVE_LDFLAGS
+    unset SAVE_extralibs
+}
+
+temp_cflags(){
+    save_flags
+    CFLAGS="$CFLAGS $*"
+}
+
+temp_ldflags(){
+    save_flags
+    LDFLAGS="$LDFLAGS $*"
+}
+
+temp_extralibs(){
+    save_flags
+    extralibs="$extralibs $*"
+}
+
+append(){
+    var=$1
+    shift
+    flags_saved && eval "SAVE_$var=\"\$SAVE_$var $*\""
+    eval "$var=\"\$$var $*\""
+}
+
+add_cppflags(){
+    append CPPFLAGS $($filter_cppflags "$@")
+}
+
+add_cflags(){
+    append CFLAGS $($filter_cflags "$@")
+}
+
+add_asflags(){
+    append ASFLAGS $($filter_asflags "$@")
+}
+
+add_ldflags(){
+    append LDFLAGS "$@"
+}
+
+add_extralibs(){
+    append extralibs "$@"
+}
+
+check_cmd(){
+    log "$@"
+    "$@" >> $logfile 2>&1
+}
+
+check_cc(){
+    log check_cc "$@"
+    cat > $TMPC
+    log_file $TMPC
+    check_cmd $cc $CPPFLAGS $CFLAGS "$@" -c -o $TMPO $TMPC
+}
+
+check_cpp(){
+    log check_cpp "$@"
+    cat > $TMPC
+    log_file $TMPC
+    check_cmd $cc $CPPFLAGS $CFLAGS "$@" -E -o $TMPO $TMPC
+}
+
+check_as(){
+    log check_as "$@"
+    cat > $TMPC
+    log_file $TMPC
+    check_cmd $as $CPPFLAGS $ASFLAGS "$@" -c -o $TMPO $TMPC
+}
+
+check_asm(){
+    log check_asm "$@"
+    name="$1"
+    code="$2"
+    shift 2
+    disable $name
+    check_as "$@" <<EOF && enable $name
+void foo(void){ __asm__ volatile($code); }
+EOF
+}
+
+check_yasm(){
+    log check_yasm "$@"
+    echo "$1" > $TMPS
+    log_file $TMPS
+    shift 1
+    check_cmd $yasmexe $YASMFLAGS "$@" -o $TMPO $TMPS
+}
+
+check_ld(){
+    log check_ld "$@"
+    flags=''
+    libs=''
+    for f; do
+        test "${f}" = "${f#-l}" && flags="$flags $f" || libs="$libs $f"
+    done
+    check_cc $($filter_cflags $flags) || return
+    check_cmd $ld $LDFLAGS $flags -o $TMPE $TMPO $extralibs $libs
+}
+
+check_cppflags(){
+    log check_cppflags "$@"
+    set -- $($filter_cppflags "$@")
+    check_cc "$@" <<EOF && append CPPFLAGS "$@"
+int x;
+EOF
+}
+
+check_cflags(){
+    log check_cflags "$@"
+    set -- $($filter_cflags "$@")
+    check_cc "$@" <<EOF && append CFLAGS "$@"
+int x;
+EOF
+}
+
+test_ldflags(){
+    log test_ldflags "$@"
+    check_ld "$@" <<EOF
+int main(void){ return 0; }
+EOF
+}
+
+check_ldflags(){
+    log check_ldflags "$@"
+    test_ldflags "$@" && add_ldflags "$@"
+}
+
+check_header(){
+    log check_header "$@"
+    header=$1
+    shift
+    disable_safe $header
+    check_cpp "$@" <<EOF && enable_safe $header
+#include <$header>
+int x;
+EOF
+}
+
+check_func(){
+    log check_func "$@"
+    func=$1
+    shift
+    disable $func
+    check_ld "$@" <<EOF && enable $func
+extern int $func();
+int main(void){ $func(); }
+EOF
+}
+
+check_func_headers(){
+    log check_func_headers "$@"
+    headers=$1
+    func=$2
+    shift 2
+    disable $func
+    incs=""
+    for hdr in $headers; do
+        incs="$incs
+#include <$hdr>"
+    done
+    check_ld "$@" <<EOF && enable $func && enable_safe $headers
+$incs
+int main(int argc, char **argv){
+    return (long) $func;
+}
+EOF
+}
+
+check_cpp_condition(){
+    log check_cpp_condition "$@"
+    header=$1
+    condition=$2
+    shift 2
+    check_cpp $($filter_cppflags "$@") <<EOF
+#include <$header>
+#if !($condition)
+#error "unsatisfied condition: $condition"
+#endif
+EOF
+}
+
+check_lib(){
+    log check_lib "$@"
+    header="$1"
+    func="$2"
+    shift 2
+    temp_extralibs "$@"
+    check_header $header && check_func $func && add_extralibs "$@"
+    err=$?
+    restore_flags
+    return $err
+}
+
+check_lib2(){
+    log check_lib2 "$@"
+    headers="$1"
+    func="$2"
+    shift 2
+    check_func_headers "$headers" $func "$@" && add_extralibs "$@"
+}
+
+check_exec(){
+    check_ld "$@" && { enabled cross_compile || $TMPE >> $logfile 2>&1; }
+}
+
+check_exec_crash(){
+    code=$(cat)
+
+    # exit() is not async signal safe.  _Exit (C99) and _exit (POSIX)
+    # are safe but may not be available everywhere.  Thus we use
+    # raise(SIGTERM) instead.  The check is run in a subshell so we
+    # can redirect the "Terminated" message from the shell.  SIGBUS
+    # is not defined by standard C so it is used conditionally.
+
+    (check_exec "$@") >> $logfile 2>&1 <<EOF
+#include <signal.h>
+static void sighandler(int sig){
+    raise(SIGTERM);
+}
+int main(void){
+    signal(SIGILL, sighandler);
+    signal(SIGFPE, sighandler);
+    signal(SIGSEGV, sighandler);
+#ifdef SIGBUS
+    signal(SIGBUS, sighandler);
+#endif
+    { $code }
+}
+EOF
+}
+
+check_type(){
+    log check_type "$@"
+    headers=$1
+    type=$2
+    shift 2
+    disable_safe "$type"
+    incs=""
+    for hdr in $headers; do
+        incs="$incs
+#include <$hdr>"
+    done
+    check_cc "$@" <<EOF && enable_safe "$type"
+$incs
+$type v;
+EOF
+}
+
+check_struct(){
+    log check_type "$@"
+    headers=$1
+    struct=$2
+    member=$3
+    shift 3
+    disable_safe "${struct}_${member}"
+    incs=""
+    for hdr in $headers; do
+        incs="$incs
+#include <$hdr>"
+    done
+    check_cc "$@" <<EOF && enable_safe "${struct}_${member}"
+$incs
+const void *p = &(($struct *)0)->$member;
+EOF
+}
+
+require(){
+    name="$1"
+    header="$2"
+    func="$3"
+    shift 3
+    check_lib $header $func "$@" || die "ERROR: $name not found"
+}
+
+require2(){
+    name="$1"
+    headers="$2"
+    func="$3"
+    shift 3
+    check_lib2 "$headers" $func "$@" || die "ERROR: $name not found"
+}
+
+check_foo_config(){
+    cfg=$1
+    pkg=$2
+    header=$3
+    func=$4
+    shift 4
+    disable $cfg
+    check_cmd ${pkg}-config --version
+    err=$?
+    if test "$err" = 0; then
+        temp_cflags $(${pkg}-config --cflags)
+        temp_extralibs $(${pkg}-config --libs)
+        check_lib "$@" $header $func && enable $cfg
+    fi
+    return $err
+}
+
+check_host_cc(){
+    log check_host_cc "$@"
+    cat > $TMPC
+    log_file $TMPC
+    check_cmd $host_cc $host_cflags "$@" -c -o $TMPO $TMPC
+}
+
+check_host_cflags(){
+    log check_host_cflags "$@"
+    check_host_cc "$@" <<EOF && append host_cflags "$@"
+int x;
+EOF
+}
+
+apply(){
+    file=$1
+    shift
+    "$@" < "$file" > "$file.tmp" && mv "$file.tmp" "$file" || rm "$file.tmp"
+}
+
+cp_if_changed(){
+    cmp -s "$1" "$2" &&
+        echo "$2 is unchanged" ||
+        cp -f "$1" "$2"
+}
+
+# CONFIG_LIST contains configurable options, while HAVE_LIST is for
+# system-dependent things.
+
+COMPONENT_LIST="
+    bsfs
+    decoders
+    demuxers
+    encoders
+    filters
+    hwaccels
+    indevs
+    muxers
+    outdevs
+    parsers
+    protocols
+"
+
+CONFIG_LIST="
+    $COMPONENT_LIST
+    aandct
+    avcodec
+    avdevice
+    avfilter
+    avfilter_lavf
+    avformat
+    avisynth
+    beos_netserver
+    bzlib
+    dct
+    doc
+    dxva2
+    fastdiv
+    ffmpeg
+    ffplay
+    ffserver
+    fft
+    golomb
+    gpl
+    gprof
+    gray
+    hardcoded_tables
+    libdc1394
+    libdirac
+    libfaac
+    libfaad
+    libfaadbin
+    libgsm
+    libmp3lame
+    libnut
+    libopencore_amrnb
+    libopencore_amrwb
+    libopenjpeg
+    libschroedinger
+    libspeex
+    libtheora
+    libvorbis
+    libx264
+    libxvid
+    lpc
+    mdct
+    memalign_hack
+    mlib
+    mpegaudio_hp
+    network
+    nonfree
+    pic
+    postproc
+    powerpc_perf
+    rdft
+    runtime_cpudetect
+    shared
+    small
+    sram
+    static
+    swscale
+    swscale_alpha
+    vaapi
+    vdpau
+    version3
+    x11grab
+    zlib
+"
+
+THREADS_LIST='
+    beosthreads
+    os2threads
+    pthreads
+    w32threads
+'
+
+ARCH_LIST='
+    alpha
+    arm
+    avr32
+    avr32_ap
+    avr32_uc
+    bfin
+    ia64
+    m68k
+    mips
+    mips64
+    parisc
+    ppc
+    ppc64
+    s390
+    sh4
+    sparc
+    sparc64
+    x86
+    x86_32
+    x86_64
+'
+
+ARCH_EXT_LIST='
+    altivec
+    amd3dnow
+    amd3dnowext
+    armv5te
+    armv6
+    armv6t2
+    armvfp
+    iwmmxt
+    mmi
+    mmx
+    mmx2
+    neon
+    ppc4xx
+    sse
+    ssse3
+    vis
+'
+
+HAVE_LIST_PUB='
+    bigendian
+'
+
+HAVE_LIST="
+    $ARCH_EXT_LIST
+    $HAVE_LIST_PUB
+    $THREADS_LIST
+    alsa_asoundlib_h
+    altivec_h
+    arpa_inet_h
+    attribute_may_alias
+    attribute_packed
+    bswap
+    closesocket
+    cmov
+    conio_h
+    dcbzl
+    dev_bktr_ioctl_bt848_h
+    dev_bktr_ioctl_meteor_h
+    dev_ic_bt8xx_h
+    dev_video_meteor_ioctl_meteor_h
+    dev_video_bktr_ioctl_bt848_h
+    dlfcn_h
+    dlopen
+    dos_paths
+    ebp_available
+    ebx_available
+    exp2
+    exp2f
+    fast_64bit
+    fast_clz
+    fast_cmov
+    fast_unaligned
+    fork
+    getaddrinfo
+    gethrtime
+    GetProcessTimes
+    getrusage
+    inet_aton
+    inline_asm
+    isatty
+    ldbrx
+    libdc1394_1
+    libdc1394_2
+    llrint
+    log2
+    log2f
+    loongson
+    lrint
+    lrintf
+    lzo1x_999_compress
+    machine_ioctl_bt848_h
+    machine_ioctl_meteor_h
+    malloc_h
+    memalign
+    mkstemp
+    pld
+    posix_memalign_disabled
+    round
+    roundf
+    sdl
+    sdl_video_size
+    setmode
+    socklen_t
+    soundcard_h
+    poll_h
+    struct_addrinfo
+    struct_ipv6_mreq
+    struct_sockaddr_in6
+    struct_sockaddr_sa_len
+    struct_sockaddr_storage
+    sys_mman_h
+    sys_resource_h
+    sys_select_h
+    sys_soundcard_h
+    sys_videoio_h
+    ten_operands
+    termios_h
+    threads
+    truncf
+    vfp_args
+    VirtualAlloc
+    winsock2_h
+    xform_asm
+    yasm
+"
+
+# options emitted with CONFIG_ prefix but not available on command line
+CONFIG_EXTRA="
+    avutil
+    gplv3
+    lgplv3
+"
+
+CMDLINE_SELECT="
+    $ARCH_EXT_LIST
+    $CONFIG_LIST
+    $THREADS_LIST
+    asm
+    cross_compile
+    debug
+    extra_warnings
+    logging
+    optimizations
+    stripping
+    yasm
+"
+
+PATHS_LIST='
+    bindir
+    datadir
+    incdir
+    libdir
+    mandir
+    prefix
+    shlibdir
+'
+
+CMDLINE_SET="
+    $PATHS_LIST
+    arch
+    as
+    build_suffix
+    cc
+    cpu
+    cross_prefix
+    dep_cc
+    extra_version
+    host_cc
+    host_cflags
+    host_ldflags
+    host_libs
+    host_os
+    ld
+    logfile
+    malloc_prefix
+    nm
+    source_path
+    sysinclude
+    sysroot
+    target_exec
+    target_os
+    target_path
+"
+
+CMDLINE_APPEND="
+    extra_cflags
+"
+
+# code dependency declarations
+
+# architecture extensions
+
+armv5te_deps="arm"
+armv6_deps="arm"
+armv6t2_deps="arm"
+armvfp_deps="arm"
+iwmmxt_deps="arm"
+neon_deps="arm"
+
+mmi_deps="mips"
+
+altivec_deps="ppc"
+ppc4xx_deps="ppc"
+
+vis_deps="sparc"
+
+x86_64_suggest="cmov fast_cmov"
+amd3dnow_deps="mmx"
+amd3dnowext_deps="amd3dnow"
+mmx_deps="x86"
+mmx2_deps="mmx"
+sse_deps="mmx"
+ssse3_deps="sse"
+
+fast_64bit_if_any="alpha ia64 mips64 parisc64 ppc64 sparc64 x86_64"
+fast_clz_if_any="alpha armv5te avr32 mips ppc x86"
+fast_unaligned_if_any="armv6 ppc x86"
+
+need_memalign="altivec neon sse"
+inline_asm_deps="!tms470"
+
+# decoders / encoders / hardware accelerators
+aac_decoder_select="fft mdct aac_parser"
+aac_encoder_select="fft mdct"
+ac3_decoder_select="fft mdct ac3_parser"
+alac_encoder_select="lpc"
+atrac3_decoder_select="fft mdct"
+binkaudio_dct_decoder_select="fft mdct rdft dct"
+binkaudio_rdft_decoder_select="fft mdct rdft"
+cavs_decoder_select="golomb"
+cook_decoder_select="fft mdct"
+cscd_decoder_suggest="zlib"
+dca_decoder_select="fft mdct"
+dnxhd_encoder_select="aandct"
+dxa_decoder_select="zlib"
+eac3_decoder_select="ac3_decoder"
+eamad_decoder_select="aandct"
+eatgq_decoder_select="aandct"
+eatqi_decoder_select="aandct"
+ffv1_decoder_select="golomb"
+flac_decoder_select="golomb"
+flac_encoder_select="golomb lpc"
+flashsv_decoder_select="zlib"
+flashsv_encoder_select="zlib"
+flv_decoder_select="h263_decoder"
+flv_encoder_select="h263_encoder"
+h261_encoder_select="aandct"
+h263_decoder_select="h263_parser"
+h263_encoder_select="aandct"
+h263_vaapi_hwaccel_deps="va_va_h"
+h263_vaapi_hwaccel_select="vaapi h263_decoder"
+h263i_decoder_select="h263_decoder"
+h263p_encoder_select="h263_encoder"
+h264_decoder_select="golomb"
+h264_dxva2_hwaccel_deps="dxva2api_h"
+h264_dxva2_hwaccel_select="dxva2 h264_decoder"
+h264_vaapi_hwaccel_deps="va_va_h"
+h264_vaapi_hwaccel_select="vaapi"
+h264_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+h264_vdpau_decoder_select="vdpau h264_decoder"
+imc_decoder_select="fft mdct"
+jpegls_decoder_select="golomb"
+jpegls_encoder_select="golomb"
+ljpeg_encoder_select="aandct"
+loco_decoder_select="golomb"
+mjpeg_encoder_select="aandct"
+mlp_decoder_select="mlp_parser"
+mpeg1video_encoder_select="aandct"
+mpeg2video_encoder_select="aandct"
+mpeg4_decoder_select="h263_decoder mpeg4video_parser"
+mpeg4_encoder_select="h263_encoder"
+mpeg_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+mpeg_vdpau_decoder_select="vdpau mpegvideo_decoder"
+mpeg1_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+mpeg1_vdpau_decoder_select="vdpau mpeg1video_decoder"
+mpeg2_vaapi_hwaccel_deps="va_va_h"
+mpeg2_vaapi_hwaccel_select="vaapi mpeg2video_decoder"
+mpeg4_vaapi_hwaccel_deps="va_va_h"
+mpeg4_vaapi_hwaccel_select="vaapi mpeg4_decoder"
+mpeg4_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+mpeg4_vdpau_decoder_select="vdpau mpeg4_decoder"
+mpeg_xvmc_decoder_deps="X11_extensions_XvMClib_h"
+mpeg_xvmc_decoder_select="mpegvideo_decoder"
+msmpeg4v1_decoder_select="h263_decoder"
+msmpeg4v1_encoder_select="h263_encoder"
+msmpeg4v2_decoder_select="h263_decoder"
+msmpeg4v2_encoder_select="h263_encoder"
+msmpeg4v3_decoder_select="h263_decoder"
+msmpeg4v3_encoder_select="h263_encoder"
+nellymoser_decoder_select="fft mdct"
+nellymoser_encoder_select="fft mdct"
+png_decoder_select="zlib"
+png_encoder_select="zlib"
+qdm2_decoder_select="fft mdct rdft"
+rv10_decoder_select="h263_decoder"
+rv10_encoder_select="h263_encoder"
+rv20_decoder_select="h263_decoder"
+rv20_encoder_select="h263_encoder"
+rv30_decoder_select="golomb"
+rv40_decoder_select="golomb"
+shorten_decoder_select="golomb"
+sonic_decoder_select="golomb"
+sonic_encoder_select="golomb"
+sonic_ls_encoder_select="golomb"
+svq3_decoder_select="golomb"
+svq3_decoder_suggest="zlib"
+theora_decoder_select="vp3_decoder"
+tiff_decoder_suggest="zlib"
+tiff_encoder_suggest="zlib"
+truehd_decoder_select="mlp_decoder"
+tscc_decoder_select="zlib"
+vc1_decoder_select="h263_decoder"
+vc1_dxva2_hwaccel_deps="dxva2api_h DXVA_PictureParameters_wDecodedPictureIndex"
+vc1_dxva2_hwaccel_select="dxva2 vc1_decoder"
+vc1_vaapi_hwaccel_deps="va_va_h"
+vc1_vaapi_hwaccel_select="vaapi vc1_decoder"
+vc1_vdpau_decoder_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
+vc1_vdpau_decoder_select="vdpau vc1_decoder"
+vorbis_decoder_select="fft mdct"
+vorbis_encoder_select="fft mdct"
+vp6a_decoder_select="vp6_decoder"
+vp6f_decoder_select="vp6_decoder"
+wmav1_decoder_select="fft mdct"
+wmav1_encoder_select="fft mdct"
+wmav2_decoder_select="fft mdct"
+wmav2_encoder_select="fft mdct"
+wmv1_decoder_select="h263_decoder"
+wmv1_encoder_select="h263_encoder"
+wmv2_decoder_select="h263_decoder"
+wmv2_encoder_select="h263_encoder"
+wmv3_decoder_select="vc1_decoder"
+wmv3_dxva2_hwaccel_select="vc1_dxva2_hwaccel"
+wmv3_vaapi_hwaccel_select="vc1_vaapi_hwaccel"
+wmv3_vdpau_decoder_select="vc1_vdpau_decoder"
+zlib_decoder_select="zlib"
+zlib_encoder_select="zlib"
+zmbv_decoder_select="zlib"
+zmbv_encoder_select="zlib"
+
+# parsers
+h264_parser_select="golomb"
+
+# bitstream_filters
+aac_adtstoasc_bsf_select="aac_parser"
+
+# external libraries
+libdirac_decoder_deps="libdirac !libschroedinger"
+libdirac_encoder_deps="libdirac"
+libfaac_encoder_deps="libfaac"
+libfaad_decoder_deps="libfaad"
+libfaadbin_decoder_extralibs='$ldl'
+libgsm_decoder_deps="libgsm"
+libgsm_encoder_deps="libgsm"
+libgsm_ms_decoder_deps="libgsm"
+libgsm_ms_encoder_deps="libgsm"
+libmp3lame_encoder_deps="libmp3lame"
+libopencore_amrnb_decoder_deps="libopencore_amrnb"
+libopencore_amrnb_encoder_deps="libopencore_amrnb"
+libopencore_amrwb_decoder_deps="libopencore_amrwb"
+libopenjpeg_decoder_deps="libopenjpeg"
+libschroedinger_decoder_deps="libschroedinger"
+libschroedinger_encoder_deps="libschroedinger"
+libspeex_decoder_deps="libspeex"
+libtheora_encoder_deps="libtheora"
+libvorbis_encoder_deps="libvorbis"
+libx264_encoder_deps="libx264"
+libxvid_encoder_deps="libxvid"
+
+# demuxers / muxers
+ac3_demuxer_deps="ac3_parser"
+asf_stream_muxer_select="asf_muxer"
+avisynth_demuxer_deps="avisynth"
+dirac_demuxer_deps="dirac_parser"
+eac3_demuxer_select="ac3_parser"
+ipod_muxer_select="mov_muxer"
+libnut_demuxer_deps="libnut"
+libnut_muxer_deps="libnut"
+matroska_audio_muxer_select="matroska_muxer"
+matroska_demuxer_suggest="zlib bzlib"
+mov_demuxer_suggest="zlib"
+mp3_demuxer_deps="mpegaudio_parser"
+mp4_muxer_select="mov_muxer"
+mpegtsraw_demuxer_select="mpegts_demuxer"
+mxf_d10_muxer_select="mxf_muxer"
+ogg_demuxer_select="golomb"
+psp_muxer_select="mov_muxer"
+rtsp_demuxer_deps="sdp_demuxer"
+sdp_demuxer_deps="rtp_protocol mpegts_demuxer"
+spdif_muxer_select="aac_parser"
+tg2_muxer_select="mov_muxer"
+tgp_muxer_select="mov_muxer"
+w64_demuxer_deps="wav_demuxer"
+
+# indevs / outdevs
+alsa_indev_deps="alsa_asoundlib_h snd_pcm_htimestamp"
+alsa_indev_extralibs="-lasound"
+alsa_outdev_deps="alsa_asoundlib_h"
+alsa_outdev_extralibs="-lasound"
+audio_beos_indev_deps="audio_beos"
+audio_beos_indev_extralibs="-lmedia -lbe"
+audio_beos_outdev_deps="audio_beos"
+audio_beos_outdev_extralibs="-lmedia -lbe"
+bktr_indev_deps_any="dev_bktr_ioctl_bt848_h machine_ioctl_bt848_h dev_video_bktr_ioctl_bt848_h dev_ic_bt8xx_h"
+dv1394_indev_deps="dv1394 dv_demuxer"
+jack_indev_deps="jack_jack_h"
+jack_indev_extralibs="-ljack"
+libdc1394_indev_deps="libdc1394"
+oss_indev_deps_any="soundcard_h sys_soundcard_h"
+oss_outdev_deps_any="soundcard_h sys_soundcard_h"
+v4l_indev_deps="linux_videodev_h"
+v4l2_indev_deps_any="linux_videodev2_h sys_videoio_h"
+vfwcap_indev_deps="capCreateCaptureWindow"
+vfwcap_indev_extralibs="-lavicap32"
+x11_grab_device_indev_deps="x11grab XShmCreateImage"
+x11_grab_device_indev_extralibs="-lX11 -lXext -lXfixes"
+
+# protocols
+gopher_protocol_deps="network"
+http_protocol_deps="network"
+rtmp_protocol_deps="tcp_protocol"
+rtp_protocol_deps="udp_protocol"
+tcp_protocol_deps="network"
+udp_protocol_deps="network"
+
+# filters
+movie_filter_deps="avfilter_lavf"
+avfilter_lavf_deps="avformat"
+
+# libraries
+avdevice_deps="avcodec avformat"
+avformat_deps="avcodec"
+
+# programs
+ffmpeg_deps="avcodec avformat swscale"
+ffplay_deps="avcodec avformat swscale sdl"
+ffserver_deps="avformat ffm_muxer rtp_protocol rtsp_demuxer"
+ffserver_extralibs='$ldl'
+
+doc_deps="texi2html"
+
+# default parameters
+
+logfile="config.err"
+
+# installation paths
+prefix_default="/usr/local"
+bindir_default='${prefix}/bin'
+datadir_default='${prefix}/share/ffmpeg'
+incdir_default='${prefix}/include'
+libdir_default='${prefix}/lib'
+mandir_default='${prefix}/share/man'
+shlibdir_default="$libdir_default"
+
+# toolchain
+ar="ar"
+cc_default="gcc"
+cc_version=\"unknown\"
+host_cc_default="gcc"
+ln_s="ln -sf"
+nm_default="nm"
+objformat="elf"
+ranlib="ranlib"
+strip="strip"
+yasmexe="yasm"
+
+nm_opts='-g'
+
+# machine
+arch=$(uname -m)
+cpu="generic"
+
+# OS
+target_os=$(tolower $(uname -s))
+host_os=$target_os
+
+# configurable options
+enable avcodec
+enable avdevice
+enable avformat
+enable avutil
+enable asm
+enable debug
+enable doc
+enable fastdiv
+enable ffmpeg
+enable ffplay
+enable ffserver
+enable mpegaudio_hp
+enable network
+enable optimizations
+enable protocols
+enable static
+enable stripping
+enable swscale
+enable swscale_alpha
+
+# build settings
+SHFLAGS='-shared -Wl,-soname,$$(@F)'
+FFSERVERLDFLAGS=-Wl,-E
+LIBPREF="lib"
+LIBSUF=".a"
+FULLNAME='$(NAME)$(BUILDSUF)'
+LIBNAME='$(LIBPREF)$(FULLNAME)$(LIBSUF)'
+SLIBPREF="lib"
+SLIBSUF=".so"
+SLIBNAME='$(SLIBPREF)$(FULLNAME)$(SLIBSUF)'
+SLIBNAME_WITH_VERSION='$(SLIBNAME).$(LIBVERSION)'
+SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'
+LIB_INSTALL_EXTRA_CMD='$(RANLIB) "$(LIBDIR)/$(LIBNAME)"'
+
+CC_O='-o $@'
+
+host_cflags='-D_ISOC99_SOURCE -D_POSIX_C_SOURCE=200112 -O3 -g -Wall'
+host_libs='-lm'
+
+target_path='$(CURDIR)'
+
+# gcc stupidly only outputs the basename of targets with -MM, but we need the
+# full relative path for objects in subdirectories for non-recursive Make.
+DEPEND_CMD='$(DEPCC) $(DEPFLAGS) $< | sed -e "/^\#.*/d" -e "s,^[[:space:]]*$(*F)\\.o,$(@D)/$(*F).o," > $(@:.o=.d)'
+DEPFLAGS='$(CPPFLAGS) $(CFLAGS) -MM'
+
+# find source path
+source_path="$(dirname "$0")"
+enable source_path_used
+if test -f configure; then
+    source_path="$(pwd)"
+    disable source_path_used
+else
+    source_path="$(cd "$source_path"; pwd)"
+    echo "$source_path" | grep -q '[[:blank:]]' &&
+        die "Out of tree builds are impossible with whitespace in source path."
+    test -e "$source_path/config.h" &&
+        die "Out of tree builds are impossible with config.h in source dir."
+fi
+
+for v in "$@"; do
+    r=${v#*=}
+    l=${v%"$r"}
+    r=$(sh_quote "$r")
+    FFMPEG_CONFIGURATION="${FFMPEG_CONFIGURATION# } ${l}${r}"
+done
+
+find_things(){
+    thing=$1
+    pattern=$2
+    file=$source_path/$3
+    sed -n "s/^[^#]*$pattern.*([^,]*, *\([^,]*\)\(,.*\)*).*/\1_$thing/p" "$file"
+}
+
+ENCODER_LIST=$(find_things  encoder  ENC      libavcodec/allcodecs.c)
+DECODER_LIST=$(find_things  decoder  DEC      libavcodec/allcodecs.c)
+HWACCEL_LIST=$(find_things  hwaccel  HWACCEL  libavcodec/allcodecs.c)
+PARSER_LIST=$(find_things   parser   PARSER   libavcodec/allcodecs.c)
+BSF_LIST=$(find_things      bsf      BSF      libavcodec/allcodecs.c)
+MUXER_LIST=$(find_things    muxer    _MUX     libavformat/allformats.c)
+DEMUXER_LIST=$(find_things  demuxer  DEMUX    libavformat/allformats.c)
+OUTDEV_LIST=$(find_things   outdev   OUTDEV   libavdevice/alldevices.c)
+INDEV_LIST=$(find_things    indev    _IN      libavdevice/alldevices.c)
+PROTOCOL_LIST=$(find_things protocol PROTOCOL libavformat/allformats.c)
+FILTER_LIST=$(find_things   filter   FILTER   libavfilter/allfilters.c)
+
+enable $ARCH_EXT_LIST \
+       $DECODER_LIST \
+       $ENCODER_LIST \
+       $HWACCEL_LIST \
+       $PARSER_LIST \
+       $BSF_LIST \
+       $DEMUXER_LIST \
+       $MUXER_LIST \
+       $FILTER_LIST \
+       $PROTOCOL_LIST \
+       $INDEV_LIST \
+       $OUTDEV_LIST \
+
+die_unknown(){
+    echo "Unknown option \"$1\"."
+    echo "See $0 --help for available options."
+    exit 1
+}
+
+show_list() {
+    suffix=_$1
+    shift
+    echo $* | sed s/$suffix//g | tr ' ' '\n' | sort | pr -3 -t
+    exit 0
+}
+
+for opt do
+    optval="${opt#*=}"
+    case "$opt" in
+    --extra-ldflags=*) add_ldflags $optval
+    ;;
+    --extra-libs=*) add_extralibs $optval
+    ;;
+    --disable-devices) disable $INDEV_LIST $OUTDEV_LIST
+    ;;
+    --enable-debug=*) debuglevel="$optval"
+    ;;
+    --enable-*=*|--disable-*=*)
+    eval $(echo "${opt%%=*}" | sed 's/--/action=/;s/-/ thing=/')
+    is_in "${thing}s" $COMPONENT_LIST || die_unknown "$opt"
+    eval list=\$$(toupper $thing)_LIST
+    name=$(echo "${optval}" | sed "s/,/_${thing}|/g")_${thing}
+    $action $(filter "$name" $list)
+    ;;
+    --enable-?*|--disable-?*)
+    eval $(echo "$opt" | sed 's/--/action=/;s/-/ option=/;s/-/_/g')
+    if is_in $option $COMPONENT_LIST; then
+        test $action = disable && action=unset
+        eval $action \$$(toupper ${option%s})_LIST
+    elif is_in $option $CMDLINE_SELECT; then
+        $action $option
+    else
+        die_unknown $opt
+    fi
+    ;;
+    --list-*)
+        NAME="${opt#--list-}"
+        is_in $NAME $COMPONENT_LIST || die_unknown $opt
+        NAME=${NAME%s}
+        eval show_list $NAME \$$(toupper $NAME)_LIST
+    ;;
+    --help|-h) show_help
+    ;;
+    *)
+    optname="${opt%%=*}"
+    optname="${optname#--}"
+    optname=$(echo "$optname" | sed 's/-/_/g')
+    if is_in $optname $CMDLINE_SET; then
+        eval $optname='$optval'
+    elif is_in $optname $CMDLINE_APPEND; then
+        append $optname "$optval"
+    else
+         die_unknown $opt
+    fi
+    ;;
+    esac
+done
+
+disabled logging && logfile=/dev/null
+
+echo "# $0 $FFMPEG_CONFIGURATION" > $logfile
+set >> $logfile
+
+test -n "$cross_prefix" && enable cross_compile
+
+ar="${cross_prefix}${ar}"
+cc_default="${cross_prefix}${cc_default}"
+nm_default="${cross_prefix}${nm_default}"
+ranlib="${cross_prefix}${ranlib}"
+strip="${cross_prefix}${strip}"
+
+sysinclude_default="${sysroot}/usr/include"
+
+set_default cc nm sysinclude
+enabled cross_compile || host_cc_default=$cc
+set_default host_cc
+
+exesuf() {
+    case $1 in
+        mingw32*|cygwin*|*-dos|freedos|opendos|os/2*) echo .exe ;;
+    esac
+}
+
+EXESUF=$(exesuf $target_os)
+HOSTEXESUF=$(exesuf $host_os)
+
+# set temporary file name
+: ${TMPDIR:=$TEMPDIR}
+: ${TMPDIR:=$TMP}
+: ${TMPDIR:=/tmp}
+
+if ! check_cmd type mktemp; then
+    # simple replacement for missing mktemp
+    # NOT SAFE FOR GENERAL USE
+    mktemp(){
+        echo "${2%XXX*}.${HOSTNAME}.${UID}.$$"
+    }
+fi
+
+tmpfile(){
+    tmp=$(mktemp -u "${TMPDIR}/ffconf.XXXXXXXX")$2 &&
+        (set -C; exec > $tmp) 2>/dev/null ||
+        die "Unable to create temporary file in $TMPDIR."
+    append TMPFILES $tmp
+    eval $1=$tmp
+}
+
+trap 'rm -f -- $TMPFILES' EXIT
+trap exit HUP INT TERM
+
+tmpfile TMPC  .c
+tmpfile TMPE  $EXESUF
+tmpfile TMPH  .h
+tmpfile TMPO  .o
+tmpfile TMPS  .S
+tmpfile TMPV  .ver
+tmpfile TMPSH .sh
+
+unset -f mktemp
+
+# make sure we can execute files in $TMPDIR
+cat > $TMPSH 2>> $logfile <<EOF
+#! /bin/sh
+EOF
+chmod +x $TMPSH >> $logfile 2>&1
+if ! $TMPSH >> $logfile 2>&1; then
+    cat <<EOF
+Unable to create and execute files in $TMPDIR.  Set the TMPDIR environment
+variable to another directory and make sure that it is not mounted noexec.
+EOF
+    die "Sanity test failed."
+fi
+
+filter_cflags=echo
+filter_cppflags=echo
+filter_asflags=echo
+
+if   $cc -v 2>&1 | grep -qi ^gcc; then
+    cc_type=gcc
+    cc_version=__VERSION__
+    if ! $cc -dumpversion | grep -q '^2\.'; then
+        CC_DEPFLAGS='-MMD -MF $(@:.o=.d) -MT $@'
+        AS_DEPFLAGS='-MMD -MF $(@:.o=.d) -MT $@'
+    fi
+    speed_cflags='-O3'
+    size_cflags='-Os'
+elif $cc --version 2>/dev/null | grep -q Intel; then
+    cc_type=icc
+    cc_version="AV_STRINGIFY(__INTEL_COMPILER)"
+    CC_DEPFLAGS='-MMD'
+    AS_DEPFLAGS='-MMD'
+    speed_cflags='-O3'
+    size_cflags='-Os'
+elif $cc -v 2>&1 | grep -q xlc; then
+    cc_type=xlc
+    cc_version="AV_STRINGIFY(__IBMC__)"
+    speed_cflags='-O5'
+    size_cflags='-O5 -qcompact'
+elif $cc -V 2>/dev/null | grep -q Compaq; then
+    cc_type=ccc
+    cc_version="AV_STRINGIFY(__DECC_VER)"
+    DEPFLAGS='$(CPPFLAGS) $(CFLAGS) -M'
+    debuglevel=3
+    add_ldflags -Wl,-z,now # calls to libots crash without this
+    speed_cflags='-fast'
+    size_cflags='-O1'
+elif $cc --vsn 2>/dev/null | grep -q "ARM C/C++ Compiler"; then
+    test -d "$sysroot" || die "No valid sysroot specified."
+    cc_type=armcc
+    cc_version="AV_STRINGIFY(__ARMCC_VERSION)"
+    armcc_conf="$PWD/armcc.conf"
+    $cc --arm_linux_configure                 \
+        --arm_linux_config_file="$armcc_conf" \
+        --configure_sysroot="$sysroot"        \
+        --configure_cpp_headers="$sysinclude" >>$logfile 2>&1 ||
+        die "Error creating armcc configuration file."
+    cc="$cc --arm_linux_config_file=$armcc_conf --translate_gcc"
+    as_default="${cross_prefix}gcc"
+    CC_DEPFLAGS='-MMD'
+    AS_DEPFLAGS='-MMD'
+    speed_cflags='-O3'
+    size_cflags='-Os'
+elif $cc -version 2>/dev/null | grep -q TMS470; then
+    cc_type=tms470
+    cc_version="AV_STRINGIFY(__TI_COMPILER_VERSION__)"
+    cc="$cc --gcc --abi=eabi -eo=.o -mc -me"
+    CC_O='-fr=$(@D)'
+    as_default="${cross_prefix}gcc"
+    ld_default="${cross_prefix}gcc"
+    TMPO=$(basename $TMPC .c).o
+    append TMPFILES $TMPO
+    add_cflags -D__gnuc_va_list=va_list -D__USER_LABEL_PREFIX__=
+    CC_DEPFLAGS='-ppa -ppd=$(@:.o=.d)'
+    AS_DEPFLAGS='-MMD'
+    speed_cflags='-O3 -mf=5'
+    size_cflags='-O3 -mf=2'
+    filter_cflags=tms470_flags
+    tms470_flags(){
+        for flag; do
+            case $flag in
+                -march=*|-mcpu=*)
+                    case "${flag#*=}" in
+                        armv7-a|cortex-a*)      echo -mv=7a8 ;;
+                        armv7-r|cortex-r*)      echo -mv=7r4 ;;
+                        armv7-m|cortex-m*)      echo -mv=7m3 ;;
+                        armv6*|arm11*)          echo -mv=6   ;;
+                        armv5*e|arm[79]*e*|arm9[24]6*|arm96*|arm102[26])
+                                                echo -mv=5e  ;;
+                        armv4*|arm7*|arm9[24]*) echo -mv=4   ;;
+                    esac
+                    ;;
+                -mfpu=neon)     echo --float_support=vfpv3 --neon ;;
+                -mfpu=vfp)      echo --float_support=vfpv2        ;;
+                -mfpu=vfpv3)    echo --float_support=vfpv3        ;;
+                -msoft-float)   echo --float_support=vfplib       ;;
+                -O[0-3]|-mf=*)  echo $flag                        ;;
+                -g)             echo -g -mn                       ;;
+                -pds=*)         echo $flag                        ;;
+            esac
+        done
+    }
+elif $cc -v 2>&1 | grep -q clang; then
+    cc_type=clang
+    cc_version=__VERSION__
+    CC_DEPFLAGS='-MMD'
+    AS_DEPFLAGS='-MMD'
+    speed_cflags='-O3'
+    size_cflags='-Os'
+elif $cc -V 2>&1 | grep -q Sun; then
+    cc_type=suncc
+    cc_version="AV_STRINGIFY(__SUNPRO_C)"
+    DEPEND_CMD='$(DEPCC) $(DEPFLAGS) $< | sed -e "1s,^.*: ,$@: ," -e "\$$!s,\$$, \\\," -e "1!s,^.*: , ," > $(@:.o=.d)'
+    DEPFLAGS='$(CPPFLAGS) $(CFLAGS) -xM1'
+    speed_cflags='-O5'
+    size_cflags='-O5 -xspace'
+    filter_cflags=suncc_flags
+    suncc_flags(){
+        for flag; do
+            case $flag in
+                -march=*|-mcpu=*)
+                    case "${flag#*=}" in
+                        native)                   echo -xtarget=native       ;;
+                        v9)                       echo -xarch=sparc          ;;
+                        ultrasparc)               echo -xarch=sparcvis       ;;
+                        ultrasparc3|niagara*)     echo -xarch=sparcvis2      ;;
+                        i586|pentium)             echo -xchip=pentium        ;;
+                        i686|pentiumpro|pentium2) echo -xtarget=pentium_pro  ;;
+                        pentium3*|c3-2)           echo -xtarget=pentium3     ;;
+                        pentium-m)          echo -xarch=sse2 -xchip=pentium3 ;;
+                        pentium4*)          echo -xtarget=pentium4           ;;
+                        prescott|nocona)    echo -xarch=sse3 -xchip=pentium4 ;;
+                        *-sse3)             echo -xarch=sse3                 ;;
+                        core2)              echo -xarch=ssse3 -xchip=core2   ;;
+                        amdfam10|barcelona)       echo -xarch=sse4_1         ;;
+                        athlon-4|athlon-[mx]p)    echo -xarch=ssea           ;;
+                        k8|opteron|athlon64|athlon-fx)
+                                                  echo -xarch=sse2a          ;;
+                        athlon*)                  echo -xarch=pentium_proa   ;;
+                    esac
+                    ;;
+                -std=c99)             echo -xc99              ;;
+                -fomit-frame-pointer) echo -xregs=frameptr    ;;
+                -fPIC)                echo -KPIC -xcode=pic32 ;;
+                -W*,*)                echo $flag              ;;
+                -f*-*|-W*)                                    ;;
+                *)                    echo $flag              ;;
+            esac
+        done
+    }
+fi
+
+test -n "$cc_type" && enable $cc_type || echolog "Unknown C compiler $cc"
+
+: ${as_default:=$cc}
+: ${dep_cc_default:=$cc}
+: ${ld_default:=$cc}
+set_default as dep_cc ld
+
+test -n "$CC_DEPFLAGS" || CCDEP=$DEPEND_CMD
+test -n "$AS_DEPFLAGS" || ASDEP=$DEPEND_CMD
+
+add_cflags $extra_cflags
+add_asflags $extra_cflags
+
+if test -n "$sysroot"; then
+    case "$cc_type" in
+        gcc)
+            add_cppflags --sysroot="$sysroot"
+            add_ldflags --sysroot="$sysroot"
+        ;;
+        tms470)
+            add_cppflags -I"$sysinclude"
+            add_ldflags  --sysroot="$sysroot"
+        ;;
+        clang)
+            add_cppflags -isysroot="$sysroot"
+            add_ldflags -isysroot="$sysroot"
+        ;;
+    esac
+fi
+
+if test "$cpu" = host; then
+    enabled cross_compile && die "--cpu=host makes no sense when cross-compiling."
+
+    case "$cc_type" in
+        gcc)
+            check_native(){
+                $cc $1=native -v -c -o $TMPO $TMPC >$TMPE 2>&1 || return
+                sed -n "/$1=/{
+                            s/.*$1=\\([^ ]*\\).*/\\1/
+                            p
+                            q
+                        }" $TMPE
+            }
+            cpu=$(check_native -march || check_native -mcpu)
+        ;;
+    esac
+
+    test "${cpu:-host}" = host && die "--cpu=host not supported with compiler $cc"
+fi
+
+# Deal with common $arch aliases
+case "$arch" in
+    arm*)
+        arch="arm"
+    ;;
+    mips|mipsel|IP*)
+        arch="mips"
+    ;;
+    mips64)
+        arch="mips"
+        subarch="mips64"
+    ;;
+    parisc|hppa)
+        arch="parisc"
+    ;;
+    parisc64|hppa64)
+        arch="parisc"
+        subarch="parisc64"
+    ;;
+    "Power Macintosh"|ppc|powerpc)
+        arch="ppc"
+    ;;
+    ppc64)
+        arch="ppc"
+        subarch="ppc64"
+    ;;
+    s390|s390x)
+        arch="s390"
+    ;;
+    sh4|sh)
+        arch="sh4"
+    ;;
+    sun4u|sparc64)
+        arch="sparc"
+        subarch="sparc64"
+    ;;
+    i[3-6]86|i86pc|BePC|x86_64|amd64)
+        arch="x86"
+    ;;
+esac
+
+is_in $arch $ARCH_LIST || echo "WARNING: unknown arch $arch"
+enable $arch
+
+# Add processor-specific flags
+if test "$cpu" = generic; then
+    : do nothing
+elif enabled ppc; then
+
+    case $(tolower $cpu) in
+        601|ppc601|powerpc601)
+            cpuflags="-mcpu=601"
+            disable altivec
+        ;;
+        603*|ppc603*|powerpc603*)
+            cpuflags="-mcpu=603"
+            disable altivec
+        ;;
+        604*|ppc604*|powerpc604*)
+            cpuflags="-mcpu=604"
+            disable altivec
+        ;;
+        g3|75*|ppc75*|powerpc75*)
+            cpuflags="-mcpu=750 -mpowerpc-gfxopt"
+            disable altivec
+        ;;
+        g4|745*|ppc745*|powerpc745*)
+            cpuflags="-mcpu=7450 -mpowerpc-gfxopt"
+        ;;
+        74*|ppc74*|powerpc74*)
+            cpuflags="-mcpu=7400 -mpowerpc-gfxopt"
+        ;;
+        g5|970|ppc970|powerpc970|power4*)
+            cpuflags="-mcpu=970 -mpowerpc-gfxopt -mpowerpc64"
+        ;;
+        cell)
+            cpuflags="-mcpu=cell"
+            enable ldbrx
+        ;;
+        e500v2)
+            cpuflags="-mcpu=8548 -mhard-float -mfloat-gprs=double"
+            disable altivec
+        ;;
+        e500)
+            cpuflags="-mcpu=8540 -mhard-float"
+            disable altivec
+        ;;
+    esac
+
+elif enabled x86; then
+
+    case $cpu in
+        i[345]86|pentium)
+            cpuflags="-march=$cpu"
+            disable mmx
+        ;;
+        # targets that do NOT support conditional mov (cmov)
+        pentium-mmx|k6|k6-[23]|winchip-c6|winchip2|c3)
+            cpuflags="-march=$cpu"
+            disable cmov
+        ;;
+        # targets that do support conditional mov (cmov)
+        i686|pentiumpro|pentium[23]|pentium-m|athlon|athlon-tbird|athlon-4|athlon-[mx]p|athlon64|k8|opteron|athlon-fx|core2|amdfam10)
+            cpuflags="-march=$cpu"
+            enable cmov
+            enable fast_cmov
+        ;;
+        # targets that do support conditional mov but on which it's slow
+        pentium4|pentium4m|prescott|nocona)
+            cpuflags="-march=$cpu"
+            enable cmov
+            disable fast_cmov
+        ;;
+    esac
+
+elif enabled sparc; then
+
+    case $cpu in
+        sparc64)
+            cpuflags="-mcpu=v9"
+        ;;
+    esac
+
+elif enabled arm; then
+
+    case $cpu in
+        armv*)
+            cpuflags="-march=$cpu"
+        ;;
+        *)
+            cpuflags="-mcpu=$cpu"
+        ;;
+    esac
+
+elif enabled alpha; then
+
+    enabled ccc && cpuflags="-arch $cpu" || cpuflags="-mcpu=$cpu"
+
+elif enabled bfin; then
+
+    cpuflags="-mcpu=$cpu"
+
+elif enabled mips; then
+
+    cpuflags="-march=$cpu"
+
+elif enabled avr32; then
+
+    case $cpu in
+        ap7[02]0[0-2])
+            subarch="avr32_ap"
+            cpuflags="-mpart=$cpu"
+        ;;
+        ap)
+            subarch="avr32_ap"
+            cpuflags="-march=$cpu"
+        ;;
+        uc3[ab]*)
+            subarch="avr32_uc"
+            cpuflags="-mcpu=$cpu"
+        ;;
+        uc)
+            subarch="avr32_uc"
+            cpuflags="-march=$cpu"
+        ;;
+    esac
+
+fi
+
+add_cflags $cpuflags
+add_asflags $cpuflags
+
+# compiler sanity check
+check_exec <<EOF
+int main(void){ return 0; }
+EOF
+if test "$?" != 0; then
+    echo "$cc is unable to create an executable file."
+    if test -z "$cross_prefix" && ! enabled cross_compile ; then
+        echo "If $cc is a cross-compiler, use the --enable-cross-compile option."
+        echo "Only do this if you know what cross compiling means."
+    fi
+    die "C compiler test failed."
+fi
+
+add_cppflags -D_ISOC99_SOURCE -D_POSIX_C_SOURCE=200112
+check_cflags -std=c99
+check_cc -D_FILE_OFFSET_BITS=64 <<EOF && add_cppflags -D_FILE_OFFSET_BITS=64
+#include <stdlib.h>
+EOF
+check_cc -D_LARGEFILE_SOURCE <<EOF && add_cppflags -D_LARGEFILE_SOURCE
+#include <stdlib.h>
+EOF
+
+check_host_cflags -std=c99
+
+case "$arch" in
+    alpha|ia64|mips|parisc|sparc)
+        spic=$shared
+    ;;
+    x86)
+        subarch="x86_32"
+        check_cc <<EOF && subarch="x86_64"
+        int test[(int)sizeof(char*) - 7];
+EOF
+        if test "$subarch" = "x86_64"; then
+            spic=$shared
+        fi
+    ;;
+esac
+
+enable $subarch
+enabled spic && enable pic
+check_cpp_condition stdlib.h "defined(__PIC__) || defined(__pic__) || defined(PIC)" && enable pic
+
+# OS specific
+case $target_os in
+    beos|haiku|zeta)
+        prefix_default="$HOME/config"
+        # 3 gcc releases known for BeOS, each with ugly bugs
+        gcc_version="$($cc -v 2>&1 | grep version | cut -d ' ' -f3-)"
+        case "$gcc_version" in
+          2.9-beos-991026*|2.9-beos-000224*) echo "R5/GG gcc"
+            disable mmx
+            ;;
+          *20010315*) echo "BeBits gcc"
+            add_cflags -fno-expensive-optimizations
+            ;;
+        esac
+        SHFLAGS=-nostart
+        # enable BeOS things
+        enable audio_beos
+        # no need for libm, but the inet stuff
+        # Check for BONE
+        # XXX: actually should check for NOT net_server
+        if echo $BEINCLUDES | grep -q 'headers/be/bone'; then
+            network_extralibs="-lbind -lsocket"
+        else
+            enable beos_netserver
+            network_extralibs="-lnet"
+        fi ;;
+    sunos)
+        FFSERVERLDFLAGS=""
+        SHFLAGS='-shared -Wl,-h,$$(@F)'
+        enabled x86 && SHFLAGS="-mimpure-text $SHFLAGS"
+        network_extralibs="-lsocket -lnsl"
+        add_cppflags -D__EXTENSIONS__
+        nm_opts='-P -g'
+        ;;
+    netbsd)
+        oss_indev_extralibs="-lossaudio"
+        oss_outdev_extralibs="-lossaudio"
+        ;;
+    openbsd)
+        enable malloc_aligned
+        # On OpenBSD 4.5. the compiler does not use PIC unless
+        # explicitly using -fPIC. FFmpeg builds fine without PIC,
+        # however the generated executable will not do anything
+        # (simply quits with exit-code 1, no crash, no output).
+        # Thus explicitly enable PIC here.
+        enable pic
+        SHFLAGS='-shared'
+        oss_indev_extralibs="-lossaudio"
+        oss_outdev_extralibs="-lossaudio"
+        ;;
+    freebsd|dragonfly)
+        enable malloc_aligned
+        ;;
+    bsd/os)
+        osextralibs="-lpoll -lgnugetopt"
+        strip="strip -d"
+        ;;
+    darwin)
+        enable malloc_aligned
+        SHFLAGS='-dynamiclib -Wl,-single_module -Wl,-install_name,$(SHLIBDIR)/$(SLIBNAME),-current_version,$(LIBVERSION),-compatibility_version,$(LIBMAJOR) -Wl,-read_only_relocs,suppress'
+        strip="strip -x"
+        FFLDFLAGS="-Wl,-dynamic,-search_paths_first"
+        SLIBSUF=".dylib"
+        SLIBNAME_WITH_VERSION='$(SLIBPREF)$(FULLNAME).$(LIBVERSION)$(SLIBSUF)'
+        SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME).$(LIBMAJOR)$(SLIBSUF)'
+        FFSERVERLDFLAGS=-Wl,-bind_at_load
+        objformat="macho"
+        enabled x86_64 && objformat="macho64"
+        enabled_any pic shared ||
+            { check_cflags -mdynamic-no-pic && add_asflags -mdynamic-no-pic; }
+        ;;
+    mingw32*)
+        if test $target_os = "mingw32ce"; then
+            disable network
+        else
+            target_os=mingw32
+        fi
+        LIBTARGET=i386
+        if enabled x86_64; then
+            enable malloc_aligned
+            LIBTARGET=x64
+        elif enabled arm; then
+            LIBTARGET=arm
+        fi
+        shlibdir_default="$bindir_default"
+        disable ffserver
+        SLIBPREF=""
+        SLIBSUF=".dll"
+        SLIBNAME_WITH_VERSION='$(SLIBPREF)$(FULLNAME)-$(LIBVERSION)$(SLIBSUF)'
+        SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'
+        SLIB_EXTRA_CMD='-lib.exe /machine:$(LIBTARGET) /def:$$(@:$(SLIBSUF)=.def) /out:$(SUBDIR)$(SLIBNAME_WITH_MAJOR:$(SLIBSUF)=.lib)'
+        SLIB_INSTALL_EXTRA_CMD='-install -m 644 $(SUBDIR)$(SLIBNAME_WITH_MAJOR:$(SLIBSUF)=.lib) "$(SHLIBDIR)/$(SLIBNAME:$(SLIBSUF)=.lib)"; \
+            install -m 644 $(SUBDIR)$(SLIBNAME_WITH_MAJOR:$(SLIBSUF)=.lib) "$(SHLIBDIR)/$(SLIBNAME_WITH_MAJOR:$(SLIBSUF)=.lib)"; \
+            install -d "$(LIBDIR)"; \
+            install -m 644 $(SUBDIR)lib$(SLIBNAME:$(SLIBSUF)=.dll.a) "$(LIBDIR)/lib$(SLIBNAME:$(SLIBSUF)=.dll.a)"'
+        SLIB_UNINSTALL_EXTRA_CMD='rm -f "$(SHLIBDIR)/$(SLIBNAME:$(SLIBSUF)=.lib)"'
+        SHFLAGS='-shared -Wl,--output-def,$$(@:$(SLIBSUF)=.def) -Wl,--out-implib,$(SUBDIR)lib$(SLIBNAME:$(SLIBSUF)=.dll.a) -Wl,--enable-runtime-pseudo-reloc -Wl,--enable-auto-image-base'
+        objformat="win32"
+        enable dos_paths
+        check_cflags -fno-common
+        if ! enabled x86_64; then
+            check_cpp_condition _mingw.h "(__MINGW32_MAJOR_VERSION > 3) || (__MINGW32_MAJOR_VERSION == 3 && __MINGW32_MINOR_VERSION >= 15)" ||
+                die "ERROR: MinGW runtime version must be >= 3.15."
+            enabled_any avisynth vfwcap_indev &&
+                { check_cpp_condition w32api.h "(__W32API_MAJOR_VERSION > 3) || (__W32API_MAJOR_VERSION == 3 && __W32API_MINOR_VERSION >= 13)" ||
+                  die "ERROR: avisynth and vfwcap_indev require w32api version 3.13 or later."; }
+        fi
+        ;;
+    cygwin*)
+        target_os=cygwin
+        shlibdir_default="$bindir_default"
+        SLIBPREF="cyg"
+        SLIBSUF=".dll"
+        SLIBNAME_WITH_VERSION='$(SLIBPREF)$(FULLNAME)-$(LIBVERSION)$(SLIBSUF)'
+        SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'
+        SHFLAGS='-shared -Wl,--enable-auto-image-base'
+        objformat="win32"
+        enable dos_paths
+        check_cflags -fno-common
+        ;;
+    *-dos|freedos|opendos)
+        disable ffplay ffserver
+        disable $INDEV_LIST $OUTDEV_LIST
+        network_extralibs="-lsocket"
+        objformat="coff"
+        enable dos_paths
+        ;;
+    linux)
+        enable dv1394
+        ;;
+    irix*)
+        target_os=irix
+        ranlib="echo ignoring ranlib"
+        ;;
+    os/2*)
+        strip="lxlite"
+        ln_s="cp -f"
+        FFLDFLAGS="-Zomf -Zbin-files -Zargs-wild -Zmap"
+        SHFLAGS='$(SUBDIR)$(NAME).def -Zdll -Zomf'
+        FFSERVERLDFLAGS=""
+        LIBSUF="_s.a"
+        SLIBPREF=""
+        SLIBSUF=".dll"
+        SLIBNAME_WITH_VERSION='$(SLIBPREF)$(NAME)-$(LIBVERSION)$(SLIBSUF)'
+        SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(shell echo $(NAME) | cut -c1-6)$(LIBMAJOR)$(SLIBSUF)'
+        SLIB_CREATE_DEF_CMD='echo LIBRARY $(SLIBNAME_WITH_MAJOR) INITINSTANCE TERMINSTANCE > $(SUBDIR)$(NAME).def; \
+          echo PROTMODE >> $(SUBDIR)$(NAME).def; \
+          echo CODE PRELOAD MOVEABLE DISCARDABLE >> $(SUBDIR)$(NAME).def; \
+          echo DATA PRELOAD MOVEABLE MULTIPLE NONSHARED >> $(SUBDIR)$(NAME).def; \
+          echo EXPORTS >> $(SUBDIR)$(NAME).def; \
+          emxexp -o $(OBJS) >> $(SUBDIR)$(NAME).def'
+        SLIB_EXTRA_CMD='emximp -o $(SUBDIR)$(LIBPREF)$(NAME)_dll.a $(SUBDIR)$(NAME).def; \
+          emximp -o $(SUBDIR)$(LIBPREF)$(NAME)_dll.lib $(SUBDIR)$(NAME).def;'
+        SLIB_INSTALL_EXTRA_CMD='install -m 644 $(SUBDIR)$(LIBPREF)$(NAME)_dll.a $(SUBDIR)$(LIBPREF)$(NAME)_dll.lib "$(LIBDIR)"'
+        SLIB_UNINSTALL_EXTRA_CMD='rm -f "$(LIBDIR)"/$(LIBPREF)$(NAME)_dll.a "$(LIBDIR)"/$(LIBPREF)$(NAME)_dll.lib'
+        enable dos_paths
+        ;;
+    gnu/kfreebsd)
+        ;;
+    gnu)
+        ;;
+
+    *)
+        die "Unknown OS '$target_os'."
+        ;;
+esac
+
+set_default $PATHS_LIST
+
+add_extralibs $osextralibs
+
+# Combine FFLDFLAGS and the LDFLAGS environment variable.
+LDFLAGS="$FFLDFLAGS $LDFLAGS"
+
+# we need to build at least one lib type
+if ! enabled_any static shared; then
+    cat <<EOF
+At least one library type must be built.
+Specify --enable-static to build the static libraries or --enable-shared to
+build the shared libraries as well. To only build the shared libraries specify
+--disable-static in addition to --enable-shared.
+EOF
+    exit 1;
+fi
+
+disabled static && LIBNAME=""
+
+if enabled_any libfaad libfaadbin ; then
+    if check_header faad.h; then
+        check_cc <<EOF
+#include <faad.h>
+#ifndef FAAD2_VERSION
+ok faad1
+#endif
+int main(void) { return 0; }
+EOF
+        test $? = 0 && enable libfaad2
+    else
+        die "FAAD test failed."
+    fi
+fi
+
+
+die_license_disabled() {
+    enabled $1 || { enabled $2 && die "$2 is $1 and --enable-$1 is not specified."; }
+}
+
+die_license_disabled gpl libfaad2
+die_license_disabled gpl libx264
+die_license_disabled gpl libxvid
+die_license_disabled gpl postproc
+die_license_disabled gpl x11grab
+
+die_license_disabled nonfree libfaac
+
+die_license_disabled version3 libopencore_amrnb
+die_license_disabled version3 libopencore_amrwb
+
+enabled version3 && { enabled gpl && enable gplv3 || enable lgplv3; }
+
+check_deps $ARCH_EXT_LIST
+
+disabled optimizations || check_cflags -fomit-frame-pointer
+
+enable_pic() {
+    enable pic
+    add_cppflags -DPIC
+    add_cflags   -fPIC
+    add_asflags  -fPIC
+}
+
+enabled pic && enable_pic
+
+check_cc <<EOF || die "Symbol mangling check failed."
+int ff_extern;
+EOF
+sym=$($nm $nm_opts $TMPO | awk '/ff_extern/{ print substr($0, match($0, /[^ \t]*ff_extern/)) }')
+extern_prefix=${sym%%ff_extern*}
+
+check_cc <<EOF && enable inline_asm
+void foo(void) { __asm__ volatile ("" ::); }
+EOF
+
+_restrict=
+for restrict_keyword in restrict __restrict__ __restrict; do
+    check_cc <<EOF && _restrict=$restrict_keyword && break
+void foo(char * $restrict_keyword p);
+EOF
+done
+
+check_cc <<EOF && enable attribute_packed
+struct { int x; } __attribute__((packed)) x;
+EOF
+
+check_cc <<EOF && enable attribute_may_alias
+union { int x; } __attribute__((may_alias)) x;
+EOF
+
+check_cc <<EOF || die "endian test failed"
+unsigned int endian = 'B' << 24 | 'I' << 16 | 'G' << 8 | 'E';
+EOF
+od -t x1 $TMPO | grep -q '42 *49 *47 *45' && enable bigendian
+
+if enabled alpha; then
+
+    check_cflags -mieee
+
+elif enabled arm; then
+
+    check_cflags -marm
+
+    check_ld <<EOF && enable vfp_args
+__asm__ (".eabi_attribute 28, 1");
+int main(void) { return 0; }
+EOF
+
+    # We have to check if pld is a nop and disable it.
+    check_asm pld '"pld [r0]"'
+
+    enabled armv5te && check_asm armv5te '"qadd r0, r0, r0"'
+    enabled armv6   && check_asm armv6   '"sadd16 r0, r0, r0"'
+    enabled armv6t2 && check_asm armv6t2 '"movt r0, #0"'
+    enabled armvfp  && check_asm armvfp  '"fadds s0, s0, s0"'
+    enabled iwmmxt  && check_asm iwmmxt  '"wunpckelub wr6, wr4"'
+    enabled neon    && check_asm neon    '"vadd.i16 q0, q0, q0"'
+
+    enabled_all armv6t2 shared !pic && enable_pic
+
+elif enabled ia64; then
+
+    # HACK: currently fails to build if .bss is > 4MB and shared libs are built
+    enabled shared && enable_weak hardcoded_tables
+
+elif enabled mips; then
+
+    check_asm loongson '"dmult.g $1, $2, $3"'
+    enabled mmi     && check_asm mmi     '"lq $2, 0($2)"'
+
+elif enabled ppc; then
+
+    check_asm dcbzl     '"dcbzl 0, 1"'
+    check_asm ppc4xx    '"maclhw r10, r11, r12"'
+    check_asm xform_asm '"lwzx %1, %y0" :: "Z"(*(int*)0), "r"(0)'
+
+    # AltiVec flags: The FSF version of GCC differs from the Apple version
+    if enabled altivec; then
+        check_cflags -maltivec -mabi=altivec &&
+        { check_header altivec.h && inc_altivec_h="#include <altivec.h>" ; } ||
+        check_cflags -faltivec
+
+        # check if our compiler supports Motorola AltiVec C API
+        check_cc <<EOF || disable altivec
+$inc_altivec_h
+int main(void) {
+    vector signed int v1, v2, v3;
+    v1 = vec_add(v2,v3);
+    return 0;
+}
+EOF
+
+        # check if our compiler supports braces for vector declarations
+        check_cc <<EOF || die "You need a compiler that supports {} in AltiVec vector declarations."
+$inc_altivec_h
+int main (void) { (vector int) {1}; return 0; }
+EOF
+    fi
+
+elif enabled sparc; then
+
+    enabled vis && check_asm vis '"pdist %f0, %f0, %f0"' -mcpu=ultrasparc &&
+        add_cflags -mcpu=ultrasparc -mtune=ultrasparc
+
+elif enabled x86; then
+
+    # check whether EBP is available on x86
+    # As 'i' is stored on the stack, this program will crash
+    # if the base pointer is used to access it because the
+    # base pointer is cleared in the inline assembly code.
+    check_exec_crash <<EOF && enable ebp_available
+    volatile int i=0;
+    __asm__ volatile (
+        "xorl %%ebp, %%ebp"
+    ::: "%ebp");
+    return i;
+EOF
+
+    # check whether EBX is available on x86
+    check_asm ebx_available '""::"b"(0)' &&
+        check_asm ebx_available '"":::"%ebx"'
+
+    # check whether more than 10 operands are supported
+    check_cc <<EOF && enable ten_operands
+int main(void) {
+    int x=0;
+    __asm__ volatile(
+        ""
+        :"+&rm"(x), "+&rm"(x), "+&rm"(x), "+&rm"(x), "+&rm"(x), "+&rm"(x)
+    );
+    return 0;
+}
+EOF
+
+    # check whether binutils is new enough to compile SSSE3/MMX2
+    enabled ssse3 && check_asm ssse3 '"pabsw %xmm0, %xmm0"'
+    enabled mmx2  && check_asm mmx2  '"pmaxub %mm0, %mm1"'
+
+    check_asm bswap '"bswap %%eax" ::: "%eax"'
+
+    YASMFLAGS="-f $objformat -DARCH_$(toupper $subarch)"
+    enabled     x86_64        && append YASMFLAGS "-m amd64"
+    enabled     pic           && append YASMFLAGS "-DPIC"
+    test -n "$extern_prefix"  && append YASMFLAGS "-DPREFIX"
+    case "$objformat" in
+        elf) enabled debug && append YASMFLAGS "-g dwarf2" ;;
+    esac
+    disabled yasm || { check_yasm "pabsw xmm0, xmm0" && enable yasm; }
+
+    case "$cpu" in
+        athlon*|opteron*|k8*|pentium|pentium-mmx|prescott|nocona|atom|geode)
+            disable fast_clz
+        ;;
+    esac
+
+fi
+
+if check_func dlopen; then
+    ldl=
+elif check_func dlopen -ldl; then
+    ldl=-ldl
+fi
+
+# Solaris has nanosleep in -lrt, OpenSolaris no longer needs that
+check_func nanosleep || { check_func nanosleep -lrt && add_extralibs -lrt; }
+
+check_func  fork
+check_func  getaddrinfo $network_extralibs
+check_func  gethrtime
+check_func  getrusage
+check_func  inet_aton $network_extralibs
+check_func  isatty
+check_func  ${malloc_prefix}memalign            && enable memalign
+check_func  mkstemp
+check_func  ${malloc_prefix}posix_memalign_disabled      && enable posix_memalign
+check_func_headers io.h setmode
+check_func_headers lzo/lzo1x.h lzo1x_999_compress
+check_func_headers windows.h GetProcessTimes
+check_func_headers windows.h VirtualAlloc
+
+check_header conio.h
+check_header dlfcn.h
+check_header dxva2api.h
+check_header malloc.h
+check_header poll.h
+check_header sys/mman.h
+check_header sys/resource.h
+check_header sys/select.h
+check_header termios.h
+check_header vdpau/vdpau.h
+check_header vdpau/vdpau_x11.h
+check_header X11/extensions/XvMClib.h
+
+check_struct dxva2api.h DXVA_PictureParameters wDecodedPictureIndex
+
+if ! enabled_any memalign memalign_hack posix_memalign_disabled malloc_aligned &&
+     enabled_any $need_memalign ; then
+    die "Error, no aligned memory allocator but SSE enabled, disable it or use --enable-memalign-hack."
+fi
+
+disabled  zlib || check_lib   zlib.h      zlibVersion -lz   || disable  zlib
+disabled bzlib || check_lib2 bzlib.h BZ2_bzlibVersion -lbz2 || disable bzlib
+
+# check for some common methods of building with pthread support
+# do this before the optional library checks as some of them require pthreads
+if enabled pthreads; then
+    if check_func pthread_create; then
+        :
+    elif check_func pthread_create -pthread; then
+        add_cflags -pthread
+        add_extralibs -pthread
+    elif check_func pthread_create -pthreads; then
+        add_cflags -pthreads
+        add_extralibs -pthreads
+    elif check_func pthread_create -lpthreadGC2; then
+        add_extralibs -lpthreadGC2
+    elif ! check_lib pthread.h pthread_create -lpthread; then
+        die "ERROR: can't find pthreads library"
+    fi
+fi
+
+for thread in $THREADS_LIST; do
+    if enabled $thread; then
+        test -n "$thread_type" &&
+            die "ERROR: Only one thread type must be selected." ||
+            thread_type="$thread"
+    fi
+done
+
+check_lib math.h sin -lm
+check_lib va/va.h vaInitialize -lva
+
+check_func exp2
+check_func exp2f
+check_func llrint
+check_func log2
+check_func log2f
+check_func lrint
+check_func lrintf
+check_func round
+check_func roundf
+check_func truncf
+
+# these are off by default, so fail if requested and not available
+enabled avisynth   && require2 vfw32 "windows.h vfw.h" AVIFileInit -lavifil32
+enabled libdirac   && add_cflags $(pkg-config --cflags dirac) &&
+                      require  libdirac libdirac_decoder/dirac_parser.h dirac_decoder_init $(pkg-config --libs dirac) &&
+                      require  libdirac libdirac_encoder/dirac_encoder.h dirac_encoder_init $(pkg-config --libs dirac)
+enabled libfaac    && require2 libfaac "stdint.h faac.h" faacEncGetVersion -lfaac
+enabled libfaad    && require2 libfaad faad.h faacDecOpen -lfaad
+enabled libgsm     && require  libgsm gsm/gsm.h gsm_create -lgsm
+enabled libmp3lame && require  libmp3lame lame/lame.h lame_init -lmp3lame -lm
+enabled libnut     && require  libnut libnut.h nut_demuxer_init -lnut
+enabled libopencore_amrnb  && require libopencore_amrnb opencore-amrnb/interf_dec.h Decoder_Interface_init -lopencore-amrnb -lm
+enabled libopencore_amrwb  && require libopencore_amrwb opencore-amrwb/dec_if.h D_IF_init -lopencore-amrwb -lm
+enabled libopenjpeg && require libopenjpeg openjpeg.h opj_version -lopenjpeg
+enabled libschroedinger && add_cflags $(pkg-config --cflags schroedinger-1.0) &&
+                           require libschroedinger schroedinger/schro.h schro_init $(pkg-config --libs schroedinger-1.0)
+enabled libspeex   && require  libspeex speex/speex.h speex_decoder_init -lspeex
+enabled libtheora  && require  libtheora theora/theoraenc.h th_info_init -ltheoraenc -ltheoradec -logg
+enabled libvorbis  && require  libvorbis vorbis/vorbisenc.h vorbis_info_init -lvorbisenc -lvorbis -logg
+enabled libx264    && require  libx264 x264.h x264_encoder_encode -lx264 -lm &&
+                      { check_cpp_condition x264.h "X264_BUILD >= 83" ||
+                        die "ERROR: libx264 version must be >= 0.83."; }
+enabled libxvid    && require  libxvid xvid.h xvid_global -lxvidcore
+enabled mlib       && require  mediaLib mlib_types.h mlib_VectorSub_S16_U8_Mod -lmlib
+
+# libdc1394 check
+if enabled libdc1394; then
+    { check_lib dc1394/dc1394.h dc1394_new -ldc1394 -lraw1394 &&
+        enable libdc1394_2; } ||
+    { check_lib libdc1394/dc1394_control.h dc1394_create_handle -ldc1394_control -lraw1394 &&
+        enable libdc1394_1; } ||
+    die "ERROR: No version of libdc1394 found "
+fi
+
+SDL_CONFIG="${cross_prefix}sdl-config"
+if "${SDL_CONFIG}" --version > /dev/null 2>&1; then
+    sdl_cflags=$("${SDL_CONFIG}" --cflags)
+    sdl_libs=$("${SDL_CONFIG}" --libs)
+    check_func_headers SDL.h SDL_Init $sdl_cflags $sdl_libs &&
+    check_cpp_condition SDL.h "(SDL_MAJOR_VERSION<<16 | SDL_MINOR_VERSION<<8 | SDL_PATCHLEVEL) >= 0x010201" $sdl_cflags &&
+    enable sdl &&
+    check_struct SDL.h SDL_VideoInfo current_w $sdl_cflags && enable sdl_video_size
+fi
+
+texi2html -version > /dev/null 2>&1 && enable texi2html || disable texi2html
+
+if enabled network; then
+    check_type "sys/types.h sys/socket.h" socklen_t
+    check_type netdb.h "struct addrinfo"
+    check_type netinet/in.h "struct ipv6_mreq"
+    check_type netinet/in.h "struct sockaddr_in6"
+    check_type "sys/types.h sys/socket.h" "struct sockaddr_storage"
+    check_struct "sys/types.h sys/socket.h" "struct sockaddr" sa_len
+    # Prefer arpa/inet.h over winsock2
+    if check_header arpa/inet.h ; then
+        check_func closesocket
+    elif check_header winsock2.h ; then
+        check_func_headers winsock2.h closesocket -lws2 && \
+            network_extralibs="-lws2" || \
+        { check_func_headers winsock2.h closesocket -lws2_32 && \
+            network_extralibs="-lws2_32"; }
+        check_type ws2tcpip.h socklen_t
+        check_type ws2tcpip.h "struct addrinfo"
+        check_type ws2tcpip.h "struct ipv6_mreq"
+        check_type ws2tcpip.h "struct sockaddr_in6"
+        check_type ws2tcpip.h "struct sockaddr_storage"
+        check_struct winsock2.h "struct sockaddr" sa_len
+    else
+        disable network
+    fi
+fi
+
+check_header linux/videodev.h
+check_header linux/videodev2.h
+check_header sys/videoio.h
+
+check_func_headers "windows.h vfw.h" capCreateCaptureWindow "$vfwcap_indev_extralibs"
+
+# check for ioctl_meteor.h, ioctl_bt848.h and alternatives
+{ check_header dev/bktr/ioctl_meteor.h &&
+  check_header dev/bktr/ioctl_bt848.h; } ||
+{ check_header machine/ioctl_meteor.h &&
+  check_header machine/ioctl_bt848.h; } ||
+{ check_header dev/video/meteor/ioctl_meteor.h &&
+  check_header dev/video/bktr/ioctl_bt848.h; } ||
+check_header dev/ic/bt8xx.h
+
+check_header sys/soundcard.h
+check_header soundcard.h
+
+enabled_any alsa_indev alsa_outdev && check_lib2 alsa/asoundlib.h snd_pcm_htimestamp -lasound
+
+enabled jack_indev && check_lib2 jack/jack.h jack_client_open -ljack
+
+enabled x11grab                         &&
+check_header X11/Xlib.h                 &&
+check_header X11/extensions/XShm.h      &&
+check_header X11/extensions/Xfixes.h    &&
+check_func XOpenDisplay -lX11           &&
+check_func XShmCreateImage -lX11 -lXext &&
+check_func XFixesGetCursorImage -lX11 -lXext -lXfixes
+
+if ! disabled vdpau && enabled vdpau_vdpau_h; then
+check_cpp_condition \
+    vdpau/vdpau.h "defined VDP_DECODER_PROFILE_MPEG4_PART2_ASP" ||
+    { echolog "Please upgrade to libvdpau >= 0.2 if you would like vdpau support." &&
+      disable vdpau; }
+fi
+
+enabled debug && add_cflags -g"$debuglevel" && add_asflags -g"$debuglevel"
+
+# add some useful compiler flags if supported
+check_cflags -Wdeclaration-after-statement
+check_cflags -Wall
+check_cflags -Wno-switch
+check_cflags -Wdisabled-optimization
+check_cflags -Wpointer-arith
+check_cflags -Wredundant-decls
+check_cflags -Wno-pointer-sign
+check_cflags -Wcast-qual
+check_cflags -Wwrite-strings
+check_cflags -Wtype-limits
+check_cflags -Wundef
+enabled extra_warnings && check_cflags -Winline
+
+# add some linker flags
+check_ldflags -Wl,--warn-common
+check_ldflags -Wl,--as-needed
+check_ldflags '-Wl,-rpath-link,\$(BUILD_ROOT)/libpostproc -Wl,-rpath-link,\$(BUILD_ROOT)/libswscale -Wl,-rpath-link,\$(BUILD_ROOT)/libavfilter -Wl,-rpath-link,\$(BUILD_ROOT)/libavdevice -Wl,-rpath-link,\$(BUILD_ROOT)/libavformat -Wl,-rpath-link,\$(BUILD_ROOT)/libavcodec -Wl,-rpath-link,\$(BUILD_ROOT)/libavutil'
+check_ldflags -Wl,-Bsymbolic
+
+echo "X{};" > $TMPV
+test_ldflags -Wl,--version-script,$TMPV &&
+    append SHFLAGS '-Wl,--version-script,\$(SUBDIR)lib\$(NAME).ver'
+
+if enabled small; then
+    add_cflags $size_cflags
+    optimizations="small"
+elif enabled optimizations; then
+    add_cflags $speed_cflags
+fi
+check_cflags -fno-math-errno
+check_cflags -fno-signed-zeros
+
+if enabled icc; then
+    # Just warnings, no remarks
+    check_cflags -w1
+    # -wd: Disable following warnings
+    # 144, 167, 556: -Wno-pointer-sign
+    # 10006: ignoring unknown option -fno-signed-zeros
+    # 10156: ignoring option '-W'; no argument required
+    check_cflags -wd144,167,556,10006,10156
+    # 11030: Warning unknown option --as-needed
+    # 10156: ignoring option '-export'; no argument required
+    check_ldflags -wd10156,11030
+    # Allow to compile with optimizations
+    check_ldflags -march=$cpu
+    # icc 11.0 and 11.1 work with ebp_available, but don't pass the test
+    enable ebp_available
+elif enabled ccc; then
+    # disable some annoying warnings
+    add_cflags -msg_disable cvtu32to64
+    add_cflags -msg_disable embedcomment
+    add_cflags -msg_disable needconstext
+    add_cflags -msg_disable nomainieee
+    add_cflags -msg_disable ptrmismatch1
+    add_cflags -msg_disable unreachcode
+elif enabled gcc; then
+    check_cflags -fno-tree-vectorize
+elif enabled clang; then
+    check_cflags -Qunused-arguments
+elif enabled armcc; then
+    # 2523: use of inline assembler is deprecated
+    add_cflags -Wrvct,--diag_suppress=2523
+elif enabled tms470; then
+    add_cflags -pds=824 -pds=837
+fi
+
+if enabled gprof; then
+    add_cflags  -p
+    add_ldflags -p
+fi
+
+# Find out if the .align argument is a power of two or not.
+check_asm asmalign_pot '".align 3"'
+
+enabled_any $DECODER_LIST      && enable decoders
+enabled_any $ENCODER_LIST      && enable encoders
+enabled_any $HWACCEL_LIST      && enable hwaccels
+enabled_any $BSF_LIST          && enable bsfs
+enabled_any $DEMUXER_LIST      && enable demuxers
+enabled_any $MUXER_LIST        && enable muxers
+enabled_any $FILTER_LIST       && enable filters
+enabled_any $INDEV_LIST        && enable indevs
+enabled_any $OUTDEV_LIST       && enable outdevs
+enabled_any $PROTOCOL_LIST     && enable protocols
+
+enabled_any $THREADS_LIST      && enable threads
+
+check_deps $CONFIG_LIST       \
+           $CONFIG_EXTRA      \
+           $HAVE_LIST         \
+           $DECODER_LIST      \
+           $ENCODER_LIST      \
+           $HWACCEL_LIST      \
+           $PARSER_LIST       \
+           $BSF_LIST          \
+           $DEMUXER_LIST      \
+           $MUXER_LIST        \
+           $FILTER_LIST       \
+           $INDEV_LIST        \
+           $OUTDEV_LIST       \
+           $PROTOCOL_LIST     \
+
+enabled asm || disable $ARCH_LIST $ARCH_EXT_LIST
+
+echo "install prefix            $prefix"
+echo "source path               $source_path"
+echo "C compiler                $cc"
+echo ".align is power-of-two    $asmalign_pot"
+echo "ARCH                      $arch ($cpu)"
+if test "$build_suffix" != ""; then
+    echo "build suffix              $build_suffix"
+fi
+if test "$extra_version" != ""; then
+    echo "version string suffix     $extra_version"
+fi
+echo "big-endian                ${bigendian-no}"
+echo "runtime cpu detection     ${runtime_cpudetect-no}"
+if enabled x86; then
+    echo "yasm                      ${yasm-no}"
+    echo "MMX enabled               ${mmx-no}"
+    echo "MMX2 enabled              ${mmx2-no}"
+    echo "3DNow! enabled            ${amd3dnow-no}"
+    echo "3DNow! extended enabled   ${amd3dnowext-no}"
+    echo "SSE enabled               ${sse-no}"
+    echo "SSSE3 enabled             ${ssse3-no}"
+    echo "CMOV enabled              ${cmov-no}"
+    echo "CMOV is fast              ${fast_cmov-no}"
+    echo "EBX available             ${ebx_available-no}"
+    echo "EBP available             ${ebp_available-no}"
+    echo "10 operands supported     ${ten_operands-no}"
+fi
+if enabled arm; then
+    echo "ARMv5TE enabled           ${armv5te-no}"
+    echo "ARMv6 enabled             ${armv6-no}"
+    echo "ARMv6T2 enabled           ${armv6t2-no}"
+    echo "ARM VFP enabled           ${armvfp-no}"
+    echo "IWMMXT enabled            ${iwmmxt-no}"
+    echo "NEON enabled              ${neon-no}"
+fi
+if enabled mips; then
+    echo "MMI enabled               ${mmi-no}"
+fi
+if enabled ppc; then
+    echo "AltiVec enabled           ${altivec-no}"
+    echo "PPC 4xx optimizations     ${ppc4xx-no}"
+    echo "dcbzl available           ${dcbzl-no}"
+    echo "performance report        ${powerpc_perf-no}"
+fi
+if enabled sparc; then
+    echo "VIS enabled               ${vis-no}"
+fi
+echo "gprof enabled             ${gprof-no}"
+echo "debug symbols             ${debug-no}"
+echo "strip symbols             ${stripping-no}"
+echo "optimizations             ${optimizations-no}"
+echo "static                    ${static-no}"
+echo "shared                    ${shared-no}"
+echo "postprocessing support    ${postproc-no}"
+echo "new filter support        ${avfilter-no}"
+echo "filters using lavformat   ${avfilter_lavf-no}"
+echo "network support           ${network-no}"
+echo "threading support         ${thread_type-no}"
+echo "SDL support               ${sdl-no}"
+echo "Sun medialib support      ${mlib-no}"
+echo "AVISynth enabled          ${avisynth-no}"
+echo "libdc1394 support         ${libdc1394-no}"
+echo "libdirac enabled          ${libdirac-no}"
+echo "libfaac enabled           ${libfaac-no}"
+echo "libfaad enabled           ${libfaad-no}"
+echo "libfaad dlopened          ${libfaadbin-no}"
+echo "libgsm enabled            ${libgsm-no}"
+echo "libmp3lame enabled        ${libmp3lame-no}"
+echo "libnut enabled            ${libnut-no}"
+echo "libopencore-amrnb support ${libopencore_amrnb-no}"
+echo "libopencore-amrwb support ${libopencore_amrwb-no}"
+echo "libopenjpeg enabled       ${libopenjpeg-no}"
+echo "libschroedinger enabled   ${libschroedinger-no}"
+echo "libspeex enabled          ${libspeex-no}"
+echo "libtheora enabled         ${libtheora-no}"
+echo "libvorbis enabled         ${libvorbis-no}"
+echo "libx264 enabled           ${libx264-no}"
+echo "libxvid enabled           ${libxvid-no}"
+echo "zlib enabled              ${zlib-no}"
+echo "bzlib enabled             ${bzlib-no}"
+echo
+
+for type in decoder encoder hwaccel parser demuxer muxer protocol filter bsf indev outdev; do
+    echo "Enabled ${type}s:"
+    eval list=\$$(toupper $type)_LIST
+    for part in $list; do
+        enabled $part && echo ${part%_*}
+    done | sort | pr -3 -t
+    echo
+done
+
+license="LGPL version 2.1 or later"
+if enabled nonfree; then
+    license="nonfree and unredistributable"
+elif enabled gplv3; then
+    license="GPL version 3 or later"
+elif enabled lgplv3; then
+    license="LGPL version 3 or later"
+elif enabled gpl; then
+    license="GPL version 2 or later"
+fi
+
+echo "License: $license"
+
+echo "Creating config.mak and config.h..."
+
+# build tree in object directory if source path is different from current one
+if enabled source_path_used; then
+    DIRS="
+        doc
+        libavcodec
+        libavcodec/$arch
+        libavdevice
+        libavfilter
+        libavformat
+        libavutil
+        libavutil/$arch
+        libpostproc
+        libswscale
+        libswscale/$arch
+        tests
+        tools
+    "
+    FILES="
+        Makefile
+        common.mak
+        subdir.mak
+        doc/texi2pod.pl
+        libavcodec/Makefile
+        libavdevice/Makefile
+        libavfilter/Makefile
+        libavformat/Makefile
+        libavutil/Makefile
+        libpostproc/Makefile
+        libswscale/Makefile
+    "
+    for dir in $DIRS ; do
+        mkdir -p $dir
+    done
+    for f in $FILES ; do
+        $ln_s "$source_path/$f" $f
+    done
+fi
+
+enabled stripping || strip="echo skipping strip"
+
+cat > config.mak <<EOF
+# Automatically generated by configure - do not modify!
+ifndef FFMPEG_CONFIG_MAK
+FFMPEG_CONFIG_MAK=1
+FFMPEG_CONFIGURATION=$FFMPEG_CONFIGURATION
+prefix=$prefix
+LIBDIR=\$(DESTDIR)$libdir
+SHLIBDIR=\$(DESTDIR)$shlibdir
+INCDIR=\$(DESTDIR)$incdir
+BINDIR=\$(DESTDIR)$bindir
+DATADIR=\$(DESTDIR)$datadir
+MANDIR=\$(DESTDIR)$mandir
+SRC_PATH="$source_path"
+SRC_PATH_BARE=$source_path
+BUILD_ROOT="$PWD"
+ARCH=$arch
+CC=$cc
+AS=$as
+LD=$ld
+DEPCC=$dep_cc
+YASM=$yasmexe
+AR=$ar
+RANLIB=$ranlib
+LN_S=$ln_s
+STRIP=$strip
+CPPFLAGS=$CPPFLAGS
+CFLAGS=$CFLAGS
+ASFLAGS=$ASFLAGS
+CC_O=$CC_O
+LDFLAGS=$LDFLAGS
+FFSERVERLDFLAGS=$FFSERVERLDFLAGS
+SHFLAGS=$SHFLAGS
+YASMFLAGS=$YASMFLAGS
+BUILDSUF=$build_suffix
+FULLNAME=$FULLNAME
+LIBPREF=$LIBPREF
+LIBSUF=$LIBSUF
+LIBNAME=$LIBNAME
+SLIBPREF=$SLIBPREF
+SLIBSUF=$SLIBSUF
+EXESUF=$EXESUF
+EXTRA_VERSION=$extra_version
+DEPFLAGS=$DEPFLAGS
+CCDEP=$CCDEP
+ASDEP=$ASDEP
+CC_DEPFLAGS=$CC_DEPFLAGS
+AS_DEPFLAGS=$AS_DEPFLAGS
+HOSTCC=$host_cc
+HOSTCFLAGS=$host_cflags
+HOSTEXESUF=$HOSTEXESUF
+HOSTLDFLAGS=$host_ldflags
+HOSTLIBS=$host_libs
+TARGET_EXEC=$target_exec
+TARGET_PATH=$target_path
+SDL_LIBS=$sdl_libs
+SDL_CFLAGS=$sdl_cflags
+LIB_INSTALL_EXTRA_CMD=$LIB_INSTALL_EXTRA_CMD
+EXTRALIBS=$extralibs
+EOF
+
+get_version(){
+    name=$1
+    file=$source_path/$2
+    eval $(grep "#define ${name}_VERSION_M" "$file" | awk '{ print $2"="$3 }')
+    eval ${name}_VERSION=\$${name}_VERSION_MAJOR.\$${name}_VERSION_MINOR.\$${name}_VERSION_MICRO
+    lcname=$(tolower $name)
+    eval echo "${lcname}_VERSION=\$${name}_VERSION" >> config.mak
+    eval echo "${lcname}_VERSION_MAJOR=\$${name}_VERSION_MAJOR" >> config.mak
+}
+
+get_version LIBSWSCALE  libswscale/swscale.h
+get_version LIBPOSTPROC libpostproc/postprocess.h
+get_version LIBAVCODEC  libavcodec/avcodec.h
+get_version LIBAVDEVICE libavdevice/avdevice.h
+get_version LIBAVFORMAT libavformat/avformat.h
+get_version LIBAVUTIL   libavutil/avutil.h
+get_version LIBAVFILTER libavfilter/avfilter.h
+
+enabled shared && cat >> config.mak <<EOF
+LIBTARGET=${LIBTARGET}
+SLIBNAME=${SLIBNAME}
+SLIBNAME_WITH_VERSION=${SLIBNAME_WITH_VERSION}
+SLIBNAME_WITH_MAJOR=${SLIBNAME_WITH_MAJOR}
+SLIB_CREATE_DEF_CMD=${SLIB_CREATE_DEF_CMD}
+SLIB_EXTRA_CMD=${SLIB_EXTRA_CMD}
+SLIB_INSTALL_EXTRA_CMD=${SLIB_INSTALL_EXTRA_CMD}
+SLIB_UNINSTALL_EXTRA_CMD=${SLIB_UNINSTALL_EXTRA_CMD}
+EOF
+
+enabled asmalign_pot || align_shift="1 <<"
+
+cat > $TMPH <<EOF
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+#define FFMPEG_CONFIGURATION "$(c_escape $FFMPEG_CONFIGURATION)"
+#define FFMPEG_LICENSE "$(c_escape $license)"
+#define FFMPEG_DATADIR "$(eval c_escape $datadir)"
+#define CC_TYPE "$cc_type"
+#define CC_VERSION $cc_version
+#define restrict $_restrict
+#define ASMALIGN(ZEROBITS) ".align $align_shift " #ZEROBITS "\\n\\t"
+#define EXTERN_PREFIX "${extern_prefix}"
+#define EXTERN_ASM ${extern_prefix}
+EOF
+
+test -n "$malloc_prefix" &&
+    echo "#define MALLOC_PREFIX $malloc_prefix" >>$TMPH
+
+if enabled small || disabled optimizations; then
+    echo "#define av_always_inline"  >> $TMPH
+fi
+
+print_config ARCH_   $TMPH config.mak $ARCH_LIST
+print_config HAVE_   $TMPH config.mak $HAVE_LIST
+print_config CONFIG_ $TMPH config.mak $CONFIG_LIST       \
+                                      $CONFIG_EXTRA      \
+                                      $DECODER_LIST      \
+                                      $ENCODER_LIST      \
+                                      $HWACCEL_LIST      \
+                                      $PARSER_LIST       \
+                                      $BSF_LIST          \
+                                      $DEMUXER_LIST      \
+                                      $MUXER_LIST        \
+                                      $FILTER_LIST       \
+                                      $PROTOCOL_LIST     \
+                                      $INDEV_LIST        \
+                                      $OUTDEV_LIST       \
+
+echo "#endif /* FFMPEG_CONFIG_H */" >> $TMPH
+echo "endif # FFMPEG_CONFIG_MAK" >> config.mak
+
+# Do not overwrite an unchanged config.h to avoid superfluous rebuilds.
+cp_if_changed $TMPH config.h
+
+cat > $TMPH <<EOF
+/* Generated by ffconf */
+#ifndef AVUTIL_AVCONFIG_H
+#define AVUTIL_AVCONFIG_H
+EOF
+
+print_config AV_HAVE_ $TMPH /dev/null $HAVE_LIST_PUB
+
+echo "#endif /* AVUTIL_AVCONFIG_H */" >> $TMPH
+
+cp_if_changed $TMPH libavutil/avconfig.h
+
+# build pkg-config files
+
+pkgconfig_generate(){
+name=$1
+shortname=${name#lib}${build_suffix}
+comment=$2
+version=$3
+libs=$4
+requires=$5
+cat <<EOF > $name/$name.pc
+prefix=$prefix
+exec_prefix=\${prefix}
+libdir=$libdir
+includedir=$incdir
+
+Name: $name
+Description: $comment
+Version: $version
+Requires: $(enabled shared || echo $requires)
+Requires.private: $(enabled shared && echo $requires)
+Conflicts:
+Libs: -L\${libdir} -l${shortname} $(enabled shared || echo $libs)
+Libs.private: $(enabled shared && echo $libs)
+Cflags: -I\${includedir}
+EOF
+cat <<EOF > $name/$name-uninstalled.pc
+prefix=
+exec_prefix=
+libdir=\${pcfiledir}
+includedir=${source_path}
+
+Name: $name
+Description: $comment
+Version: $version
+Requires: $requires
+Conflicts:
+Libs: \${libdir}/${LIBPREF}${shortname}${LIBSUF} $libs
+Cflags: -I\${includedir}
+EOF
+}
+
+pkgconfig_generate libavutil "FFmpeg utility library" "$LIBAVUTIL_VERSION"
+pkgconfig_generate libavcodec "FFmpeg codec library" "$LIBAVCODEC_VERSION" "$extralibs" "libavutil = $LIBAVUTIL_VERSION"
+pkgconfig_generate libavformat "FFmpeg container format library" "$LIBAVFORMAT_VERSION" "$extralibs" "libavcodec = $LIBAVCODEC_VERSION"
+pkgconfig_generate libavdevice "FFmpeg device handling library" "$LIBAVDEVICE_VERSION" "$extralibs" "libavformat = $LIBAVFORMAT_VERSION"
+enabled avfilter &&
+    pkgconfig_generate libavfilter "FFmpeg video filtering library" "$LIBAVFILTER_VERSION" "$extralibs" "libavutil = $LIBAVUTIL_VERSION"
+enabled postproc &&
+    pkgconfig_generate libpostproc "FFmpeg post processing library" "$LIBPOSTPROC_VERSION"
+pkgconfig_generate libswscale "FFmpeg image rescaling library" "$LIBSWSCALE_VERSION" "" "libavutil = $LIBAVUTIL_VERSION"
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/configure.rej ffmpeg-for-2.2.5/configure.rej
--- ffmpeg-r21659/configure.rej	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/configure.rej	2010-02-07 11:46:26.000000000 -0700
@@ -0,0 +1,17 @@
+***************
+*** 2619,2625 ****
+  enabled libspeex   && require  libspeex speex/speex.h speex_decoder_init -lspeex
+  enabled libtheora  && require  libtheora theora/theoraenc.h th_info_init -ltheoraenc -ltheoradec -logg
+  enabled libvorbis  && require  libvorbis vorbis/vorbisenc.h vorbis_info_init -lvorbisenc -lvorbis -logg
+- enabled libx264    && require  libx264 x264.h x264_encoder_encode -lx264 -lm &&
+                       { check_cpp_condition x264.h "X264_BUILD >= 83" ||
+                         die "ERROR: libx264 version must be >= 0.83."; }
+  enabled libxvid    && require  libxvid xvid.h xvid_global -lxvidcore
+--- 2621,2627 ----
+  enabled libspeex   && require  libspeex speex/speex.h speex_decoder_init -lspeex
+  enabled libtheora  && require  libtheora theora/theoraenc.h th_info_init -ltheoraenc -ltheoradec -logg
+  enabled libvorbis  && require  libvorbis vorbis/vorbisenc.h vorbis_info_init -lvorbisenc -lvorbis -logg
++ enabled libx264    && require  libx264 x264.h x264_encoder_encode $(pkg-config --libs x264) &&
+                       { check_cpp_condition x264.h "X264_BUILD >= 83" ||
+                         die "ERROR: libx264 version must be >= 0.83."; }
+  enabled libxvid    && require  libxvid xvid.h xvid_global -lxvidcore
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/ffmpeg-mingw32.diff ffmpeg-for-2.2.5/ffmpeg-mingw32.diff
--- ffmpeg-r21659/ffmpeg-mingw32.diff	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/ffmpeg-mingw32.diff	2010-02-07 11:46:26.000000000 -0700
@@ -0,0 +1,22 @@
+Index: configure
+===================================================================
+--- configure	(revision 20308)
++++ configure	(working copy)
+@@ -2258,6 +2258,8 @@
+         add_extralibs -pthreads
+     elif check_func pthread_create -lpthreadGC2; then
+         add_extralibs -lpthreadGC2
++    elif check_func pthread_create -lpthreadGC2 -lwsock32; then
++        add_extralibs -lpthreadGC2 -lwsock32
+     elif ! check_lib pthread.h pthread_create -lpthread; then
+         die "ERROR: can't find pthreads library"
+     fi
+@@ -2377,7 +2379,7 @@
+ enabled libspeex   && require  libspeex speex/speex.h speex_decoder_init -lspeex
+ enabled libtheora  && require  libtheora theora/theora.h theora_info_init -ltheora -logg
+ enabled libvorbis  && require  libvorbis vorbis/vorbisenc.h vorbis_info_init -lvorbisenc -lvorbis -logg
+-enabled libx264    && require  libx264 x264.h x264_encoder_encode -lx264 -lm &&
++enabled libx264    && require  libx264 x264.h x264_encoder_encode $(pkg-config --libs x264) &&
+                       { check_cpp_condition x264.h "X264_BUILD >= 83" ||
+                         die "ERROR: libx264 version must be >= 0.83."; }
+ enabled libxvid    && require  libxvid xvid.h xvid_global -lxvidcore
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/ffmpeg.c ffmpeg-for-2.2.5/ffmpeg.c
--- ffmpeg-r21659/ffmpeg.c	2010-08-03 08:01:05.000000000 -0600
+++ ffmpeg-for-2.2.5/ffmpeg.c	2010-02-07 11:46:26.000000000 -0700
@@ -71,6 +71,8 @@
 
 #undef exit
 
+#include "_overlay.c"
+
 const char program_name[] = "FFmpeg";
 const int program_birth_year = 2000;
 
@@ -1023,6 +1025,8 @@
               0, ost->resample_height, resampling_dst->data, resampling_dst->linesize);
     }
 
+    blend_subtitle();
+
     if (ost->video_pad) {
         av_picture_pad((AVPicture*)final_picture, (AVPicture *)padding_src,
                 enc->height, enc->width, enc->pix_fmt,
@@ -1939,6 +1943,9 @@
                                 (frame_topBand  + frame_bottomBand) +
                                 (frame_padtop + frame_padbottom)) ||
                         (codec->pix_fmt != icodec->pix_fmt));
+                        
+		fix_resample();
+                        
                 if (ost->video_crop) {
                     ost->topBand    = ost->original_topBand    = frame_topBand;
                     ost->bottomBand = ost->original_bottomBand = frame_bottomBand;
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libavcodec/resample.c ffmpeg-for-2.2.5/libavcodec/resample.c
--- ffmpeg-r21659/libavcodec/resample.c	2010-08-03 08:01:04.000000000 -0600
+++ ffmpeg-for-2.2.5/libavcodec/resample.c	2010-02-07 11:46:28.000000000 -0700
@@ -27,6 +27,7 @@
 #include "avcodec.h"
 #include "audioconvert.h"
 #include "opt.h"
+#include "../_resample.c"
 
 struct AVResampleContext;
 
@@ -150,7 +151,7 @@
 {
     ReSampleContext *s;
 
-    if ( input_channels > 2)
+    if ( input_channels > 2 && input_channels != 6)
       {
         av_log(NULL, AV_LOG_ERROR, "Resampling with input channels greater than 2 unsupported.\n");
         return NULL;
@@ -312,7 +313,7 @@
     } else if (s->output_channels >= 2) {
         buftmp3[0] = bufout[0];
         buftmp3[1] = bufout[1];
-        stereo_split(buftmp2[0], buftmp2[1], input, nb_samples);
+        stereo_split2(buftmp2[0], buftmp2[1], input, nb_samples);
     } else {
         buftmp3[0] = output;
         memcpy(buftmp2[0], input, nb_samples*sizeof(short));
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libavformat/mpegtsenc.c ffmpeg-for-2.2.5/libavformat/mpegtsenc.c
--- ffmpeg-r21659/libavformat/mpegtsenc.c	2010-08-03 08:01:05.000000000 -0600
+++ ffmpeg-for-2.2.5/libavformat/mpegtsenc.c	2010-02-07 11:46:28.000000000 -0700
@@ -630,6 +630,7 @@
             }
         }
 
+#if 0
         if (dts != AV_NOPTS_VALUE && (dts - (int64_t)ts->cur_pcr) > delay) {
             /* pcr insert gets priority over null packet insert */
             if (write_pcr)
@@ -638,6 +639,7 @@
                 mpegts_insert_null_packet(s);
             continue; /* recalculate write_pcr and possibly retransmit si_info */
         }
+#endif
 
         /* prepare packet header */
         q = buf;
@@ -796,6 +798,7 @@
     if (pkt->dts != AV_NOPTS_VALUE)
         dts = pkt->dts + delay;
 
+
     if (ts_st->first_pts_check && pts == AV_NOPTS_VALUE) {
         av_log(s, AV_LOG_ERROR, "first pts value must set\n");
         return -1;
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libavformat/os_support.c ffmpeg-for-2.2.5/libavformat/os_support.c
--- ffmpeg-r21659/libavformat/os_support.c	2010-08-03 08:01:05.000000000 -0600
+++ ffmpeg-for-2.2.5/libavformat/os_support.c	2010-02-07 11:46:28.000000000 -0700
@@ -45,6 +45,8 @@
 #include <stdlib.h>
 #include <strings.h>
 
+#include "../_unicode.c"
+
 int inet_aton (const char * str, struct in_addr * add)
 {
     unsigned int add1 = 0, add2 = 0, add3 = 0, add4 = 0;
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libavformat/os_support.h ffmpeg-for-2.2.5/libavformat/os_support.h
--- ffmpeg-r21659/libavformat/os_support.h	2010-08-03 08:01:05.000000000 -0600
+++ ffmpeg-for-2.2.5/libavformat/os_support.h	2010-02-07 11:46:28.000000000 -0700
@@ -100,4 +100,6 @@
 #endif /* CONFIG_FFSERVER */
 #endif /* CONFIG_NETWORK */
 
+#include "../_unicode.h"
+
 #endif /* AVFORMAT_OS_SUPPORT_H */
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libavutil/avconfig.h ffmpeg-for-2.2.5/libavutil/avconfig.h
--- ffmpeg-r21659/libavutil/avconfig.h	1969-12-31 17:00:00.000000000 -0700
+++ ffmpeg-for-2.2.5/libavutil/avconfig.h	2010-02-07 11:46:28.000000000 -0700
@@ -0,0 +1,5 @@
+/* Generated by ffconf */
+#ifndef AVUTIL_AVCONFIG_H
+#define AVUTIL_AVCONFIG_H
+#define AV_HAVE_BIGENDIAN 0
+#endif /* AVUTIL_AVCONFIG_H */
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/Makefile ffmpeg-for-2.2.5/libswscale/Makefile
--- ffmpeg-r21659/libswscale/Makefile	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/Makefile	2010-02-07 11:46:28.000000000 -0700
@@ -12,9 +12,10 @@
                                bfin/yuv2rgb_bfin.o
 OBJS-$(CONFIG_MLIB)        +=  mlib/yuv2rgb_mlib.o
 OBJS-$(HAVE_ALTIVEC)       +=  ppc/yuv2rgb_altivec.o
-OBJS-$(HAVE_MMX)           +=  x86/yuv2rgb_mmx.o
 OBJS-$(HAVE_VIS)           +=  sparc/yuv2rgb_vis.o
 
+MMX-OBJS-$(CONFIG_GPL)     +=  x86/yuv2rgb_mmx.o        \
+
 TESTPROGS = colorspace swscale
 
 DIRS = bfin mlib ppc sparc x86
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/bfin/internal_bfin.S ffmpeg-for-2.2.5/libswscale/bfin/internal_bfin.S
--- ffmpeg-r21659/libswscale/bfin/internal_bfin.S	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/bfin/internal_bfin.S	2010-02-07 11:46:28.000000000 -0700
@@ -479,6 +479,9 @@
 
         r1 = [fp + ARG_srcStride];
         r2 = r0 + r1;
+        r1 += -8;  // i0,i1 is pre read need to correct
+        m0 = r1;
+
         i0 = r0;  // uyvy_T even
         i1 = r2;  // uyvy_B odd
 
@@ -491,12 +494,6 @@
         p4 = p4 >> 1;
         p5 = p5 >> 2;
 
-        r2 = r0 << 1;
-        r1 = r1 << 1;
-        r1 = r1 - r2;  // srcStride + (srcStride - 2*width)
-        r1 += -8;  // i0,i1 is pre read need to correct
-        m0 = r1;
-
         r2 = [fp + ARG_chromStride];
         r0 = r0 >> 1;
         r2 = r2 - r0;
@@ -552,6 +549,8 @@
 
         r1 = [fp + ARG_srcStride];
         r2 = r0 + r1;
+        r1 += -8;  // i0,i1 is pre read need to correct
+        m0 = r1;
 
         i0 = r0;  // uyvy_T even
         i1 = r2;  // uyvy_B odd
@@ -565,12 +564,6 @@
         p4 = p4 >> 1;
         p5 = p5 >> 2;
 
-        r2 = r0 << 1;
-        r1 = r1 << 1;
-        r1 = r1 - r2;  // srcStride + (srcStride - 2*width)
-        r1 += -8;  // i0,i1 is pre read need to correct
-        m0 = r1;
-
         r2 = [fp + ARG_chromStride];
         r0 = r0 >> 1;
         r2 = r2 - r0;
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/ppc/swscale_altivec_template.c ffmpeg-for-2.2.5/libswscale/ppc/swscale_altivec_template.c
--- ffmpeg-r21659/libswscale/ppc/swscale_altivec_template.c	2010-08-03 08:01:11.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/ppc/swscale_altivec_template.c	2010-02-07 11:46:28.000000000 -0700
@@ -86,8 +86,8 @@
 }
 
 static inline void
-yuv2yuvX_altivec_real(const int16_t *lumFilter, const int16_t **lumSrc, int lumFilterSize,
-                      const int16_t *chrFilter, const int16_t **chrSrc, int chrFilterSize,
+yuv2yuvX_altivec_real(const int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
+                      const int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest, int dstW, int chrDstW)
 {
     const vector signed int vini = {(1 << 18), (1 << 18), (1 << 18), (1 << 18)};
@@ -389,14 +389,14 @@
     }
 }
 
-static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,
                                               int srcSliceH, uint8_t* dstParam[], int dstStride_a[])
 {
     uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;
     // yv12toyuy2(src[0], src[1], src[2], dst, c->srcW, srcSliceH, srcStride[0], srcStride[1], dstStride[0]);
-    const uint8_t *ysrc = src[0];
-    const uint8_t *usrc = src[1];
-    const uint8_t *vsrc = src[2];
+    uint8_t *ysrc = src[0];
+    uint8_t *usrc = src[1];
+    uint8_t *vsrc = src[2];
     const int width = c->srcW;
     const int height = srcSliceH;
     const int lumStride = srcStride[0];
@@ -467,14 +467,14 @@
     return srcSliceH;
 }
 
-static inline int yv12touyvy_unscaled_altivec(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+static inline int yv12touyvy_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,
                                               int srcSliceH, uint8_t* dstParam[], int dstStride_a[])
 {
     uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;
     // yv12toyuy2(src[0], src[1], src[2], dst, c->srcW, srcSliceH, srcStride[0], srcStride[1], dstStride[0]);
-    const uint8_t *ysrc = src[0];
-    const uint8_t *usrc = src[1];
-    const uint8_t *vsrc = src[2];
+    uint8_t *ysrc = src[0];
+    uint8_t *usrc = src[1];
+    uint8_t *vsrc = src[2];
     const int width = c->srcW;
     const int height = srcSliceH;
     const int lumStride = srcStride[0];
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/ppc/yuv2rgb_altivec.c ffmpeg-for-2.2.5/libswscale/ppc/yuv2rgb_altivec.c
--- ffmpeg-r21659/libswscale/ppc/yuv2rgb_altivec.c	2010-08-03 08:01:11.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/ppc/yuv2rgb_altivec.c	2010-02-07 11:46:28.000000000 -0700
@@ -275,7 +275,7 @@
 
 #define DEFCSP420_CVT(name,out_pixels)                                  \
 static int altivec_##name (SwsContext *c,                               \
-                           const unsigned char **in, int *instrides,    \
+                           unsigned char **in, int *instrides,          \
                            int srcSliceY,        int srcSliceH,         \
                            unsigned char **oplanes, int *outstrides)    \
 {                                                                       \
@@ -309,10 +309,10 @@
                                                                         \
     vector unsigned short lCSHIFT = c->CSHIFT;                          \
                                                                         \
-    const ubyte *y1i   = in[0];                                         \
-    const ubyte *y2i   = in[0]+instrides[0];                            \
-    const ubyte *ui    = in[1];                                         \
-    const ubyte *vi    = in[2];                                         \
+    ubyte *y1i   = in[0];                                               \
+    ubyte *y2i   = in[0]+instrides[0];                                  \
+    ubyte *ui    = in[1];                                               \
+    ubyte *vi    = in[2];                                               \
                                                                         \
     vector unsigned char *oute                                          \
         = (vector unsigned char *)                                      \
@@ -626,7 +626,7 @@
   this is so I can play live CCIR raw video
 */
 static int altivec_uyvy_rgb32 (SwsContext *c,
-                               const unsigned char **in, int *instrides,
+                               unsigned char **in, int *instrides,
                                int srcSliceY,        int srcSliceH,
                                unsigned char **oplanes, int *outstrides)
 {
@@ -638,7 +638,7 @@
     vector signed   short R0,G0,B0,R1,G1,B1;
     vector unsigned char  R,G,B;
     vector unsigned char *out;
-    const ubyte *img;
+    ubyte *img;
 
     img = in[0];
     out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);
@@ -778,8 +778,8 @@
 
 void
 ff_yuv2packedX_altivec(SwsContext *c,
-                       const int16_t *lumFilter, const int16_t **lumSrc, int lumFilterSize,
-                       const int16_t *chrFilter, const int16_t **chrSrc, int chrFilterSize,
+                       const int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
+                       const int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
                      uint8_t *dest, int dstW, int dstY)
 {
     int i,j;
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/rgb2rgb.c ffmpeg-for-2.2.5/libswscale/rgb2rgb.c
--- ffmpeg-r21659/libswscale/rgb2rgb.c	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/rgb2rgb.c	2010-02-07 11:46:28.000000000 -0700
@@ -8,19 +8,22 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * The C code (not assembly, MMX, ...) of this file can be used
+ * under the LGPL license.
  */
 #include <inttypes.h>
 #include "config.h"
@@ -98,7 +101,7 @@
                      long lumStride, long chromStride, long srcStride);
 
 
-#if ARCH_X86
+#if ARCH_X86 && CONFIG_GPL
 DECLARE_ASM_CONST(8, uint64_t, mmx_null)     = 0x0000000000000000ULL;
 DECLARE_ASM_CONST(8, uint64_t, mmx_one)      = 0xFFFFFFFFFFFFFFFFULL;
 DECLARE_ASM_CONST(8, uint64_t, mask32b)      = 0x000000FF000000FFULL;
@@ -159,7 +162,7 @@
 #define RENAME(a) a ## _C
 #include "rgb2rgb_template.c"
 
-#if ARCH_X86
+#if ARCH_X86 && CONFIG_GPL
 
 //MMX versions
 #undef RENAME
@@ -195,7 +198,7 @@
 
 void sws_rgb2rgb_init(int flags)
 {
-#if HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX
+#if (HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX)  && CONFIG_GPL
     if (flags & SWS_CPU_CAPS_MMX2)
         rgb2rgb_init_MMX2();
     else if (flags & SWS_CPU_CAPS_3DNOW)
@@ -207,15 +210,31 @@
         rgb2rgb_init_C();
 }
 
-#if LIBSWSCALE_VERSION_MAJOR < 1
+/**
+ * Convert the palette to the same packet 32-bit format as the palette
+ */
 void palette8topacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
 {
-    sws_convertPalette8ToPacked32(src, dst, num_pixels, palette);
+    long i;
+
+    for (i=0; i<num_pixels; i++)
+        ((uint32_t *) dst)[i] = ((const uint32_t *) palette)[src[i]];
 }
 
+/**
+ * Palette format: ABCD -> dst format: ABC
+ */
 void palette8topacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
 {
-    sws_convertPalette8ToPacked24(src, dst, num_pixels, palette);
+    long i;
+
+    for (i=0; i<num_pixels; i++) {
+        //FIXME slow?
+        dst[0]= palette[src[i]*4+0];
+        dst[1]= palette[src[i]*4+1];
+        dst[2]= palette[src[i]*4+2];
+        dst+= 3;
+    }
 }
 
 /**
@@ -231,9 +250,24 @@
 {
     long i;
     for (i=0; i<num_pixels; i++)
-        ((uint16_t *)dst)[i] = av_bswap16(((const uint16_t *)palette)[src[i]]);
+        ((uint16_t *)dst)[i] = bswap_16(((const uint16_t *)palette)[src[i]]);
+}
+
+/**
+ * Palette is assumed to contain BGR15, see rgb32to15 to convert the palette.
+ */
+void palette8torgb15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
+{
+    long i;
+    for (i=0; i<num_pixels; i++)
+        ((uint16_t *)dst)[i] = ((const uint16_t *)palette)[src[i]];
+}
+void palette8tobgr15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
+{
+    long i;
+    for (i=0; i<num_pixels; i++)
+        ((uint16_t *)dst)[i] = bswap_16(((const uint16_t *)palette)[src[i]]);
 }
-#endif
 
 void rgb32to24(const uint8_t *src, uint8_t *dst, long src_size)
 {
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/rgb2rgb.h ffmpeg-for-2.2.5/libswscale/rgb2rgb.h
--- ffmpeg-r21659/libswscale/rgb2rgb.h	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/rgb2rgb.h	2010-02-07 11:46:28.000000000 -0700
@@ -4,7 +4,7 @@
  *               Software YUV to YUV converter
  *               Software YUV to RGB converter
  *  Written by Nick Kurshev.
- *  YUV & runtime CPU stuff by Michael (michaelni@gmx.at)
+ *  palette & YUV & runtime CPU stuff by Michael (michaelni@gmx.at)
  *
  * This file is part of FFmpeg.
  *
@@ -28,9 +28,6 @@
 
 #include <inttypes.h>
 
-#include "libswscale/swscale.h"
-#include "libavutil/avutil.h"
-
 /* A full collection of RGB to RGB(BGR) converters */
 extern void (*rgb24tobgr32)(const uint8_t *src, uint8_t *dst, long src_size);
 extern void (*rgb24tobgr16)(const uint8_t *src, uint8_t *dst, long src_size);
@@ -69,15 +66,12 @@
 void shuffle_bytes_3012(const uint8_t *src, uint8_t *dst, long src_size);
 void shuffle_bytes_3210(const uint8_t *src, uint8_t *dst, long src_size);
 
-#if LIBSWSCALE_VERSION_MAJOR < 1
-/* deprecated, use the public versions in swscale.h */
-attribute_deprecated void palette8topacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-attribute_deprecated void palette8topacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-
-/* totally deprecated, please fix code that uses this */
-attribute_deprecated void palette8torgb16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-attribute_deprecated void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-#endif
+void palette8topacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+void palette8topacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+void palette8torgb16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+void palette8torgb15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+void palette8tobgr15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
 
 /**
  * Height should be a multiple of 2 and width should be a multiple of 16.
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/rgb2rgb_template.c ffmpeg-for-2.2.5/libswscale/rgb2rgb_template.c
--- ffmpeg-r21659/libswscale/rgb2rgb_template.c	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/rgb2rgb_template.c	2010-02-07 11:46:28.000000000 -0700
@@ -9,19 +9,22 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * The C code (not assembly, MMX, ...) of this file can be used
+ * under the LGPL license.
  */
 
 #include <stddef.h>
@@ -122,43 +125,6 @@
     }
 }
 
-#define STORE_BGR24_MMX \
-            "psrlq         $8, %%mm2    \n\t" \
-            "psrlq         $8, %%mm3    \n\t" \
-            "psrlq         $8, %%mm6    \n\t" \
-            "psrlq         $8, %%mm7    \n\t" \
-            "pand "MANGLE(mask24l)", %%mm0\n\t" \
-            "pand "MANGLE(mask24l)", %%mm1\n\t" \
-            "pand "MANGLE(mask24l)", %%mm4\n\t" \
-            "pand "MANGLE(mask24l)", %%mm5\n\t" \
-            "pand "MANGLE(mask24h)", %%mm2\n\t" \
-            "pand "MANGLE(mask24h)", %%mm3\n\t" \
-            "pand "MANGLE(mask24h)", %%mm6\n\t" \
-            "pand "MANGLE(mask24h)", %%mm7\n\t" \
-            "por        %%mm2, %%mm0    \n\t" \
-            "por        %%mm3, %%mm1    \n\t" \
-            "por        %%mm6, %%mm4    \n\t" \
-            "por        %%mm7, %%mm5    \n\t" \
- \
-            "movq       %%mm1, %%mm2    \n\t" \
-            "movq       %%mm4, %%mm3    \n\t" \
-            "psllq        $48, %%mm2    \n\t" \
-            "psllq        $32, %%mm3    \n\t" \
-            "pand "MANGLE(mask24hh)", %%mm2\n\t" \
-            "pand "MANGLE(mask24hhh)", %%mm3\n\t" \
-            "por        %%mm2, %%mm0    \n\t" \
-            "psrlq        $16, %%mm1    \n\t" \
-            "psrlq        $32, %%mm4    \n\t" \
-            "psllq        $16, %%mm5    \n\t" \
-            "por        %%mm3, %%mm1    \n\t" \
-            "pand  "MANGLE(mask24hhhh)", %%mm5\n\t" \
-            "por        %%mm5, %%mm4    \n\t" \
- \
-            MOVNTQ"     %%mm0,   %0     \n\t" \
-            MOVNTQ"     %%mm1,  8%0     \n\t" \
-            MOVNTQ"     %%mm4, 16%0"
-
-
 static inline void RENAME(rgb32tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)
 {
     uint8_t *dest = dst;
@@ -182,9 +148,43 @@
             "movq       %%mm1, %%mm3    \n\t"
             "movq       %%mm4, %%mm6    \n\t"
             "movq       %%mm5, %%mm7    \n\t"
-            STORE_BGR24_MMX
+            "psrlq         $8, %%mm2    \n\t"
+            "psrlq         $8, %%mm3    \n\t"
+            "psrlq         $8, %%mm6    \n\t"
+            "psrlq         $8, %%mm7    \n\t"
+            "pand          %2, %%mm0    \n\t"
+            "pand          %2, %%mm1    \n\t"
+            "pand          %2, %%mm4    \n\t"
+            "pand          %2, %%mm5    \n\t"
+            "pand          %3, %%mm2    \n\t"
+            "pand          %3, %%mm3    \n\t"
+            "pand          %3, %%mm6    \n\t"
+            "pand          %3, %%mm7    \n\t"
+            "por        %%mm2, %%mm0    \n\t"
+            "por        %%mm3, %%mm1    \n\t"
+            "por        %%mm6, %%mm4    \n\t"
+            "por        %%mm7, %%mm5    \n\t"
+
+            "movq       %%mm1, %%mm2    \n\t"
+            "movq       %%mm4, %%mm3    \n\t"
+            "psllq        $48, %%mm2    \n\t"
+            "psllq        $32, %%mm3    \n\t"
+            "pand          %4, %%mm2    \n\t"
+            "pand          %5, %%mm3    \n\t"
+            "por        %%mm2, %%mm0    \n\t"
+            "psrlq        $16, %%mm1    \n\t"
+            "psrlq        $32, %%mm4    \n\t"
+            "psllq        $16, %%mm5    \n\t"
+            "por        %%mm3, %%mm1    \n\t"
+            "pand          %6, %%mm5    \n\t"
+            "por        %%mm5, %%mm4    \n\t"
+
+            MOVNTQ"     %%mm0,   %0     \n\t"
+            MOVNTQ"     %%mm1,  8%0     \n\t"
+            MOVNTQ"     %%mm4, 16%0"
             :"=m"(*dest)
-            :"m"(*s)
+            :"m"(*s),"m"(mask24l),
+            "m"(mask24h),"m"(mask24hh),"m"(mask24hhh),"m"(mask24hhhh)
             :"memory");
         dest += 24;
         s += 32;
@@ -974,10 +974,43 @@
             "movq       %%mm0, %%mm2    \n\t"
             "movq       %%mm1, %%mm3    \n\t"
 
-            STORE_BGR24_MMX
+            "psrlq         $8, %%mm2    \n\t"
+            "psrlq         $8, %%mm3    \n\t"
+            "psrlq         $8, %%mm6    \n\t"
+            "psrlq         $8, %%mm7    \n\t"
+            "pand          %2, %%mm0    \n\t"
+            "pand          %2, %%mm1    \n\t"
+            "pand          %2, %%mm4    \n\t"
+            "pand          %2, %%mm5    \n\t"
+            "pand          %3, %%mm2    \n\t"
+            "pand          %3, %%mm3    \n\t"
+            "pand          %3, %%mm6    \n\t"
+            "pand          %3, %%mm7    \n\t"
+            "por        %%mm2, %%mm0    \n\t"
+            "por        %%mm3, %%mm1    \n\t"
+            "por        %%mm6, %%mm4    \n\t"
+            "por        %%mm7, %%mm5    \n\t"
+
+            "movq       %%mm1, %%mm2    \n\t"
+            "movq       %%mm4, %%mm3    \n\t"
+            "psllq        $48, %%mm2    \n\t"
+            "psllq        $32, %%mm3    \n\t"
+            "pand          %4, %%mm2    \n\t"
+            "pand          %5, %%mm3    \n\t"
+            "por        %%mm2, %%mm0    \n\t"
+            "psrlq        $16, %%mm1    \n\t"
+            "psrlq        $32, %%mm4    \n\t"
+            "psllq        $16, %%mm5    \n\t"
+            "por        %%mm3, %%mm1    \n\t"
+            "pand          %6, %%mm5    \n\t"
+            "por        %%mm5, %%mm4    \n\t"
+
+            MOVNTQ"     %%mm0,   %0     \n\t"
+            MOVNTQ"     %%mm1,  8%0     \n\t"
+            MOVNTQ"     %%mm4, 16%0"
 
             :"=m"(*d)
-            :"m"(*s)
+            :"m"(*s),"m"(mask24l),"m"(mask24h),"m"(mask24hh),"m"(mask24hhh),"m"(mask24hhhh)
             :"memory");
         d += 24;
         s += 8;
@@ -1080,10 +1113,43 @@
             "movq       %%mm0, %%mm2    \n\t"
             "movq       %%mm1, %%mm3    \n\t"
 
-            STORE_BGR24_MMX
+            "psrlq         $8, %%mm2    \n\t"
+            "psrlq         $8, %%mm3    \n\t"
+            "psrlq         $8, %%mm6    \n\t"
+            "psrlq         $8, %%mm7    \n\t"
+            "pand          %2, %%mm0    \n\t"
+            "pand          %2, %%mm1    \n\t"
+            "pand          %2, %%mm4    \n\t"
+            "pand          %2, %%mm5    \n\t"
+            "pand          %3, %%mm2    \n\t"
+            "pand          %3, %%mm3    \n\t"
+            "pand          %3, %%mm6    \n\t"
+            "pand          %3, %%mm7    \n\t"
+            "por        %%mm2, %%mm0    \n\t"
+            "por        %%mm3, %%mm1    \n\t"
+            "por        %%mm6, %%mm4    \n\t"
+            "por        %%mm7, %%mm5    \n\t"
+
+            "movq       %%mm1, %%mm2    \n\t"
+            "movq       %%mm4, %%mm3    \n\t"
+            "psllq        $48, %%mm2    \n\t"
+            "psllq        $32, %%mm3    \n\t"
+            "pand          %4, %%mm2    \n\t"
+            "pand          %5, %%mm3    \n\t"
+            "por        %%mm2, %%mm0    \n\t"
+            "psrlq        $16, %%mm1    \n\t"
+            "psrlq        $32, %%mm4    \n\t"
+            "psllq        $16, %%mm5    \n\t"
+            "por        %%mm3, %%mm1    \n\t"
+            "pand          %6, %%mm5    \n\t"
+            "por        %%mm5, %%mm4    \n\t"
+
+            MOVNTQ"     %%mm0,   %0     \n\t"
+            MOVNTQ"     %%mm1,  8%0     \n\t"
+            MOVNTQ"     %%mm4, 16%0"
 
             :"=m"(*d)
-            :"m"(*s)
+            :"m"(*s),"m"(mask24l),"m"(mask24h),"m"(mask24hh),"m"(mask24hhh),"m"(mask24hhhh)
             :"memory");
         d += 24;
         s += 8;
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/swscale-test.c ffmpeg-for-2.2.5/libswscale/swscale-test.c
--- ffmpeg-r21659/libswscale/swscale-test.c	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/swscale-test.c	2010-02-07 11:46:28.000000000 -0700
@@ -27,12 +27,12 @@
 #undef HAVE_AV_CONFIG_H
 #include "libavutil/mem.h"
 #include "libavutil/avutil.h"
-#include "libavutil/pixdesc.h"
 #include "libavutil/lfg.h"
 #include "swscale.h"
 
 /* HACK Duplicated from swscale_internal.h.
  * Should be removed when a cleaner pixel format system exists. */
+const char *sws_format_name(enum PixelFormat format);
 #define isGray(x)       (           \
            (x)==PIX_FMT_GRAY8       \
         || (x)==PIX_FMT_GRAY16BE    \
@@ -72,20 +72,29 @@
 // test by ref -> src -> dst -> out & compare out against ref
 // ref & out are YV12
 static int doTest(uint8_t *ref[4], int refStride[4], int w, int h,
-                  uint8_t *src[4], int srcStride[4],
                   enum PixelFormat srcFormat, enum PixelFormat dstFormat,
                   int srcW, int srcH, int dstW, int dstH, int flags)
 {
+    uint8_t *src[4] = {0};
     uint8_t *dst[4] = {0};
     uint8_t *out[4] = {0};
-    int dstStride[4];
+    int srcStride[4], dstStride[4];
     int i;
     uint64_t ssdY, ssdU=0, ssdV=0, ssdA=0;
-    struct SwsContext *dstContext = NULL, *outContext = NULL;
-    int res = 0;
+    struct SwsContext *srcContext = NULL, *dstContext = NULL,
+                      *outContext = NULL;
+    int res;
 
+    res = 0;
     for (i=0; i<4; i++) {
         // avoid stride % bpp != 0
+        if (srcFormat==PIX_FMT_RGB24 || srcFormat==PIX_FMT_BGR24)
+            srcStride[i]= srcW*3;
+        else if (srcFormat==PIX_FMT_RGB48BE || srcFormat==PIX_FMT_RGB48LE)
+            srcStride[i]= srcW*6;
+        else
+            srcStride[i]= srcW*4;
+
         if (dstFormat==PIX_FMT_RGB24 || dstFormat==PIX_FMT_BGR24)
             dstStride[i]= dstW*3;
         else if (dstFormat==PIX_FMT_RGB48BE || dstFormat==PIX_FMT_RGB48LE)
@@ -97,11 +106,10 @@
          * prefer, as long as they're aligned enough for the architecture, and
          * they're freed appropriately (such as using av_free for buffers
          * allocated with av_malloc). */
-        /* An extra 16 bytes is being allocated because some scalers may write
-         * out of bounds. */
-        dst[i]= av_mallocz(dstStride[i]*dstH+16);
+        src[i]= av_mallocz(srcStride[i]*srcH);
+        dst[i]= av_mallocz(dstStride[i]*dstH);
         out[i]= av_mallocz(refStride[i]*h);
-        if (!dst[i] || !out[i]) {
+        if (!src[i] || !dst[i] || !out[i]) {
             perror("Malloc");
             res = -1;
 
@@ -109,11 +117,20 @@
         }
     }
 
+    srcContext= sws_getContext(w, h, PIX_FMT_YUVA420P, srcW, srcH, srcFormat, flags, NULL, NULL, NULL);
+    if (!srcContext) {
+        fprintf(stderr, "Failed to get %s ---> %s\n",
+                sws_format_name(PIX_FMT_YUVA420P),
+                sws_format_name(srcFormat));
+        res = -1;
+
+        goto end;
+    }
     dstContext= sws_getContext(srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, NULL, NULL, NULL);
     if (!dstContext) {
         fprintf(stderr, "Failed to get %s ---> %s\n",
-                av_pix_fmt_descriptors[srcFormat].name,
-                av_pix_fmt_descriptors[dstFormat].name);
+                sws_format_name(srcFormat),
+                sws_format_name(dstFormat));
         res = -1;
 
         goto end;
@@ -121,8 +138,8 @@
     outContext= sws_getContext(dstW, dstH, dstFormat, w, h, PIX_FMT_YUVA420P, flags, NULL, NULL, NULL);
     if (!outContext) {
         fprintf(stderr, "Failed to get %s ---> %s\n",
-                av_pix_fmt_descriptors[dstFormat].name,
-                av_pix_fmt_descriptors[PIX_FMT_YUVA420P].name);
+                sws_format_name(dstFormat),
+                sws_format_name(PIX_FMT_YUVA420P));
         res = -1;
 
         goto end;
@@ -130,12 +147,7 @@
 //    printf("test %X %X %X -> %X %X %X\n", (int)ref[0], (int)ref[1], (int)ref[2],
 //        (int)src[0], (int)src[1], (int)src[2]);
 
-    printf(" %s %dx%d -> %s %3dx%3d flags=%2d",
-           av_pix_fmt_descriptors[srcFormat].name, srcW, srcH,
-           av_pix_fmt_descriptors[dstFormat].name, dstW, dstH,
-           flags);
-    fflush(stdout);
-
+    sws_scale(srcContext, ref, refStride, 0, h   , src, srcStride);
     sws_scale(dstContext, src, srcStride, 0, srcH, dst, dstStride);
     sws_scale(outContext, dst, dstStride, 0, dstH, out, refStride);
 
@@ -153,15 +165,20 @@
     ssdV/= w*h/4;
     ssdA/= w*h;
 
-    printf(" SSD=%5"PRId64",%5"PRId64",%5"PRId64",%5"PRId64"\n",
-           ssdY, ssdU, ssdV, ssdA);
+    printf(" %s %dx%d -> %s %4dx%4d flags=%2d SSD=%5"PRId64",%5"PRId64",%5"PRId64",%5"PRId64"\n",
+           sws_format_name(srcFormat), srcW, srcH,
+           sws_format_name(dstFormat), dstW, dstH,
+           flags, ssdY, ssdU, ssdV, ssdA);
+    fflush(stdout);
 
 end:
 
+    sws_freeContext(srcContext);
     sws_freeContext(dstContext);
     sws_freeContext(outContext);
 
     for (i=0; i<4; i++) {
+        av_free(src[i]);
         av_free(dst[i]);
         av_free(out[i]);
     }
@@ -192,50 +209,15 @@
                 continue;
 
             printf("%s -> %s\n",
-                   av_pix_fmt_descriptors[srcFormat].name,
-                   av_pix_fmt_descriptors[dstFormat].name);
+                   sws_format_name(srcFormat),
+                   sws_format_name(dstFormat));
             fflush(stdout);
 
-            for (k = 0; flags[k] && !res; k++) {
-                struct SwsContext *srcContext = NULL;
-                uint8_t *src[4] = {0};
-                int srcStride[4];
-                int p;
-                for (p = 0; p < 4; p++) {
-                    if (srcFormat == PIX_FMT_RGB24 ||
-                        srcFormat == PIX_FMT_BGR24)
-                        srcStride[p] = srcW*3;
-                    else if (srcFormat==PIX_FMT_RGB48BE ||
-                             srcFormat==PIX_FMT_RGB48LE)
-                        srcStride[p] = srcW*6;
-                    else
-                        srcStride[p] = srcW*4;
-                    src[p] = av_mallocz(srcStride[p]*srcH+16);
-                    if (!src[p]) {
-                        perror("Malloc");
-                        return;
-                    }
-                }
-                srcContext = sws_getContext(w, h, PIX_FMT_YUVA420P, srcW, srcH,
-                                            srcFormat, flags[k], NULL, NULL, NULL);
-                if (!srcContext) {
-                   fprintf(stderr, "Failed to get %s ---> %s\n",
-                            av_pix_fmt_descriptors[PIX_FMT_YUVA420P].name,
-                            av_pix_fmt_descriptors[srcFormat].name);
-                   return;
-                }
-                sws_scale(srcContext, ref, refStride, 0, h, src, srcStride);
-
                 for (i = 0; dstW[i] && !res; i++)
                     for (j = 0; dstH[j] && !res; j++)
-                        res = doTest(ref, refStride, w, h, src, srcStride,
-                                     srcFormat, dstFormat,
+                    for (k = 0; flags[k] && !res; k++)
+                        res = doTest(ref, refStride, w, h, srcFormat, dstFormat,
                                      srcW, srcH, dstW[i], dstH[j], flags[k]);
-
-                sws_freeContext(srcContext);
-                for (p = 0; p < 4; p++)
-                    av_free(src[p]);
-            }
         }
     }
 }
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/swscale.c ffmpeg-for-2.2.5/libswscale/swscale.c
--- ffmpeg-r21659/libswscale/swscale.c	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/swscale.c	2010-02-07 11:46:28.000000000 -0700
@@ -3,19 +3,22 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * the C code (not assembly, mmx, ...) of this file can be used
+ * under the LGPL license too
  */
 
 /*
@@ -24,7 +27,7 @@
   {BGR,RGB}{1,4,8,15,16} support dithering
 
   unscaled special converters (YV12=I420=IYUV, Y800=Y8)
-  YV12 -> {BGR,RGB}{1,4,8,12,15,16,24,32}
+  YV12 -> {BGR,RGB}{1,4,8,15,16,24,32}
   x -> x
   YUV9 -> YV12
   YUV9/YV12 -> Y800
@@ -36,7 +39,7 @@
 
 /*
 tested special converters (most are tested actually, but I did not write it down ...)
- YV12 -> BGR12/BGR16
+ YV12 -> BGR16
  YV12 -> YV12
  BGR15 -> BGR16
  BGR16 -> BGR16
@@ -63,7 +66,6 @@
 #include "libavutil/intreadwrite.h"
 #include "libavutil/x86_cpu.h"
 #include "libavutil/avutil.h"
-#include "libavutil/mathematics.h"
 #include "libavutil/bswap.h"
 #include "libavutil/pixdesc.h"
 
@@ -78,12 +80,19 @@
 
 #define FAST_BGR2YV12 // use 7 bit coefficients instead of 15 bit
 
+#ifdef M_PI
+#define PI M_PI
+#else
+#define PI 3.14159265358979323846
+#endif
+
 #define isPacked(x)         (       \
            (x)==PIX_FMT_PAL8        \
         || (x)==PIX_FMT_YUYV422     \
         || (x)==PIX_FMT_UYVY422     \
         || isAnyRGB(x)              \
     )
+#define usePal(x) (av_pix_fmt_descriptors[x].flags & PIX_FMT_PAL)
 
 #define RGB2YUV_SHIFT 15
 #define BY ( (int)(0.114*219/255*(1<<RGB2YUV_SHIFT)+0.5))
@@ -97,14 +106,14 @@
 #define RU (-(int)(0.169*224/255*(1<<RGB2YUV_SHIFT)+0.5))
 
 static const double rgb2yuv_table[8][9]={
-    {0.7152, 0.0722, 0.2126, -0.386, 0.5, -0.115, -0.454, -0.046, 0.5}, //ITU709
-    {0.7152, 0.0722, 0.2126, -0.386, 0.5, -0.115, -0.454, -0.046, 0.5}, //ITU709
-    {0.587 , 0.114 , 0.299 , -0.331, 0.5, -0.169, -0.419, -0.081, 0.5}, //DEFAULT / ITU601 / ITU624 / SMPTE 170M
-    {0.587 , 0.114 , 0.299 , -0.331, 0.5, -0.169, -0.419, -0.081, 0.5}, //DEFAULT / ITU601 / ITU624 / SMPTE 170M
+    {0.7152, 0.0722, 0.2126, -0.386, 0.5, -0.115, -0.454, -0.046, 0.5},
+    {0.7152, 0.0722, 0.2126, -0.386, 0.5, -0.115, -0.454, -0.046, 0.5},
+    {0.587 , 0.114 , 0.299 , -0.331, 0.5, -0.169, -0.419, -0.081, 0.5},
+    {0.587 , 0.114 , 0.299 , -0.331, 0.5, -0.169, -0.419, -0.081, 0.5},
     {0.59  , 0.11  , 0.30  , -0.331, 0.5, -0.169, -0.421, -0.079, 0.5}, //FCC
-    {0.587 , 0.114 , 0.299 , -0.331, 0.5, -0.169, -0.419, -0.081, 0.5}, //DEFAULT / ITU601 / ITU624 / SMPTE 170M
-    {0.587 , 0.114 , 0.299 , -0.331, 0.5, -0.169, -0.419, -0.081, 0.5}, //DEFAULT / ITU601 / ITU624 / SMPTE 170M
-    {0.701 , 0.087 , 0.212 , -0.384, 0.5, -0.116, -0.445, -0.055, 0.5}, //SMPTE 240M
+    {0.587 , 0.114 , 0.299 , -0.331, 0.5, -0.169, -0.419, -0.081, 0.5},
+    {0.587 , 0.114 , 0.299 , -0.331, 0.5, -0.169, -0.419, -0.081, 0.5}, //SMPTE 170M
+    {0.701 , 0.087 , 0.212 , -0.384, 0.5  -0.116, -0.445, -0.055, 0.5}, //SMPTE 240M
 };
 
 /*
@@ -122,7 +131,7 @@
 write special BGR->BGR scaler
 */
 
-#if ARCH_X86
+#if ARCH_X86 && CONFIG_GPL
 DECLARE_ASM_CONST(8, uint64_t, bF8)=       0xF8F8F8F8F8F8F8F8LL;
 DECLARE_ASM_CONST(8, uint64_t, bFC)=       0xFCFCFCFCFCFCFCFCLL;
 DECLARE_ASM_CONST(8, uint64_t, w10)=       0x0010001000100010LL;
@@ -177,7 +186,7 @@
 
 DECLARE_ASM_CONST(8, uint64_t, ff_bgr24toUVOffset)= 0x0040400000404000ULL;
 
-#endif /* ARCH_X86 */
+#endif /* ARCH_X86 && CONFIG_GPL */
 
 DECLARE_ALIGNED(8, static const uint8_t, dither_2x2_4)[2][8]={
 {  1,   3,   1,   3,   1,   3,   1,   3, },
@@ -189,13 +198,6 @@
 {  0,   4,   0,   4,   0,   4,   0,   4, },
 };
 
-DECLARE_ALIGNED(8, const uint8_t, dither_4x4_16)[4][8]={
-{  8,   4,  11,   7,   8,   4,  11,   7, },
-{  2,  14,   1,  13,   2,  14,   1,  13, },
-{ 10,   6,   9,   5,  10,   6,   9,   5, },
-{  0,  12,   3,  15,   0,  12,   3,  15, },
-};
-
 DECLARE_ALIGNED(8, const uint8_t, dither_8x8_32)[8][8]={
 { 17,   9,  23,  15,  16,   8,  22,  14, },
 {  5,  29,   3,  27,   4,  28,   2,  26, },
@@ -763,10 +765,8 @@
             dest+=6;\
         }\
         break;\
-    case PIX_FMT_RGB565BE:\
-    case PIX_FMT_RGB565LE:\
-    case PIX_FMT_BGR565BE:\
-    case PIX_FMT_BGR565LE:\
+    case PIX_FMT_RGB565:\
+    case PIX_FMT_BGR565:\
         {\
             const int dr1= dither_2x2_8[y&1    ][0];\
             const int dg1= dither_2x2_4[y&1    ][0];\
@@ -780,10 +780,8 @@
             }\
         }\
         break;\
-    case PIX_FMT_RGB555BE:\
-    case PIX_FMT_RGB555LE:\
-    case PIX_FMT_BGR555BE:\
-    case PIX_FMT_BGR555LE:\
+    case PIX_FMT_RGB555:\
+    case PIX_FMT_BGR555:\
         {\
             const int dr1= dither_2x2_8[y&1    ][0];\
             const int dg1= dither_2x2_8[y&1    ][1];\
@@ -797,23 +795,6 @@
             }\
         }\
         break;\
-    case PIX_FMT_RGB444BE:\
-    case PIX_FMT_RGB444LE:\
-    case PIX_FMT_BGR444BE:\
-    case PIX_FMT_BGR444LE:\
-        {\
-            const int dr1= dither_4x4_16[y&3    ][0];\
-            const int dg1= dither_4x4_16[y&3    ][1];\
-            const int db1= dither_4x4_16[(y&3)^3][0];\
-            const int dr2= dither_4x4_16[y&3    ][1];\
-            const int dg2= dither_4x4_16[y&3    ][0];\
-            const int db2= dither_4x4_16[(y&3)^3][1];\
-            func(uint16_t,0)\
-                ((uint16_t*)dest)[i2+0]= r[Y1+dr1] + g[Y1+dg1] + b[Y1+db1];\
-                ((uint16_t*)dest)[i2+1]= r[Y2+dr2] + g[Y2+dg2] + b[Y2+db2];\
-            }\
-        }\
-        break;\
     case PIX_FMT_RGB8:\
     case PIX_FMT_BGR8:\
         {\
@@ -989,7 +970,7 @@
     }
 }
 
-static inline void rgb48ToY(uint8_t *dst, const uint8_t *src, long width,
+static inline void rgb48ToY(uint8_t *dst, const uint8_t *src, int width,
                             uint32_t *unused)
 {
     int i;
@@ -1004,7 +985,7 @@
 
 static inline void rgb48ToUV(uint8_t *dstU, uint8_t *dstV,
                              const uint8_t *src1, const uint8_t *src2,
-                             long width, uint32_t *unused)
+                             int width, uint32_t *unused)
 {
     int i;
     assert(src1==src2);
@@ -1020,7 +1001,7 @@
 
 static inline void rgb48ToUV_half(uint8_t *dstU, uint8_t *dstV,
                                   const uint8_t *src1, const uint8_t *src2,
-                                  long width, uint32_t *unused)
+                                  int width, uint32_t *unused)
 {
     int i;
     assert(src1==src2);
@@ -1146,27 +1127,27 @@
 
 //Note: we have C, MMX, MMX2, 3DNOW versions, there is no 3DNOW+MMX2 one
 //Plain C versions
-#if (!HAVE_MMX && !HAVE_ALTIVEC) || CONFIG_RUNTIME_CPUDETECT
+#if ((!HAVE_MMX || !CONFIG_GPL) && !HAVE_ALTIVEC) || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_C
 #endif
 
 #if ARCH_PPC
-#if HAVE_ALTIVEC
+#if HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_ALTIVEC
 #endif
 #endif //ARCH_PPC
 
 #if ARCH_X86
 
-#if (HAVE_MMX && !HAVE_AMD3DNOW && !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT
+#if ((HAVE_MMX && !HAVE_AMD3DNOW && !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
 #define COMPILE_MMX
 #endif
 
-#if HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT
+#if (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
 #define COMPILE_MMX2
 #endif
 
-#if (HAVE_AMD3DNOW && !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT
+#if ((HAVE_AMD3DNOW && !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
 #define COMPILE_3DNOW
 #endif
 #endif //ARCH_X86
@@ -1237,7 +1218,7 @@
 #if CONFIG_RUNTIME_CPUDETECT
     int flags = c->flags;
 
-#if ARCH_X86
+#if ARCH_X86 && CONFIG_GPL
     // ordered per speed fastest first
     if (flags & SWS_CPU_CAPS_MMX2) {
         sws_init_swScale_MMX2(c);
@@ -1254,7 +1235,7 @@
     }
 
 #else
-#ifdef COMPILE_ALTIVEC
+#if ARCH_PPC
     if (flags & SWS_CPU_CAPS_ALTIVEC) {
         sws_init_swScale_altivec(c);
         return swScale_altivec;
@@ -1265,7 +1246,7 @@
 #endif
     sws_init_swScale_C(c);
     return swScale_C;
-#endif /* ARCH_X86 */
+#endif /* ARCH_X86 && CONFIG_GPL */
 #else //CONFIG_RUNTIME_CPUDETECT
 #if   COMPILE_TEMPLATE_MMX2
     sws_init_swScale_MMX2(c);
@@ -1419,12 +1400,12 @@
 
     if (usePal(srcFormat)) {
         switch (dstFormat) {
-        case PIX_FMT_RGB32  : conv = sws_convertPalette8ToPacked32; break;
-        case PIX_FMT_BGR32  : conv = sws_convertPalette8ToPacked32; break;
-        case PIX_FMT_BGR32_1: conv = sws_convertPalette8ToPacked32; break;
-        case PIX_FMT_RGB32_1: conv = sws_convertPalette8ToPacked32; break;
-        case PIX_FMT_RGB24  : conv = sws_convertPalette8ToPacked24; break;
-        case PIX_FMT_BGR24  : conv = sws_convertPalette8ToPacked24; break;
+        case PIX_FMT_RGB32  : conv = palette8topacked32; break;
+        case PIX_FMT_BGR32  : conv = palette8topacked32; break;
+        case PIX_FMT_BGR32_1: conv = palette8topacked32; break;
+        case PIX_FMT_RGB32_1: conv = palette8topacked32; break;
+        case PIX_FMT_RGB24  : conv = palette8topacked24; break;
+        case PIX_FMT_BGR24  : conv = palette8topacked24; break;
         }
     }
 
@@ -1659,15 +1640,13 @@
 
                 for (i=0; i<height; i++) {
                     for (j=0; j<length; j++)
-                        ((uint16_t*)dstPtr)[j] = av_bswap16(((const uint16_t*)srcPtr)[j]);
+                        ((uint16_t*)dstPtr)[j] = bswap_16(((const uint16_t*)srcPtr)[j]);
                     srcPtr+= srcStride[plane];
                     dstPtr+= dstStride[plane];
                 }
-            } else if (dstStride[plane] == srcStride[plane] &&
-                       srcStride[plane] > 0 && srcStride[plane] == length) {
-                memcpy(dst[plane] + dstStride[plane]*y, src[plane],
-                       height*dstStride[plane]);
-            } else {
+            } else if (dstStride[plane]==srcStride[plane] && srcStride[plane] > 0)
+                memcpy(dst[plane] + dstStride[plane]*y, src[plane], height*dstStride[plane]);
+            else {
                 if(is16BPS(c->srcFormat) && is16BPS(c->dstFormat))
                     length*=2;
                 for (i=0; i<height; i++) {
@@ -1870,8 +1849,6 @@
                 r= (i>>3    )*255;
                 g= ((i>>1)&3)*85;
                 b= (i&1     )*255;
-            } else if(c->srcFormat == PIX_FMT_GRAY8) {
-                r = g = b = i;
             } else {
                 assert(c->srcFormat == PIX_FMT_BGR4_BYTE);
                 b= (i>>3    )*255;
@@ -1959,26 +1936,3 @@
     return sws_scale(c, src, srcStride, srcSliceY, srcSliceH, dst, dstStride);
 }
 #endif
-
-/* Convert the palette to the same packed 32-bit format as the palette */
-void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
-{
-    long i;
-
-    for (i=0; i<num_pixels; i++)
-        ((uint32_t *) dst)[i] = ((const uint32_t *) palette)[src[i]];
-}
-
-/* Palette format: ABCD -> dst format: ABC */
-void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
-{
-    long i;
-
-    for (i=0; i<num_pixels; i++) {
-        //FIXME slow?
-        dst[0]= palette[src[i]*4+0];
-        dst[1]= palette[src[i]*4+1];
-        dst[2]= palette[src[i]*4+2];
-        dst+= 3;
-    }
-}
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/swscale.h ffmpeg-for-2.2.5/libswscale/swscale.h
--- ffmpeg-r21659/libswscale/swscale.h	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/swscale.h	2010-02-07 11:46:28.000000000 -0700
@@ -22,7 +22,7 @@
 #define SWSCALE_SWSCALE_H
 
 /**
- * @file
+ * @file libswscale/swscale.h
  * @brief
  *     external api for the swscale stuff
  */
@@ -30,7 +30,7 @@
 #include "libavutil/avutil.h"
 
 #define LIBSWSCALE_VERSION_MAJOR 0
-#define LIBSWSCALE_VERSION_MINOR 11
+#define LIBSWSCALE_VERSION_MINOR 10
 #define LIBSWSCALE_VERSION_MICRO 0
 
 #define LIBSWSCALE_VERSION_INT  AV_VERSION_INT(LIBSWSCALE_VERSION_MAJOR, \
@@ -194,7 +194,6 @@
  */
 int sws_scale(struct SwsContext *context, const uint8_t* const srcSlice[], const int srcStride[],
               int srcSliceY, int srcSliceH, uint8_t* const dst[], const int dstStride[]);
-
 #if LIBSWSCALE_VERSION_MAJOR < 1
 /**
  * @deprecated Use sws_scale() instead.
@@ -303,29 +302,4 @@
                                         int flags, SwsFilter *srcFilter,
                                         SwsFilter *dstFilter, const double *param);
 
-/**
- * Converts an 8bit paletted frame into a frame with a color depth of 32-bits.
- *
- * The output frame will have the same packed format as the palette.
- *
- * @param src        source frame buffer
- * @param dst        destination frame buffer
- * @param num_pixels number of pixels to convert
- * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
- */
-void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-
-/**
- * Converts an 8bit paletted frame into a frame with a color depth of 24 bits.
- *
- * With the palette format "ABCD", the destination frame ends up with the format "ABC".
- *
- * @param src        source frame buffer
- * @param dst        destination frame buffer
- * @param num_pixels number of pixels to convert
- * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
- */
-void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-
-
 #endif /* SWSCALE_SWSCALE_H */
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/swscale_internal.h ffmpeg-for-2.2.5/libswscale/swscale_internal.h
--- ffmpeg-r21659/libswscale/swscale_internal.h	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/swscale_internal.h	2010-02-07 11:46:28.000000000 -0700
@@ -331,8 +331,8 @@
 SwsFunc ff_yuv2rgb_get_func_ptr_bfin(SwsContext *c);
 void ff_bfin_get_unscaled_swscale(SwsContext *c);
 void ff_yuv2packedX_altivec(SwsContext *c,
-                            const int16_t *lumFilter, const int16_t **lumSrc, int lumFilterSize,
-                            const int16_t *chrFilter, const int16_t **chrSrc, int chrFilterSize,
+                            const int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
+                            const int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
                             uint8_t *dest, int dstW, int dstY);
 
 const char *sws_format_name(enum PixelFormat format);
@@ -391,12 +391,8 @@
         || (x)==PIX_FMT_RGB32       \
         || (x)==PIX_FMT_RGB32_1     \
         || (x)==PIX_FMT_RGB24       \
-        || (x)==PIX_FMT_RGB565BE    \
-        || (x)==PIX_FMT_RGB565LE    \
-        || (x)==PIX_FMT_RGB555BE    \
-        || (x)==PIX_FMT_RGB555LE    \
-        || (x)==PIX_FMT_RGB444BE    \
-        || (x)==PIX_FMT_RGB444LE    \
+        || (x)==PIX_FMT_RGB565      \
+        || (x)==PIX_FMT_RGB555      \
         || (x)==PIX_FMT_RGB8        \
         || (x)==PIX_FMT_RGB4        \
         || (x)==PIX_FMT_RGB4_BYTE   \
@@ -407,12 +403,8 @@
            (x)==PIX_FMT_BGR32       \
         || (x)==PIX_FMT_BGR32_1     \
         || (x)==PIX_FMT_BGR24       \
-        || (x)==PIX_FMT_BGR565BE    \
-        || (x)==PIX_FMT_BGR565LE    \
-        || (x)==PIX_FMT_BGR555BE    \
-        || (x)==PIX_FMT_BGR555LE    \
-        || (x)==PIX_FMT_BGR444BE    \
-        || (x)==PIX_FMT_BGR444LE    \
+        || (x)==PIX_FMT_BGR565      \
+        || (x)==PIX_FMT_BGR555      \
         || (x)==PIX_FMT_BGR8        \
         || (x)==PIX_FMT_BGR4        \
         || (x)==PIX_FMT_BGR4_BYTE   \
@@ -442,7 +434,6 @@
         || (x)==PIX_FMT_RGB32_1     \
         || (x)==PIX_FMT_YUVA420P    \
     )
-#define usePal(x) (av_pix_fmt_descriptors[x].flags & PIX_FMT_PAL)
 
 extern const uint64_t ff_dither4[2];
 extern const uint64_t ff_dither8[2];
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/swscale_template.c ffmpeg-for-2.2.5/libswscale/swscale_template.c
--- ffmpeg-r21659/libswscale/swscale_template.c	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/swscale_template.c	2010-02-07 11:46:28.000000000 -0700
@@ -3,19 +3,22 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * The C code (not assembly, MMX, ...) of this file can be used
+ * under the LGPL license.
  */
 
 #undef REAL_MOVNTQ
@@ -80,7 +83,7 @@
         "mov                        (%%"REG_d"), %%"REG_S"  \n\t"\
         "jb                                  1b             \n\t"\
         :: "r" (&c->redDither),\
-        "r" (dest), "g" ((x86_reg)width)\
+        "r" (dest), "g" (width)\
         : "%"REG_a, "%"REG_d, "%"REG_S\
     );
 
@@ -142,7 +145,7 @@
         "mov                        (%%"REG_d"), %%"REG_S"  \n\t"\
         "jb                                  1b             \n\t"\
         :: "r" (&c->redDither),\
-        "r" (dest), "g" ((x86_reg)width)\
+        "r" (dest), "g" (width)\
         : "%"REG_a, "%"REG_d, "%"REG_S\
     );
 
@@ -180,7 +183,7 @@
 /*
     :: "m" (-lumFilterSize), "m" (-chrFilterSize),
        "m" (lumMmxFilter+lumFilterSize*4), "m" (chrMmxFilter+chrFilterSize*4),
-       "r" (dest), "m" (dstW_reg),
+       "r" (dest), "m" (dstW),
        "m" (lumSrc+lumFilterSize), "m" (chrSrc+chrFilterSize)
     : "%eax", "%ebx", "%ecx", "%edx", "%esi"
 */
@@ -234,7 +237,7 @@
 #define YSCALEYUV2PACKEDX_END                     \
         :: "r" (&c->redDither),                   \
             "m" (dummy), "m" (dummy), "m" (dummy),\
-            "r" (dest), "m" (dstW_reg)            \
+            "r" (dest), "m" (dstW)                \
         : "%"REG_a, "%"REG_d, "%"REG_S            \
     );
 
@@ -1025,7 +1028,6 @@
 {
 #if COMPILE_TEMPLATE_MMX
     x86_reg dummy=0;
-    x86_reg dstW_reg = dstW;
     if(!(c->flags & SWS_BITEXACT)) {
         if (c->flags & SWS_ACCURATE_RND) {
             switch(c->dstFormat) {
@@ -1064,7 +1066,7 @@
 
                 :: "r" (&c->redDither),
                 "m" (dummy), "m" (dummy), "m" (dummy),
-                "r" (dest), "m" (dstW_reg)
+                "r" (dest), "m" (dstW)
                 : "%"REG_a, "%"REG_c, "%"REG_d, "%"REG_S
                 );
                 return;
@@ -1138,7 +1140,7 @@
 
                 :: "r" (&c->redDither),
                 "m" (dummy), "m" (dummy), "m" (dummy),
-                "r" (dest),  "m" (dstW_reg)
+                "r" (dest),  "m" (dstW)
                 : "%"REG_a, "%"REG_c, "%"REG_d, "%"REG_S
                 );
                 return;
@@ -2209,7 +2211,7 @@
         dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...
         //dst[i] = val>>7;
     }
-#endif /* COMPILE_TEMPLATE_ALTIVEC */
+#endif /* COMPILE_ALTIVEC */
 #endif /* COMPILE_MMX */
 }
 
@@ -2256,7 +2258,7 @@
                                         long dstWidth, const uint8_t *src, int srcW,
                                         int xInc)
 {
-#if ARCH_X86
+#if ARCH_X86 && CONFIG_GPL
 #if COMPILE_TEMPLATE_MMX2
     int32_t *filterPos = c->hLumFilterPos;
     int16_t *filter    = c->hLumFilter;
@@ -2329,7 +2331,6 @@
 #endif /* COMPILE_TEMPLATE_MMX2 */
     x86_reg xInc_shr16 = xInc >> 16;
     uint16_t xInc_mask = xInc & 0xffff;
-    x86_reg dstWidth_reg = dstWidth;
     //NO MMX just normal asm ...
     __asm__ volatile(
         "xor %%"REG_a", %%"REG_a"            \n\t" // i
@@ -2357,7 +2358,7 @@
         " jb        1b                       \n\t"
 
 
-        :: "r" (src), "m" (dst), "m" (dstWidth_reg), "m" (xInc_shr16), "m" (xInc_mask)
+        :: "r" (src), "m" (dst), "m" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask)
         : "%"REG_a, "%"REG_d, "%ecx", "%"REG_D, "%esi"
     );
 #if COMPILE_TEMPLATE_MMX2
@@ -2406,7 +2407,7 @@
                                         long dstWidth, const uint8_t *src1,
                                         const uint8_t *src2, int srcW, int xInc)
 {
-#if ARCH_X86
+#if ARCH_X86 && CONFIG_GPL
 #if COMPILE_TEMPLATE_MMX2
     int32_t *filterPos = c->hChrFilterPos;
     int16_t *filter    = c->hChrFilter;
@@ -2470,7 +2471,6 @@
 #endif /* COMPILE_TEMPLATE_MMX2 */
         x86_reg xInc_shr16 = (x86_reg) (xInc >> 16);
         uint16_t xInc_mask = xInc & 0xffff;
-        x86_reg dstWidth_reg = dstWidth;
         __asm__ volatile(
             "xor %%"REG_a", %%"REG_a"               \n\t" // i
             "xor %%"REG_d", %%"REG_d"               \n\t" // xx
@@ -2497,9 +2497,9 @@
 /* GCC 3.3 makes MPlayer crash on IA-32 machines when using "g" operand here,
 which is needed to support GCC 4.0. */
 #if ARCH_X86_64 && AV_GCC_VERSION_AT_LEAST(3,4)
-            :: "m" (src1), "m" (dst), "g" (dstWidth_reg), "m" (xInc_shr16), "m" (xInc_mask),
+            :: "m" (src1), "m" (dst), "g" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask),
 #else
-            :: "m" (src1), "m" (dst), "m" (dstWidth_reg), "m" (xInc_shr16), "m" (xInc_mask),
+            :: "m" (src1), "m" (dst), "m" (dstWidth), "m" (xInc_shr16), "m" (xInc_mask),
 #endif
             "r" (src2)
             : "%"REG_a, "%"REG_d, "%ecx", "%"REG_D, "%esi"
@@ -2651,10 +2651,8 @@
         unsigned char *aDest=(CONFIG_SWSCALE_ALPHA && alpPixBuf) ? dst[3]+dstStride[3]*dstY : NULL;
 
         const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input
-        const int firstLumSrcY2= vLumFilterPos[FFMIN(dstY | ((1<<c->chrDstVSubSample) - 1), dstH-1)];
         const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input
         int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input
-        int lastLumSrcY2=firstLumSrcY2+ vLumFilterSize -1; // Last line needed as input
         int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input
         int enough_lines;
 
@@ -2664,27 +2662,26 @@
         assert(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1);
         assert(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1);
 
-        DEBUG_BUFFERS("dstY: %d\n", dstY);
-        DEBUG_BUFFERS("\tfirstLumSrcY: %d lastLumSrcY: %d lastInLumBuf: %d\n",
-                         firstLumSrcY,    lastLumSrcY,    lastInLumBuf);
-        DEBUG_BUFFERS("\tfirstChrSrcY: %d lastChrSrcY: %d lastInChrBuf: %d\n",
-                         firstChrSrcY,    lastChrSrcY,    lastInChrBuf);
-
         // Do we have enough lines in this slice to output the dstY line
-        enough_lines = lastLumSrcY2 < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample);
-
+        enough_lines = lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample);
         if (!enough_lines) {
             lastLumSrcY = srcSliceY + srcSliceH - 1;
             lastChrSrcY = chrSrcSliceY + chrSrcSliceH - 1;
-            DEBUG_BUFFERS("buffering slice: lastLumSrcY %d lastChrSrcY %d\n",
-                                            lastLumSrcY, lastChrSrcY);
         }
 
+        DEBUG_BUFFERS("dstY: %d\n", dstY);
+        DEBUG_BUFFERS("\tfirstLumSrcY: %d lastLumSrcY: %d lastInLumBuf: %d\n",
+                         firstLumSrcY,    lastLumSrcY,    lastInLumBuf);
+        DEBUG_BUFFERS("\tfirstChrSrcY: %d lastChrSrcY: %d lastInChrBuf: %d\n",
+                         firstChrSrcY,    lastChrSrcY,    lastInChrBuf);
+
         //Do horizontal scaling
         while(lastInLumBuf < lastLumSrcY) {
             const uint8_t *src1= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];
             const uint8_t *src2= src[3]+(lastInLumBuf + 1 - srcSliceY)*srcStride[3];
             lumBufIndex++;
+            DEBUG_BUFFERS("\t\tlumBufIndex %d: lastInLumBuf: %d\n",
+                               lumBufIndex,    lastInLumBuf);
             assert(lumBufIndex < 2*vLumBufSize);
             assert(lastInLumBuf + 1 - srcSliceY < srcSliceH);
             assert(lastInLumBuf + 1 - srcSliceY >= 0);
@@ -2698,13 +2695,13 @@
                                 formatConvBuffer,
                                 pal, 1);
             lastInLumBuf++;
-            DEBUG_BUFFERS("\t\tlumBufIndex %d: lastInLumBuf: %d\n",
-                               lumBufIndex,    lastInLumBuf);
         }
         while(lastInChrBuf < lastChrSrcY) {
             const uint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];
             const uint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];
             chrBufIndex++;
+            DEBUG_BUFFERS("\t\tchrBufIndex %d: lastInChrBuf: %d\n",
+                               chrBufIndex,    lastInChrBuf);
             assert(chrBufIndex < 2*vChrBufSize);
             assert(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH));
             assert(lastInChrBuf + 1 - chrSrcSliceY >= 0);
@@ -2716,8 +2713,6 @@
                                 formatConvBuffer,
                                 pal);
             lastInChrBuf++;
-            DEBUG_BUFFERS("\t\tchrBufIndex %d: lastInChrBuf: %d\n",
-                               chrBufIndex,    lastInChrBuf);
         }
         //wrap buf index around to stay inside the ring buffer
         if (lumBufIndex >= vLumBufSize) lumBufIndex-= vLumBufSize;
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/utils.c ffmpeg-for-2.2.5/libswscale/utils.c
--- ffmpeg-r21659/libswscale/utils.c	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/utils.c	2010-02-07 11:46:28.000000000 -0700
@@ -3,23 +3,25 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * the C code (not assembly, mmx, ...) of this file can be used
+ * under the LGPL license too
  */
 
 #define _SVID_SOURCE //needed for MAP_ANONYMOUS
-#define _DARWIN_C_SOURCE // needed for MAP_ANON
 #include <inttypes.h>
 #include <string.h>
 #include <math.h>
@@ -148,6 +150,8 @@
     return isSupportedOut(pix_fmt);
 }
 
+#define usePal(x) (av_pix_fmt_descriptors[x].flags & PIX_FMT_PAL)
+
 extern const int32_t ff_yuv2rgb_coeffs[8][4];
 
 const char *sws_format_name(enum PixelFormat format)
@@ -288,7 +292,7 @@
                 }
 /*                else if (flags & SWS_X) {
                     double p= param ? param*0.01 : 0.3;
-                    coeff = d ? sin(d*M_PI)/(d*M_PI) : 1.0;
+                    coeff = d ? sin(d*PI)/(d*PI) : 1.0;
                     coeff*= pow(2.0, - p*d*d);
                 }*/
                 else if (flags & SWS_X) {
@@ -506,7 +510,7 @@
     return ret;
 }
 
-#if ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT)
+#if ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
 static int initMMX2HScaler(int dstW, int xInc, uint8_t *filterCode, int16_t *filter, int32_t *filterPos, int numSplits)
 {
     uint8_t *fragmentA;
@@ -664,7 +668,7 @@
 
     return fragmentPos + 1;
 }
-#endif /* ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) */
+#endif /* ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL */
 
 static void getSubSampleFactors(int *h, int *v, enum PixelFormat format)
 {
@@ -672,8 +676,23 @@
     *v = av_pix_fmt_descriptors[format].log2_chroma_h;
 }
 
+static uint16_t roundToInt16(int64_t f)
+{
+    int r= (f + (1<<15))>>16;
+         if (r<-0x7FFF) return 0x8000;
+    else if (r> 0x7FFF) return 0x7FFF;
+    else                return r;
+}
+
 int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
 {
+    int64_t crv =  inv_table[0];
+    int64_t cbu =  inv_table[1];
+    int64_t cgu = -inv_table[2];
+    int64_t cgv = -inv_table[3];
+    int64_t cy  = 1<<16;
+    int64_t oy  = 0;
+
     memcpy(c->srcColorspaceTable, inv_table, sizeof(int)*4);
     memcpy(c->dstColorspaceTable,     table, sizeof(int)*4);
 
@@ -684,10 +703,45 @@
     c->dstRange  = dstRange;
     if (isYUV(c->dstFormat) || isGray(c->dstFormat)) return -1;
 
+    c->uOffset=   0x0400040004000400LL;
+    c->vOffset=   0x0400040004000400LL;
+
+    if (!srcRange) {
+        cy= (cy*255) / 219;
+        oy= 16<<16;
+    } else {
+        crv= (crv*224) / 255;
+        cbu= (cbu*224) / 255;
+        cgu= (cgu*224) / 255;
+        cgv= (cgv*224) / 255;
+    }
+
+    cy = (cy *contrast             )>>16;
+    crv= (crv*contrast * saturation)>>32;
+    cbu= (cbu*contrast * saturation)>>32;
+    cgu= (cgu*contrast * saturation)>>32;
+    cgv= (cgv*contrast * saturation)>>32;
+
+    oy -= 256*brightness;
+
+    c->yCoeff=    roundToInt16(cy *8192) * 0x0001000100010001ULL;
+    c->vrCoeff=   roundToInt16(crv*8192) * 0x0001000100010001ULL;
+    c->ubCoeff=   roundToInt16(cbu*8192) * 0x0001000100010001ULL;
+    c->vgCoeff=   roundToInt16(cgv*8192) * 0x0001000100010001ULL;
+    c->ugCoeff=   roundToInt16(cgu*8192) * 0x0001000100010001ULL;
+    c->yOffset=   roundToInt16(oy *   8) * 0x0001000100010001ULL;
+
+    c->yuv2rgb_y_coeff  = (int16_t)roundToInt16(cy <<13);
+    c->yuv2rgb_y_offset = (int16_t)roundToInt16(oy << 9);
+    c->yuv2rgb_v2r_coeff= (int16_t)roundToInt16(crv<<13);
+    c->yuv2rgb_v2g_coeff= (int16_t)roundToInt16(cgv<<13);
+    c->yuv2rgb_u2g_coeff= (int16_t)roundToInt16(cgu<<13);
+    c->yuv2rgb_u2b_coeff= (int16_t)roundToInt16(cbu<<13);
+
     ff_yuv2rgb_c_init_tables(c, inv_table, srcRange, brightness, contrast, saturation);
     //FIXME factorize
 
-#if HAVE_ALTIVEC
+#if ARCH_PPC && (HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT)
     if (c->flags & SWS_CPU_CAPS_ALTIVEC)
         ff_yuv2rgb_init_tables_altivec(c, inv_table, brightness, contrast, saturation);
 #endif
@@ -712,11 +766,20 @@
 static int handle_jpeg(enum PixelFormat *format)
 {
     switch (*format) {
-    case PIX_FMT_YUVJ420P: *format = PIX_FMT_YUV420P; return 1;
-    case PIX_FMT_YUVJ422P: *format = PIX_FMT_YUV422P; return 1;
-    case PIX_FMT_YUVJ444P: *format = PIX_FMT_YUV444P; return 1;
-    case PIX_FMT_YUVJ440P: *format = PIX_FMT_YUV440P; return 1;
-    default:                                          return 0;
+    case PIX_FMT_YUVJ420P:
+        *format = PIX_FMT_YUV420P;
+        return 1;
+    case PIX_FMT_YUVJ422P:
+        *format = PIX_FMT_YUV422P;
+        return 1;
+    case PIX_FMT_YUVJ444P:
+        *format = PIX_FMT_YUV444P;
+        return 1;
+    case PIX_FMT_YUVJ440P:
+        *format = PIX_FMT_YUV440P;
+        return 1;
+    default:
+        return 0;
     }
 }
 
@@ -724,6 +787,7 @@
                            int dstW, int dstH, enum PixelFormat dstFormat, int flags,
                            SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
 {
+
     SwsContext *c;
     int i;
     int usesVFilter, usesHFilter;
@@ -890,7 +954,7 @@
 
     /* precalculate horizontal scaler filter coefficients */
     {
-#if ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT)
+#if ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL
 // can't downscale !!!
         if (c->canMMX2BeUsed && (flags & SWS_FAST_BILINEAR)) {
             c->lumMmx2FilterCodeSize = initMMX2HScaler(      dstW, c->lumXInc, NULL, NULL, NULL, 8);
@@ -907,8 +971,6 @@
             c->chrMmx2FilterCode = av_malloc(c->chrMmx2FilterCodeSize);
 #endif
 
-            if (!c->lumMmx2FilterCode || !c->chrMmx2FilterCode)
-                goto fail;
             FF_ALLOCZ_OR_GOTO(c, c->hLumFilter   , (dstW        /8+8)*sizeof(int16_t), fail);
             FF_ALLOCZ_OR_GOTO(c, c->hChrFilter   , (c->chrDstW  /4+8)*sizeof(int16_t), fail);
             FF_ALLOCZ_OR_GOTO(c, c->hLumFilterPos, (dstW      /2/8+8)*sizeof(int32_t), fail);
@@ -922,7 +984,7 @@
             mprotect(c->chrMmx2FilterCode, c->chrMmx2FilterCodeSize, PROT_EXEC | PROT_READ);
 #endif
         } else
-#endif /* ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) */
+#endif /* ARCH_X86 && (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) && CONFIG_GPL */
         {
             const int filterAlign=
                 (flags & SWS_CPU_CAPS_MMX) ? 4 :
@@ -960,7 +1022,7 @@
                        srcFilter->chrV, dstFilter->chrV, c->param) < 0)
             goto fail;
 
-#if HAVE_ALTIVEC
+#if ARCH_PPC && (HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT)
         FF_ALLOC_OR_GOTO(c, c->vYCoeffsBank, sizeof (vector signed short)*c->vLumFilterSize*c->dstH, fail);
         FF_ALLOC_OR_GOTO(c, c->vCCoeffsBank, sizeof (vector signed short)*c->vChrFilterSize*c->chrDstH, fail);
 
@@ -1054,9 +1116,7 @@
         av_log(c, AV_LOG_INFO, "from %s to %s%s ",
                sws_format_name(srcFormat),
 #ifdef DITHER1XBPP
-               dstFormat == PIX_FMT_BGR555 || dstFormat == PIX_FMT_BGR565 ||
-               dstFormat == PIX_FMT_RGB444BE || dstFormat == PIX_FMT_RGB444LE ||
-               dstFormat == PIX_FMT_BGR444BE || dstFormat == PIX_FMT_BGR444LE ? "dithered " : "",
+               dstFormat == PIX_FMT_BGR555 || dstFormat == PIX_FMT_BGR565 ? "dithered " : "",
 #else
                "",
 #endif
@@ -1125,9 +1185,6 @@
             av_log(c, AV_LOG_VERBOSE, "using %s YV12->BGR16 converter\n", (flags & SWS_CPU_CAPS_MMX) ? "MMX" : "C");
         else if (dstFormat==PIX_FMT_BGR555)
             av_log(c, AV_LOG_VERBOSE, "using %s YV12->BGR15 converter\n", (flags & SWS_CPU_CAPS_MMX) ? "MMX" : "C");
-        else if (dstFormat == PIX_FMT_RGB444BE || dstFormat == PIX_FMT_RGB444LE ||
-                 dstFormat == PIX_FMT_BGR444BE || dstFormat == PIX_FMT_BGR444LE)
-            av_log(c, AV_LOG_VERBOSE, "using %s YV12->BGR12 converter\n", (flags & SWS_CPU_CAPS_MMX) ? "MMX" : "C");
 
         av_log(c, AV_LOG_VERBOSE, "%dx%d -> %dx%d\n", srcW, srcH, dstW, dstH);
         av_log(c, AV_LOG_DEBUG, "lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n",
@@ -1255,7 +1312,7 @@
     return sws_getConstVec(1.0, 1);
 }
 
-static double sws_dcVec(SwsVector *a)
+double sws_dcVec(SwsVector *a)
 {
     int i;
     double sum=0;
@@ -1469,7 +1526,7 @@
     av_freep(&c->vChrFilter);
     av_freep(&c->hLumFilter);
     av_freep(&c->hChrFilter);
-#if HAVE_ALTIVEC
+#if ARCH_PPC && (HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT)
     av_freep(&c->vYCoeffsBank);
     av_freep(&c->vCCoeffsBank);
 #endif
@@ -1479,20 +1536,20 @@
     av_freep(&c->hLumFilterPos);
     av_freep(&c->hChrFilterPos);
 
-#if ARCH_X86
+#if ARCH_X86 && CONFIG_GPL
 #ifdef MAP_ANONYMOUS
     if (c->lumMmx2FilterCode) munmap(c->lumMmx2FilterCode, c->lumMmx2FilterCodeSize);
     if (c->chrMmx2FilterCode) munmap(c->chrMmx2FilterCode, c->chrMmx2FilterCodeSize);
 #elif HAVE_VIRTUALALLOC
-    if (c->lumMmx2FilterCode) VirtualFree(c->lumMmx2FilterCode, 0, MEM_RELEASE);
-    if (c->chrMmx2FilterCode) VirtualFree(c->chrMmx2FilterCode, 0, MEM_RELEASE);
+    if (c->lumMmx2FilterCode) VirtualFree(c->lumMmx2FilterCode, c->lumMmx2FilterCodeSize, MEM_RELEASE);
+    if (c->chrMmx2FilterCode) VirtualFree(c->chrMmx2FilterCode, c->chrMmx2FilterCodeSize, MEM_RELEASE);
 #else
     av_free(c->lumMmx2FilterCode);
     av_free(c->chrMmx2FilterCode);
 #endif
     c->lumMmx2FilterCode=NULL;
     c->chrMmx2FilterCode=NULL;
-#endif /* ARCH_X86 */
+#endif /* ARCH_X86 && CONFIG_GPL */
 
     av_freep(&c->yuvTable);
 
@@ -1509,20 +1566,17 @@
     if (!param)
         param = default_param;
 
-    if (context &&
-        (context->srcW      != srcW      ||
-         context->srcH      != srcH      ||
+    if (context) {
+        if (context->srcW != srcW || context->srcH != srcH ||
          context->srcFormat != srcFormat ||
-         context->dstW      != dstW      ||
-         context->dstH      != dstH      ||
-         context->dstFormat != dstFormat ||
-         context->flags     != flags     ||
-         context->param[0]  != param[0]  ||
-         context->param[1]  != param[1])) {
+            context->dstW != dstW || context->dstH != dstH ||
+            context->dstFormat != dstFormat || context->flags != flags ||
+            context->param[0] != param[0] || context->param[1] != param[1])
+        {
         sws_freeContext(context);
         context = NULL;
     }
-
+    }
     if (!context) {
         return sws_getContext(srcW, srcH, srcFormat,
                               dstW, dstH, dstFormat, flags,
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/x86/yuv2rgb_mmx.c ffmpeg-for-2.2.5/libswscale/x86/yuv2rgb_mmx.c
--- ffmpeg-r21659/libswscale/x86/yuv2rgb_mmx.c	2010-08-03 08:01:11.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/x86/yuv2rgb_mmx.c	2010-02-07 11:46:28.000000000 -0700
@@ -41,9 +41,6 @@
 DECLARE_ASM_CONST(8, uint64_t, mmx_00ffw)   = 0x00ff00ff00ff00ffULL;
 DECLARE_ASM_CONST(8, uint64_t, mmx_redmask) = 0xf8f8f8f8f8f8f8f8ULL;
 DECLARE_ASM_CONST(8, uint64_t, mmx_grnmask) = 0xfcfcfcfcfcfcfcfcULL;
-DECLARE_ASM_CONST(8, uint64_t, pb_e0) = 0xe0e0e0e0e0e0e0e0ULL;
-DECLARE_ASM_CONST(8, uint64_t, pb_03) = 0x0303030303030303ULL;
-DECLARE_ASM_CONST(8, uint64_t, pb_07) = 0x0707070707070707ULL;
 
 //MMX versions
 #undef RENAME
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/x86/yuv2rgb_template.c ffmpeg-for-2.2.5/libswscale/x86/yuv2rgb_template.c
--- ffmpeg-r21659/libswscale/x86/yuv2rgb_template.c	2010-08-03 08:01:11.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/x86/yuv2rgb_template.c	2010-02-07 11:46:28.000000000 -0700
@@ -1,23 +1,28 @@
 /*
- * software YUV to RGB converter
+ * yuv2rgb_mmx.c, software YUV to RGB converter with Intel MMX "technology"
  *
- * Copyright (C) 2001-2007 Michael Niedermayer
- *           (c) 2010 Konstantin Shishkov
+ * Copyright (C) 2000, Silicon Integrated System Corp
  *
- * This file is part of FFmpeg.
+ * Author: Olie Lho <ollie@sis.com.tw>
  *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * 15,24 bpp and dithering from Michael Niedermayer (michaelni@gmx.at)
+ * MMX/MMX2 Template stuff from Michael Niedermayer (needed for fast movntq support)
+ * context / deglobalize stuff by Michael Niedermayer
  *
- * FFmpeg is distributed in the hope that it will be useful,
+ * This file is part of mpeg2dec, a free MPEG-2 video decoder
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU General Public License
+ * along with mpeg2dec; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -40,22 +45,93 @@
 #define SFENCE " # nop"
 #endif
 
-#define REG_BLUE  "0"
-#define REG_RED   "1"
-#define REG_GREEN "2"
-#define REG_ALPHA "3"
-
-#define YUV2RGB_LOOP(depth)                                          \
-    h_size = (c->dstW + 7) & ~7;                                     \
-    if (h_size * depth > FFABS(dstStride[0]))                        \
-        h_size -= 8;                                                 \
+#define YUV2RGB \
+    /* Do the multiply part of the conversion for even and odd pixels,
+       register usage:
+       mm0 -> Cblue, mm1 -> Cred, mm2 -> Cgreen even pixels,
+       mm3 -> Cblue, mm4 -> Cred, mm5 -> Cgreen odd pixels,
+       mm6 -> Y even, mm7 -> Y odd */\
+    /* convert the chroma part */\
+    "punpcklbw %%mm4, %%mm0;" /* scatter 4 Cb 00 u3 00 u2 00 u1 00 u0 */ \
+    "punpcklbw %%mm4, %%mm1;" /* scatter 4 Cr 00 v3 00 v2 00 v1 00 v0 */ \
+\
+    "psllw $3, %%mm0;" /* Promote precision */ \
+    "psllw $3, %%mm1;" /* Promote precision */ \
+\
+    "psubsw "U_OFFSET"(%4), %%mm0;" /* Cb -= 128 */ \
+    "psubsw "V_OFFSET"(%4), %%mm1;" /* Cr -= 128 */ \
+\
+    "movq %%mm0, %%mm2;" /* Copy 4 Cb 00 u3 00 u2 00 u1 00 u0 */ \
+    "movq %%mm1, %%mm3;" /* Copy 4 Cr 00 v3 00 v2 00 v1 00 v0 */ \
+\
+    "pmulhw "UG_COEFF"(%4), %%mm2;" /* Mul Cb with green coeff -> Cb green */ \
+    "pmulhw "VG_COEFF"(%4), %%mm3;" /* Mul Cr with green coeff -> Cr green */ \
+\
+    "pmulhw "UB_COEFF"(%4), %%mm0;" /* Mul Cb -> Cblue 00 b3 00 b2 00 b1 00 b0 */\
+    "pmulhw "VR_COEFF"(%4), %%mm1;" /* Mul Cr -> Cred 00 r3 00 r2 00 r1 00 r0 */\
+\
+    "paddsw %%mm3, %%mm2;" /* Cb green + Cr green -> Cgreen */\
+\
+    /* convert the luma part */\
+    "movq %%mm6, %%mm7;" /* Copy 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
+    "pand "MANGLE(mmx_00ffw)", %%mm6;" /* get Y even 00 Y6 00 Y4 00 Y2 00 Y0 */\
+\
+    "psrlw $8, %%mm7;" /* get Y odd 00 Y7 00 Y5 00 Y3 00 Y1 */\
+\
+    "psllw $3, %%mm6;" /* Promote precision */\
+    "psllw $3, %%mm7;" /* Promote precision */\
+\
+    "psubw "Y_OFFSET"(%4), %%mm6;" /* Y -= 16 */\
+    "psubw "Y_OFFSET"(%4), %%mm7;" /* Y -= 16 */\
+\
+    "pmulhw "Y_COEFF"(%4), %%mm6;" /* Mul 4 Y even 00 y6 00 y4 00 y2 00 y0 */\
+    "pmulhw "Y_COEFF"(%4), %%mm7;" /* Mul 4 Y odd 00 y7 00 y5 00 y3 00 y1 */\
+\
+    /* Do the addition part of the conversion for even and odd pixels,
+       register usage:
+       mm0 -> Cblue, mm1 -> Cred, mm2 -> Cgreen even pixels,
+       mm3 -> Cblue, mm4 -> Cred, mm5 -> Cgreen odd pixels,
+       mm6 -> Y even, mm7 -> Y odd */\
+    "movq %%mm0, %%mm3;" /* Copy Cblue */\
+    "movq %%mm1, %%mm4;" /* Copy Cred */\
+    "movq %%mm2, %%mm5;" /* Copy Cgreen */\
+\
+    "paddsw %%mm6, %%mm0;" /* Y even + Cblue 00 B6 00 B4 00 B2 00 B0 */\
+    "paddsw %%mm7, %%mm3;" /* Y odd + Cblue 00 B7 00 B5 00 B3 00 B1 */\
+\
+    "paddsw %%mm6, %%mm1;" /* Y even + Cred 00 R6 00 R4 00 R2 00 R0 */\
+    "paddsw %%mm7, %%mm4;" /* Y odd + Cred 00 R7 00 R5 00 R3 00 R1 */\
+\
+    "paddsw %%mm6, %%mm2;" /* Y even + Cgreen 00 G6 00 G4 00 G2 00 G0 */\
+    "paddsw %%mm7, %%mm5;" /* Y odd + Cgreen 00 G7 00 G5 00 G3 00 G1 */\
+\
+    /* Limit RGB even to 0..255 */\
+    "packuswb %%mm0, %%mm0;" /* B6 B4 B2 B0  B6 B4 B2 B0 */\
+    "packuswb %%mm1, %%mm1;" /* R6 R4 R2 R0  R6 R4 R2 R0 */\
+    "packuswb %%mm2, %%mm2;" /* G6 G4 G2 G0  G6 G4 G2 G0 */\
+\
+    /* Limit RGB odd to 0..255 */\
+    "packuswb %%mm3, %%mm3;" /* B7 B5 B3 B1  B7 B5 B3 B1 */\
+    "packuswb %%mm4, %%mm4;" /* R7 R5 R3 R1  R7 R5 R3 R1 */\
+    "packuswb %%mm5, %%mm5;" /* G7 G5 G3 G1  G7 G5 G3 G1 */\
                                                                      \
+    /* Interleave RGB even and odd */\
+    "punpcklbw %%mm3, %%mm0;" /* B7 B6 B5 B4 B3 B2 B1 B0 */\
+    "punpcklbw %%mm4, %%mm1;" /* R7 R6 R5 R4 R3 R2 R1 R0 */\
+    "punpcklbw %%mm5, %%mm2;" /* G7 G6 G5 G4 G3 G2 G1 G0 */\
+
+
+#define YUV422_UNSHIFT                   \
     if (c->srcFormat == PIX_FMT_YUV422P) {                           \
         srcStride[1] *= 2;                                           \
         srcStride[2] *= 2;                                           \
     }                                                                \
+
+#define YUV2RGB_LOOP(depth)                                   \
+    h_size= (c->dstW+7)&~7;                                   \
+    if(h_size*depth > FFABS(dstStride[0])) h_size-=8;         \
                                                                      \
-    __asm__ volatile ("pxor %mm4, %mm4\n\t");                        \
+    __asm__ volatile ("pxor %mm4, %mm4;" /* zero mm4 */ );    \
     for (y = 0; y < srcSliceH; y++) {                                \
         uint8_t *image    = dst[0] + (y + srcSliceY) * dstStride[0]; \
         const uint8_t *py = src[0] +               y * srcStride[0]; \
@@ -63,333 +139,377 @@
         const uint8_t *pv = src[2] +        (y >> 1) * srcStride[2]; \
         x86_reg index = -h_size / 2;                                 \
 
-#define YUV2RGB_INITIAL_LOAD          \
+#define YUV2RGB_INIT                                                       \
+        /* This MMX assembly code deals with a SINGLE scan line at a time, \
+         * it converts 8 pixels in each iteration. */                      \
     __asm__ volatile (                \
-        "movq (%5, %0, 2), %%mm6\n\t" \
-        "movd    (%2, %0), %%mm0\n\t" \
-        "movd    (%3, %0), %%mm1\n\t" \
+        /* load data for start of next scan line */                        \
+        "movd    (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \
+        "movd    (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \
+        "movq (%5, %0, 2), %%mm6;" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ \
+        /*                                                                 \
+        ".balign 16     \n\t"                                              \
+        */                                                                 \
         "1: \n\t"                     \
-
-/* YUV2RGB core
- * Conversion is performed in usual way:
- * R = Y' * Ycoef + Vred * V'
- * G = Y' * Ycoef + Vgreen * V' + Ugreen * U'
- * B = Y' * Ycoef               + Ublue * U'
- *
- * where X' = X * 8 - Xoffset (multiplication is performed to increase
- * precision a bit).
- * Since it operates in YUV420 colorspace, Y component is additionally
- * split into Y1 and Y2 for even and odd pixels.
- *
- * Input:
- * mm0 - U (4 elems), mm1 - V (4 elems), mm6 - Y (8 elems), mm4 - zero register
- * Output:
- * mm1 - R, mm2 - G, mm0 - B
- */
-#define YUV2RGB                                  \
-    /* convert Y, U, V into Y1', Y2', U', V' */  \
-    "movq      %%mm6, %%mm7\n\t"                 \
-    "punpcklbw %%mm4, %%mm0\n\t"                 \
-    "punpcklbw %%mm4, %%mm1\n\t"                 \
-    "pand     "MANGLE(mmx_00ffw)", %%mm6\n\t"    \
-    "psrlw     $8,    %%mm7\n\t"                 \
-    "psllw     $3,    %%mm0\n\t"                 \
-    "psllw     $3,    %%mm1\n\t"                 \
-    "psllw     $3,    %%mm6\n\t"                 \
-    "psllw     $3,    %%mm7\n\t"                 \
-    "psubsw   "U_OFFSET"(%4), %%mm0\n\t"         \
-    "psubsw   "V_OFFSET"(%4), %%mm1\n\t"         \
-    "psubw    "Y_OFFSET"(%4), %%mm6\n\t"         \
-    "psubw    "Y_OFFSET"(%4), %%mm7\n\t"         \
-\
-     /* multiply by coefficients */              \
-    "movq      %%mm0, %%mm2\n\t"                 \
-    "movq      %%mm1, %%mm3\n\t"                 \
-    "pmulhw   "UG_COEFF"(%4), %%mm2\n\t"         \
-    "pmulhw   "VG_COEFF"(%4), %%mm3\n\t"         \
-    "pmulhw   "Y_COEFF" (%4), %%mm6\n\t"         \
-    "pmulhw   "Y_COEFF" (%4), %%mm7\n\t"         \
-    "pmulhw   "UB_COEFF"(%4), %%mm0\n\t"         \
-    "pmulhw   "VR_COEFF"(%4), %%mm1\n\t"         \
-    "paddsw    %%mm3, %%mm2\n\t"                 \
-    /* now: mm0 = UB, mm1 = VR, mm2 = CG */      \
-    /*      mm6 = Y1, mm7 = Y2 */                \
-\
-    /* produce RGB */                            \
-    "movq      %%mm7, %%mm3\n\t"                 \
-    "movq      %%mm7, %%mm5\n\t"                 \
-    "paddsw    %%mm0, %%mm3\n\t"                 \
-    "paddsw    %%mm1, %%mm5\n\t"                 \
-    "paddsw    %%mm2, %%mm7\n\t"                 \
-    "paddsw    %%mm6, %%mm0\n\t"                 \
-    "paddsw    %%mm6, %%mm1\n\t"                 \
-    "paddsw    %%mm6, %%mm2\n\t"                 \
-
-#define RGB_PACK_INTERLEAVE                  \
-    /* pack and interleave even/odd pixels */    \
-    "packuswb  %%mm1, %%mm0\n\t"                 \
-    "packuswb  %%mm5, %%mm3\n\t"                 \
-    "packuswb  %%mm2, %%mm2\n\t"                 \
-    "movq      %%mm0, %%mm1\n\n"                 \
-    "packuswb  %%mm7, %%mm7\n\t"                 \
-    "punpcklbw %%mm3, %%mm0\n\t"                 \
-    "punpckhbw %%mm3, %%mm1\n\t"                 \
-    "punpcklbw %%mm7, %%mm2\n\t"                 \
+        /* No speed difference on my p3@500 with prefetch,                 \
+         * if it is faster for anyone with -benchmark then tell me.        \
+        PREFETCH" 64(%0) \n\t"                                             \
+        PREFETCH" 64(%1) \n\t"                                             \
+        PREFETCH" 64(%2) \n\t"                                             \
+        */                                                                 \
 
 #define YUV2RGB_ENDLOOP(depth)                   \
-    "movq 8 (%5, %0, 2), %%mm6\n\t"              \
-    "movd 4 (%3, %0),    %%mm1\n\t"              \
-    "movd 4 (%2, %0),    %%mm0\n\t"              \
     "add $"AV_STRINGIFY(depth * 8)", %1\n\t"     \
     "add  $4, %0\n\t"                            \
     "js   1b\n\t"                                \
 
 #define YUV2RGB_OPERANDS                                          \
         : "+r" (index), "+r" (image)                              \
-        : "r" (pu - index), "r" (pv - index), "r"(&c->redDither), \
-          "r" (py - 2*index)                                      \
+        : "r" (pu - index), "r" (pv - index), "r"(&c->redDither), "r" (py - 2*index) \
         );                                                        \
     }                                                             \
+    __asm__ volatile (SFENCE"\n\t"EMMS); \
+    return srcSliceH; \
 
 #define YUV2RGB_OPERANDS_ALPHA                                    \
         : "+r" (index), "+r" (image)                              \
-        : "r" (pu - index), "r" (pv - index), "r"(&c->redDither), \
-          "r" (py - 2*index), "r" (pa - 2*index)                  \
+        : "r" (pu - index), "r" (pv - index), "r"(&c->redDither), "r" (py - 2*index), "r" (pa - 2*index) \
         );                                                        \
     }                                                             \
-
-#define YUV2RGB_ENDFUNC                          \
     __asm__ volatile (SFENCE"\n\t"EMMS);         \
     return srcSliceH;                            \
 
-#define IF0(x)
-#define IF1(x) x
-
-#define RGB_PACK16(gmask, is15)                  \
-    "pand      "MANGLE(mmx_redmask)", %%mm0\n\t" \
-    "pand      "MANGLE(mmx_redmask)", %%mm1\n\t" \
-    "movq      %%mm2,     %%mm3\n\t"             \
-    "psllw   $"AV_STRINGIFY(3-is15)", %%mm2\n\t" \
-    "psrlw   $"AV_STRINGIFY(5+is15)", %%mm3\n\t" \
-    "psrlw     $3,        %%mm0\n\t"             \
-    IF##is15("psrlw  $1,  %%mm1\n\t")            \
-    "pand "MANGLE(pb_e0)", %%mm2\n\t"            \
-    "pand "MANGLE(gmask)", %%mm3\n\t"            \
-    "por       %%mm2,     %%mm0\n\t"             \
-    "por       %%mm3,     %%mm1\n\t"             \
-    "movq      %%mm0,     %%mm2\n\t"             \
-    "punpcklbw %%mm1,     %%mm0\n\t"             \
-    "punpckhbw %%mm1,     %%mm2\n\t"             \
-    MOVNTQ "   %%mm0,      (%1)\n\t"             \
-    MOVNTQ "   %%mm2,     8(%1)\n\t"             \
-
-#define DITHER_RGB                               \
-    "paddusb "BLUE_DITHER"(%4),  %%mm0\n\t"      \
-    "paddusb "GREEN_DITHER"(%4), %%mm2\n\t"      \
-    "paddusb "RED_DITHER"(%4),   %%mm1\n\t"      \
-
-static inline int RENAME(yuv420_rgb15)(SwsContext *c, const uint8_t *src[],
-                                       int srcStride[],
-                                       int srcSliceY, int srcSliceH,
-                                       uint8_t *dst[], int dstStride[])
+static inline int RENAME(yuv420_rgb16)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+                                       int srcSliceH, uint8_t* dst[], int dstStride[])
 {
     int y, h_size;
 
+    YUV422_UNSHIFT
     YUV2RGB_LOOP(2)
 
-#ifdef DITHER1XBPP
         c->blueDither  = ff_dither8[y       & 1];
-        c->greenDither = ff_dither8[y       & 1];
+        c->greenDither= ff_dither4[y&1];
         c->redDither   = ff_dither8[(y + 1) & 1];
-#endif
 
-        YUV2RGB_INITIAL_LOAD
+        YUV2RGB_INIT
         YUV2RGB
-        RGB_PACK_INTERLEAVE
+
 #ifdef DITHER1XBPP
-        DITHER_RGB
+        "paddusb "BLUE_DITHER"(%4), %%mm0;"
+        "paddusb "GREEN_DITHER"(%4), %%mm2;"
+        "paddusb "RED_DITHER"(%4), %%mm1;"
 #endif
-        RGB_PACK16(pb_03, 1)
+        /* mask unneeded bits off */
+        "pand "MANGLE(mmx_redmask)", %%mm0;" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */
+        "pand "MANGLE(mmx_grnmask)", %%mm2;" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */
+        "pand "MANGLE(mmx_redmask)", %%mm1;" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */
+
+        "psrlw   $3, %%mm0;" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */
+        "pxor %%mm4, %%mm4;" /* zero mm4 */
+
+        "movq %%mm0, %%mm5;" /* Copy B7-B0 */
+        "movq %%mm2, %%mm7;" /* Copy G7-G0 */
+
+        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
+        "punpcklbw %%mm4, %%mm2;" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */
+        "punpcklbw %%mm1, %%mm0;" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
+
+        "psllw  $3, %%mm2;" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */
+        "por %%mm2, %%mm0;" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */
+
+        "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */
+        MOVNTQ "      %%mm0, (%1);" /* store pixel 0-3 */
+
+        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
+        "punpckhbw %%mm4, %%mm7;" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */
+        "punpckhbw %%mm1, %%mm5;" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
+
+        "psllw        $3, %%mm7;" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */
+        "movd 4 (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */
+
+        "por       %%mm7, %%mm5;" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */
+        "movd 4 (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */
+
+        MOVNTQ "   %%mm5, 8 (%1);" /* store pixel 4-7 */
 
     YUV2RGB_ENDLOOP(2)
     YUV2RGB_OPERANDS
-    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuv420_rgb16)(SwsContext *c, const uint8_t *src[],
-                                       int srcStride[],
-                                       int srcSliceY, int srcSliceH,
-                                       uint8_t *dst[], int dstStride[])
+static inline int RENAME(yuv420_rgb15)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+                                       int srcSliceH, uint8_t* dst[], int dstStride[])
 {
     int y, h_size;
 
+    YUV422_UNSHIFT
     YUV2RGB_LOOP(2)
 
-#ifdef DITHER1XBPP
         c->blueDither  = ff_dither8[y       & 1];
-        c->greenDither = ff_dither4[y       & 1];
+        c->greenDither= ff_dither8[y&1];
         c->redDither   = ff_dither8[(y + 1) & 1];
-#endif
 
-        YUV2RGB_INITIAL_LOAD
+        YUV2RGB_INIT
         YUV2RGB
-        RGB_PACK_INTERLEAVE
+
 #ifdef DITHER1XBPP
-        DITHER_RGB
+        "paddusb "BLUE_DITHER"(%4), %%mm0  \n\t"
+        "paddusb "GREEN_DITHER"(%4), %%mm2  \n\t"
+        "paddusb "RED_DITHER"(%4), %%mm1  \n\t"
 #endif
-        RGB_PACK16(pb_07, 0)
+
+        /* mask unneeded bits off */
+        "pand "MANGLE(mmx_redmask)", %%mm0;" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */
+        "pand "MANGLE(mmx_redmask)", %%mm2;" /* g7g6g5g4 g3_0_0_0 g7g6g5g4 g3_0_0_0 */
+        "pand "MANGLE(mmx_redmask)", %%mm1;" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */
+
+        "psrlw   $3, %%mm0;" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */
+        "psrlw   $1, %%mm1;" /* 0_r7r6r5  r4r3_0_0 0_r7r6r5 r4r3_0_0 */
+        "pxor %%mm4, %%mm4;" /* zero mm4 */
+
+        "movq %%mm0, %%mm5;" /* Copy B7-B0 */
+        "movq %%mm2, %%mm7;" /* Copy G7-G0 */
+
+        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
+        "punpcklbw %%mm4, %%mm2;" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3_0_0_0 */
+        "punpcklbw %%mm1, %%mm0;" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
+
+        "psllw  $2, %%mm2;" /* 0_0_0_0 0_0_g7g6 g5g4g3_0 0_0_0_0 */
+        "por %%mm2, %%mm0;" /* 0_r7r6r5 r4r3g7g6 g5g4g3b7 b6b5b4b3 */
+
+        "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */
+        MOVNTQ "      %%mm0, (%1);"  /* store pixel 0-3 */
+
+        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
+        "punpckhbw %%mm4, %%mm7;" /* 0_0_0_0 0_0_0_0 0_g7g6g5 g4g3_0_0 */
+        "punpckhbw %%mm1, %%mm5;" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
+
+        "psllw        $2, %%mm7;" /* 0_0_0_0 0_0_g7g6 g5g4g3_0 0_0_0_0 */
+        "movd 4 (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */
+
+        "por       %%mm7, %%mm5;" /* 0_r7r6r5 r4r3g7g6 g5g4g3b7 b6b5b4b3 */
+        "movd 4 (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */
+
+        MOVNTQ " %%mm5, 8 (%1);" /* store pixel 4-7 */
 
     YUV2RGB_ENDLOOP(2)
     YUV2RGB_OPERANDS
-    YUV2RGB_ENDFUNC
 }
 
-#define RGB_PACK24(blue, red)\
-    "packuswb  %%mm3,      %%mm0 \n" /* R0 R2 R4 R6 R1 R3 R5 R7 */\
-    "packuswb  %%mm5,      %%mm1 \n" /* B0 B2 B4 B6 B1 B3 B5 B7 */\
-    "packuswb  %%mm7,      %%mm2 \n" /* G0 G2 G4 G6 G1 G3 G5 G7 */\
-    "movq      %%mm"red",  %%mm3 \n"\
-    "movq      %%mm"blue", %%mm6 \n"\
-    "psrlq     $32,        %%mm"red" \n" /* R1 R3 R5 R7 */\
-    "punpcklbw %%mm2,      %%mm3 \n" /* R0 G0 R2 G2 R4 G4 R6 G6 */\
-    "punpcklbw %%mm"red",  %%mm6 \n" /* B0 R1 B2 R3 B4 R5 B6 R7 */\
-    "movq      %%mm3,      %%mm5 \n"\
-    "punpckhbw %%mm"blue", %%mm2 \n" /* G1 B1 G3 B3 G5 B5 G7 B7*/\
-    "punpcklwd %%mm6,      %%mm3 \n" /* R0 G0 B0 R1 R2 G2 B2 R3 */\
-    "punpckhwd %%mm6,      %%mm5 \n" /* R4 G4 B4 R5 R6 G6 B6 R7 */\
-    RGB_PACK24_B
-
+#undef RGB_PLANAR2PACKED24
 #if HAVE_MMX2
-DECLARE_ASM_CONST(8, int16_t, mask1101[4]) = {-1,-1, 0,-1};
-DECLARE_ASM_CONST(8, int16_t, mask0010[4]) = { 0, 0,-1, 0};
-DECLARE_ASM_CONST(8, int16_t, mask0110[4]) = { 0,-1,-1, 0};
-DECLARE_ASM_CONST(8, int16_t, mask1001[4]) = {-1, 0, 0,-1};
-DECLARE_ASM_CONST(8, int16_t, mask0100[4]) = { 0,-1, 0, 0};
-#undef RGB_PACK24_B
-#define RGB_PACK24_B\
-    "pshufw    $0xc6,  %%mm2, %%mm1 \n"\
-    "pshufw    $0x84,  %%mm3, %%mm6 \n"\
-    "pshufw    $0x38,  %%mm5, %%mm7 \n"\
-    "pand "MANGLE(mask1101)", %%mm6 \n" /* R0 G0 B0 R1 -- -- R2 G2 */\
-    "movq      %%mm1,         %%mm0 \n"\
-    "pand "MANGLE(mask0110)", %%mm7 \n" /* -- -- R6 G6 B6 R7 -- -- */\
-    "movq      %%mm1,         %%mm2 \n"\
-    "pand "MANGLE(mask0100)", %%mm1 \n" /* -- -- G3 B3 -- -- -- -- */\
-    "psrlq       $48,         %%mm3 \n" /* B2 R3 -- -- -- -- -- -- */\
-    "pand "MANGLE(mask0010)", %%mm0 \n" /* -- -- -- -- G1 B1 -- -- */\
-    "psllq       $32,         %%mm5 \n" /* -- -- -- -- R4 G4 B4 R5 */\
-    "pand "MANGLE(mask1001)", %%mm2 \n" /* G5 B5 -- -- -- -- G7 B7 */\
-    "por       %%mm3,         %%mm1 \n"\
-    "por       %%mm6,         %%mm0 \n"\
-    "por       %%mm5,         %%mm1 \n"\
-    "por       %%mm7,         %%mm2 \n"\
-    MOVNTQ"    %%mm0,          (%1) \n"\
-    MOVNTQ"    %%mm1,         8(%1) \n"\
-    MOVNTQ"    %%mm2,        16(%1) \n"\
-
+#define RGB_PLANAR2PACKED24(red, blue)\
+        "movq "MANGLE(ff_M24A)", %%mm4     \n\t"\
+        "movq "MANGLE(ff_M24C)", %%mm7     \n\t"\
+        "pshufw $0x50, %%mm"blue", %%mm5   \n\t" /* B3 B2 B3 B2  B1 B0 B1 B0 */\
+        "pshufw $0x50, %%mm2, %%mm3     \n\t" /* G3 G2 G3 G2  G1 G0 G1 G0 */\
+        "pshufw $0x00, %%mm"red", %%mm6 \n\t" /* R1 R0 R1 R0  R1 R0 R1 R0 */\
+\
+        "pand   %%mm4, %%mm5            \n\t" /*    B2        B1       B0 */\
+        "pand   %%mm4, %%mm3            \n\t" /*    G2        G1       G0 */\
+        "pand   %%mm7, %%mm6            \n\t" /*       R1        R0       */\
+\
+        "psllq     $8, %%mm3            \n\t" /* G2        G1       G0    */\
+        "por    %%mm5, %%mm6            \n\t"\
+        "por    %%mm3, %%mm6            \n\t"\
+        MOVNTQ" %%mm6, (%1)             \n\t"\
+\
+        "psrlq     $8, %%mm2            \n\t" /* 00 G7 G6 G5  G4 G3 G2 G1 */\
+        "pshufw $0xA5, %%mm"blue", %%mm5\n\t" /* B5 B4 B5 B4  B3 B2 B3 B2 */\
+        "pshufw $0x55, %%mm2, %%mm3     \n\t" /* G4 G3 G4 G3  G4 G3 G4 G3 */\
+        "pshufw $0xA5, %%mm"red", %%mm6 \n\t" /* R5 R4 R5 R4  R3 R2 R3 R2 */\
+\
+        "pand "MANGLE(ff_M24B)", %%mm5  \n\t" /* B5       B4        B3    */\
+        "pand          %%mm7, %%mm3     \n\t" /*       G4        G3       */\
+        "pand          %%mm4, %%mm6     \n\t" /*    R4        R3       R2 */\
+\
+        "por    %%mm5, %%mm3            \n\t" /* B5    G4 B4     G3 B3    */\
+        "por    %%mm3, %%mm6            \n\t"\
+        MOVNTQ" %%mm6, 8(%1)            \n\t"\
+\
+        "pshufw $0xFF, %%mm"blue", %%mm5\n\t" /* B7 B6 B7 B6  B7 B6 B6 B7 */\
+        "pshufw $0xFA, %%mm2, %%mm3     \n\t" /* 00 G7 00 G7  G6 G5 G6 G5 */\
+        "pshufw $0xFA, %%mm"red", %%mm6 \n\t" /* R7 R6 R7 R6  R5 R4 R5 R4 */\
+        "movd 4 (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\
+\
+        "pand          %%mm7, %%mm5     \n\t" /*       B7        B6       */\
+        "pand          %%mm4, %%mm3     \n\t" /*    G7        G6       G5 */\
+        "pand "MANGLE(ff_M24B)", %%mm6  \n\t" /* R7       R6        R5    */\
+        "movd 4 (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\
+\
+        "por          %%mm5, %%mm3      \n\t"\
+        "por          %%mm3, %%mm6      \n\t"\
+        MOVNTQ"       %%mm6, 16(%1)     \n\t"\
+        "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
+        "pxor         %%mm4, %%mm4      \n\t"
 #else
-#undef RGB_PACK24_B
-#define RGB_PACK24_B\
-    "movd      %%mm3,       (%1) \n" /* R0 G0 B0 R1 */\
-    "movd      %%mm2,      4(%1) \n" /* G1 B1 */\
-    "psrlq     $32,        %%mm3 \n"\
-    "psrlq     $16,        %%mm2 \n"\
-    "movd      %%mm3,      6(%1) \n" /* R2 G2 B2 R3 */\
-    "movd      %%mm2,     10(%1) \n" /* G3 B3 */\
-    "psrlq     $16,        %%mm2 \n"\
-    "movd      %%mm5,     12(%1) \n" /* R4 G4 B4 R5 */\
-    "movd      %%mm2,     16(%1) \n" /* G5 B5 */\
-    "psrlq     $32,        %%mm5 \n"\
-    "movd      %%mm2,     20(%1) \n" /* -- -- G7 B7 */\
-    "movd      %%mm5,     18(%1) \n" /* R6 G6 B6 R7 */\
-
+#define RGB_PLANAR2PACKED24(red, blue)\
+        "pxor      %%mm4, %%mm4     \n\t"\
+        "movq      %%mm"blue", %%mm5\n\t" /* B */\
+        "movq      %%mm"red", %%mm6 \n\t" /* R */\
+        "punpcklbw %%mm2, %%mm"blue"\n\t" /* GBGBGBGB 0 */\
+        "punpcklbw %%mm4, %%mm"red" \n\t" /* 0R0R0R0R 0 */\
+        "punpckhbw %%mm2, %%mm5     \n\t" /* GBGBGBGB 2 */\
+        "punpckhbw %%mm4, %%mm6     \n\t" /* 0R0R0R0R 2 */\
+        "movq      %%mm"blue", %%mm7\n\t" /* GBGBGBGB 0 */\
+        "movq      %%mm5, %%mm3     \n\t" /* GBGBGBGB 2 */\
+        "punpcklwd %%mm"red", %%mm7 \n\t" /* 0RGB0RGB 0 */\
+        "punpckhwd %%mm"red", %%mm"blue"\n\t" /* 0RGB0RGB 1 */\
+        "punpcklwd %%mm6, %%mm5     \n\t" /* 0RGB0RGB 2 */\
+        "punpckhwd %%mm6, %%mm3     \n\t" /* 0RGB0RGB 3 */\
+\
+        "movq      %%mm7, %%mm2     \n\t" /* 0RGB0RGB 0 */\
+        "movq      %%mm"blue", %%mm6\n\t" /* 0RGB0RGB 1 */\
+        "movq      %%mm5, %%mm"red" \n\t" /* 0RGB0RGB 2 */\
+        "movq      %%mm3, %%mm4     \n\t" /* 0RGB0RGB 3 */\
+\
+        "psllq       $40, %%mm7     \n\t" /* RGB00000 0 */\
+        "psllq       $40, %%mm"blue"\n\t" /* RGB00000 1 */\
+        "psllq       $40, %%mm5     \n\t" /* RGB00000 2 */\
+        "psllq       $40, %%mm3     \n\t" /* RGB00000 3 */\
+\
+        "punpckhdq %%mm2, %%mm7     \n\t" /* 0RGBRGB0 0 */\
+        "punpckhdq %%mm6, %%mm"blue"\n\t" /* 0RGBRGB0 1 */\
+        "punpckhdq %%mm"red", %%mm5 \n\t" /* 0RGBRGB0 2 */\
+        "punpckhdq %%mm4, %%mm3     \n\t" /* 0RGBRGB0 3 */\
+\
+        "psrlq        $8, %%mm7     \n\t" /* 00RGBRGB 0 */\
+        "movq      %%mm"blue", %%mm6\n\t" /* 0RGBRGB0 1 */\
+        "psllq       $40, %%mm"blue"\n\t" /* GB000000 1 */\
+        "por       %%mm"blue", %%mm7\n\t" /* GBRGBRGB 0 */\
+        MOVNTQ"    %%mm7, (%1)      \n\t"\
+\
+        "psrlq       $24, %%mm6     \n\t" /* 0000RGBR 1 */\
+        "movq      %%mm5, %%mm"red" \n\t" /* 0RGBRGB0 2 */\
+        "psllq       $24, %%mm5     \n\t" /* BRGB0000 2 */\
+        "por       %%mm5, %%mm6     \n\t" /* BRGBRGBR 1 */\
+        MOVNTQ"    %%mm6, 8(%1)     \n\t"\
+\
+        "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
+\
+        "psrlq       $40, %%mm"red" \n\t" /* 000000RG 2 */\
+        "psllq        $8, %%mm3     \n\t" /* RGBRGB00 3 */\
+        "por       %%mm3, %%mm"red" \n\t" /* RGBRGBRG 2 */\
+        MOVNTQ"    %%mm"red", 16(%1)\n\t"\
+\
+        "movd 4 (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\
+        "movd 4 (%2, %0), %%mm0;" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\
+        "pxor      %%mm4, %%mm4     \n\t"
 #endif
 
-static inline int RENAME(yuv420_rgb24)(SwsContext *c, const uint8_t *src[],
-                                       int srcStride[],
-                                       int srcSliceY, int srcSliceH,
-                                       uint8_t *dst[], int dstStride[])
+static inline int RENAME(yuv420_rgb24)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+                                       int srcSliceH, uint8_t* dst[], int dstStride[])
 {
     int y, h_size;
 
+    YUV422_UNSHIFT
     YUV2RGB_LOOP(3)
 
-        YUV2RGB_INITIAL_LOAD
+        YUV2RGB_INIT
         YUV2RGB
-        RGB_PACK24(REG_BLUE, REG_RED)
+        /* mm0=B, %%mm2=G, %%mm1=R */
+        RGB_PLANAR2PACKED24("0", "1")
 
     YUV2RGB_ENDLOOP(3)
     YUV2RGB_OPERANDS
-    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuv420_bgr24)(SwsContext *c, const uint8_t *src[],
-                                       int srcStride[],
-                                       int srcSliceY, int srcSliceH,
-                                       uint8_t *dst[], int dstStride[])
+static inline int RENAME(yuv420_bgr24)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+                                       int srcSliceH, uint8_t* dst[], int dstStride[])
 {
     int y, h_size;
 
+    YUV422_UNSHIFT
     YUV2RGB_LOOP(3)
 
-        YUV2RGB_INITIAL_LOAD
+        YUV2RGB_INIT
         YUV2RGB
-        RGB_PACK24(REG_RED, REG_BLUE)
+        /* mm0=B, %%mm2=G, %%mm1=R */
+        RGB_PLANAR2PACKED24("1", "0")
 
     YUV2RGB_ENDLOOP(3)
     YUV2RGB_OPERANDS
-    YUV2RGB_ENDFUNC
 }
 
+/*
 
-#define SET_EMPTY_ALPHA                                                      \
-    "pcmpeqd   %%mm"REG_ALPHA", %%mm"REG_ALPHA"\n\t" /* set alpha to 0xFF */ \
+RGB_PLANAR2PACKED32(red,green,blue,alpha)
 
-#define LOAD_ALPHA                                   \
-    "movq      (%6, %0, 2),     %%mm"REG_ALPHA"\n\t" \
+convert RGB plane to RGB packed format
 
-#define RGB_PACK32(red, green, blue, alpha)  \
-    "movq      %%mm"blue",  %%mm5\n\t"       \
-    "movq      %%mm"red",   %%mm6\n\t"       \
-    "punpckhbw %%mm"green", %%mm5\n\t"       \
-    "punpcklbw %%mm"green", %%mm"blue"\n\t"  \
-    "punpckhbw %%mm"alpha", %%mm6\n\t"       \
-    "punpcklbw %%mm"alpha", %%mm"red"\n\t"   \
-    "movq      %%mm"blue",  %%mm"green"\n\t" \
-    "movq      %%mm5,       %%mm"alpha"\n\t" \
-    "punpcklwd %%mm"red",   %%mm"blue"\n\t"  \
-    "punpckhwd %%mm"red",   %%mm"green"\n\t" \
-    "punpcklwd %%mm6,       %%mm5\n\t"       \
-    "punpckhwd %%mm6,       %%mm"alpha"\n\t" \
-    MOVNTQ "   %%mm"blue",   0(%1)\n\t"      \
-    MOVNTQ "   %%mm"green",  8(%1)\n\t"      \
-    MOVNTQ "   %%mm5,       16(%1)\n\t"      \
-    MOVNTQ "   %%mm"alpha", 24(%1)\n\t"      \
+macro parameters specify the output color channel order:
 
-static inline int RENAME(yuv420_rgb32)(SwsContext *c, const uint8_t *src[],
-                                       int srcStride[],
-                                       int srcSliceY, int srcSliceH,
-                                       uint8_t *dst[], int dstStride[])
+RGB_PLANAR2PACKED32(REG_RED,  REG_GREEN, REG_BLUE, REG_ALPHA) for RGBA output,
+RGB_PLANAR2PACKED32(REG_BLUE, REG_GREEN, REG_RED,  REG_ALPHA) for BGRA output,
+RGB_PLANAR2PACKED32(REG_ALPHA,REG_BLUE,  REG_GREEN,REG_RED)   for ABGR output,
+
+etc.
+*/
+
+#define REG_BLUE  "0"
+#define REG_RED   "1"
+#define REG_GREEN "2"
+#define REG_ALPHA "3"
+
+#define RGB_PLANAR2PACKED32(red,green,blue,alpha)                       \
+    /* convert RGB plane to RGB packed format,                          \
+       mm0 ->  B, mm1 -> R, mm2 -> G, mm3 -> A,                         \
+       mm4 -> GB, mm5 -> AR pixel 4-7,                                  \
+       mm6 -> GB, mm7 -> AR pixel 0-3 */                                \
+    "movq      %%mm" blue ", %%mm6;"   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
+    "movq      %%mm" red  ", %%mm7;"   /* R7 R6 R5 R4 R3 R2 R1 R0 */    \
+\
+    "movq      %%mm" blue ", %%mm4;"   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
+    "movq      %%mm" red  ", %%mm5;"   /* R7 R6 R5 R4 R3 R2 R1 R0 */    \
+\
+    "punpcklbw %%mm" green ", %%mm6;"  /* G3 B3 G2 B2 G1 B1 G0 B0 */    \
+    "punpcklbw %%mm" alpha ", %%mm7;"  /* A3 R3 A2 R2 A1 R1 A0 R0 */    \
+\
+    "punpcklwd %%mm7, %%mm6;"          /* A1 R1 B1 G1 A0 R0 B0 G0 */    \
+    MOVNTQ "   %%mm6, (%1);"           /* Store ARGB1 ARGB0 */          \
+\
+    "movq      %%mm" blue ", %%mm6;"   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
+    "punpcklbw %%mm" green ", %%mm6;"  /* G3 B3 G2 B2 G1 B1 G0 B0 */    \
+\
+    "punpckhwd %%mm7, %%mm6;"          /* A3 R3 G3 B3 A2 R2 B3 G2 */    \
+    MOVNTQ "   %%mm6, 8 (%1);"         /* Store ARGB3 ARGB2 */          \
+\
+    "punpckhbw %%mm" green ", %%mm4;"  /* G7 B7 G6 B6 G5 B5 G4 B4 */    \
+    "punpckhbw %%mm" alpha ", %%mm5;"  /* A7 R7 A6 R6 A5 R5 A4 R4 */    \
+\
+    "punpcklwd %%mm5, %%mm4;"          /* A5 R5 B5 G5 A4 R4 B4 G4 */    \
+    MOVNTQ "   %%mm4, 16 (%1);"        /* Store ARGB5 ARGB4 */          \
+\
+    "movq      %%mm" blue ", %%mm4;"   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
+    "punpckhbw %%mm" green ", %%mm4;"  /* G7 B7 G6 B6 G5 B5 G4 B4 */    \
+\
+    "punpckhwd %%mm5, %%mm4;"   /* A7 R7 G7 B7 A6 R6 B6 G6 */           \
+    MOVNTQ "   %%mm4, 24 (%1);" /* Store ARGB7 ARGB6 */                 \
+\
+    "movd 4 (%2, %0), %%mm0;"   /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \
+    "movd 4 (%3, %0), %%mm1;"   /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \
+\
+    "pxor         %%mm4, %%mm4;" /* zero mm4 */                         \
+    "movq 8 (%5, %0, 2), %%mm6;" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ \
+
+static inline int RENAME(yuv420_rgb32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+                                       int srcSliceH, uint8_t* dst[], int dstStride[])
 {
     int y, h_size;
 
+    YUV422_UNSHIFT
     YUV2RGB_LOOP(4)
 
-        YUV2RGB_INITIAL_LOAD
+        YUV2RGB_INIT
         YUV2RGB
-        RGB_PACK_INTERLEAVE
-        SET_EMPTY_ALPHA
-        RGB_PACK32(REG_RED, REG_GREEN, REG_BLUE, REG_ALPHA)
+        "pcmpeqd   %%mm3, %%mm3;"   /* fill mm3 */
+        RGB_PLANAR2PACKED32(REG_RED,REG_GREEN,REG_BLUE,REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS
-    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuva420_rgb32)(SwsContext *c, const uint8_t *src[],
-                                        int srcStride[],
-                                        int srcSliceY, int srcSliceH,
-                                        uint8_t *dst[], int dstStride[])
+static inline int RENAME(yuva420_rgb32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+                                        int srcSliceH, uint8_t* dst[], int dstStride[])
 {
 #if HAVE_7REGS
     int y, h_size;
@@ -397,42 +517,35 @@
     YUV2RGB_LOOP(4)
 
         const uint8_t *pa = src[3] + y * srcStride[3];
-        YUV2RGB_INITIAL_LOAD
+        YUV2RGB_INIT
         YUV2RGB
-        RGB_PACK_INTERLEAVE
-        LOAD_ALPHA
-        RGB_PACK32(REG_RED, REG_GREEN, REG_BLUE, REG_ALPHA)
+        "movq     (%6, %0, 2), %%mm3;"            /* Load 8 A A7 A6 A5 A4 A3 A2 A1 A0 */
+        RGB_PLANAR2PACKED32(REG_RED,REG_GREEN,REG_BLUE,REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS_ALPHA
-    YUV2RGB_ENDFUNC
 #endif
 }
 
-static inline int RENAME(yuv420_bgr32)(SwsContext *c, const uint8_t *src[],
-                                       int srcStride[],
-                                       int srcSliceY, int srcSliceH,
-                                       uint8_t *dst[], int dstStride[])
+static inline int RENAME(yuv420_bgr32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+                                       int srcSliceH, uint8_t* dst[], int dstStride[])
 {
     int y, h_size;
 
+    YUV422_UNSHIFT
     YUV2RGB_LOOP(4)
 
-        YUV2RGB_INITIAL_LOAD
+        YUV2RGB_INIT
         YUV2RGB
-        RGB_PACK_INTERLEAVE
-        SET_EMPTY_ALPHA
-        RGB_PACK32(REG_BLUE, REG_GREEN, REG_RED, REG_ALPHA)
+        "pcmpeqd   %%mm3, %%mm3;"   /* fill mm3 */
+        RGB_PLANAR2PACKED32(REG_BLUE,REG_GREEN,REG_RED,REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS
-    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuva420_bgr32)(SwsContext *c, const uint8_t *src[],
-                                        int srcStride[],
-                                        int srcSliceY, int srcSliceH,
-                                        uint8_t *dst[], int dstStride[])
+static inline int RENAME(yuva420_bgr32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
+                                        int srcSliceH, uint8_t* dst[], int dstStride[])
 {
 #if HAVE_7REGS
     int y, h_size;
@@ -440,14 +553,12 @@
     YUV2RGB_LOOP(4)
 
         const uint8_t *pa = src[3] + y * srcStride[3];
-        YUV2RGB_INITIAL_LOAD
+        YUV2RGB_INIT
         YUV2RGB
-        RGB_PACK_INTERLEAVE
-        LOAD_ALPHA
-        RGB_PACK32(REG_BLUE, REG_GREEN, REG_RED, REG_ALPHA)
+        "movq     (%6, %0, 2), %%mm3;"            /* Load 8 A A7 A6 A5 A4 A3 A2 A1 A0 */
+        RGB_PLANAR2PACKED32(REG_BLUE,REG_GREEN,REG_RED,REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS_ALPHA
-    YUV2RGB_ENDFUNC
 #endif
 }
diff -U 3 -H -w -d -r -N -x .svn -x CVS -x cvs -- ffmpeg-r21659/libswscale/yuv2rgb.c ffmpeg-for-2.2.5/libswscale/yuv2rgb.c
--- ffmpeg-r21659/libswscale/yuv2rgb.c	2010-08-03 08:01:12.000000000 -0600
+++ ffmpeg-for-2.2.5/libswscale/yuv2rgb.c	2010-02-07 11:46:28.000000000 -0700
@@ -33,9 +33,7 @@
 #include "swscale.h"
 #include "swscale_internal.h"
 #include "libavutil/x86_cpu.h"
-#include "libavutil/bswap.h"
 
-extern const uint8_t dither_4x4_16[4][8];
 extern const uint8_t dither_8x8_32[8][8];
 extern const uint8_t dither_8x8_73[8][8];
 extern const uint8_t dither_8x8_220[8][8];
@@ -353,32 +351,6 @@
 #endif
 
 // r, g, b, dst_1, dst_2
-YUV2RGBFUNC(yuv2rgb_c_12_ordered_dither, uint16_t, 0)
-    const uint8_t *d16 = dither_4x4_16[y&3];
-#define PUTRGB12(dst,src,i,o)                                   \
-    Y = src[2*i];                                               \
-    dst[2*i]   = r[Y+d16[0+o]] + g[Y+d16[0+o]] + b[Y+d16[0+o]]; \
-    Y = src[2*i+1];                                             \
-    dst[2*i+1] = r[Y+d16[1+o]] + g[Y+d16[1+o]] + b[Y+d16[1+o]];
-
-    LOADCHROMA(0);
-    PUTRGB12(dst_1,py_1,0,0);
-    PUTRGB12(dst_2,py_2,0,0+8);
-
-    LOADCHROMA(1);
-    PUTRGB12(dst_2,py_2,1,2+8);
-    PUTRGB12(dst_1,py_1,1,2);
-
-    LOADCHROMA(2);
-    PUTRGB12(dst_1,py_1,2,4);
-    PUTRGB12(dst_2,py_2,2,4+8);
-
-    LOADCHROMA(3);
-    PUTRGB12(dst_2,py_2,3,6+8);
-    PUTRGB12(dst_1,py_1,3,6);
-CLOSEYUV2RGBFUNC(8)
-
-// r, g, b, dst_1, dst_2
 YUV2RGBFUNC(yuv2rgb_c_8_ordered_dither, uint8_t, 0)
     const uint8_t *d32 = dither_8x8_32[y&7];
     const uint8_t *d64 = dither_8x8_73[y&7];
@@ -543,7 +515,7 @@
 SwsFunc ff_yuv2rgb_get_func_ptr(SwsContext *c)
 {
     SwsFunc t = NULL;
-#if HAVE_MMX
+#if (HAVE_MMX2 || HAVE_MMX) && CONFIG_GPL
      t = ff_yuv2rgb_init_mmx(c);
 #endif
 #if HAVE_VIS
@@ -580,8 +552,6 @@
     case PIX_FMT_BGR565:
     case PIX_FMT_RGB555:
     case PIX_FMT_BGR555:     return yuv2rgb_c_16;
-    case PIX_FMT_RGB444:
-    case PIX_FMT_BGR444:     return yuv2rgb_c_12_ordered_dither;
     case PIX_FMT_RGB8:
     case PIX_FMT_BGR8:       return yuv2rgb_c_8_ordered_dither;
     case PIX_FMT_RGB4:
@@ -595,11 +565,10 @@
     return NULL;
 }
 
-static void fill_table(uint8_t* table[256], const int elemsize, const int inc, void *y_tab)
+static void fill_table(uint8_t* table[256], const int elemsize, const int inc, uint8_t *y_table)
 {
     int i;
     int64_t cb = 0;
-    uint8_t *y_table = y_tab;
 
     y_table -= elemsize * (inc >> 9);
 
@@ -621,36 +590,18 @@
     }
 }
 
-static uint16_t roundToInt16(int64_t f)
-{
-    int r= (f + (1<<15))>>16;
-         if (r<-0x7FFF) return 0x8000;
-    else if (r> 0x7FFF) return 0x7FFF;
-    else                return r;
-}
-
 av_cold int ff_yuv2rgb_c_init_tables(SwsContext *c, const int inv_table[4], int fullRange,
                                      int brightness, int contrast, int saturation)
 {
     const int isRgb =      c->dstFormat==PIX_FMT_RGB32
                         || c->dstFormat==PIX_FMT_RGB32_1
                         || c->dstFormat==PIX_FMT_BGR24
-                        || c->dstFormat==PIX_FMT_RGB565BE
-                        || c->dstFormat==PIX_FMT_RGB565LE
-                        || c->dstFormat==PIX_FMT_RGB555BE
-                        || c->dstFormat==PIX_FMT_RGB555LE
-                        || c->dstFormat==PIX_FMT_RGB444BE
-                        || c->dstFormat==PIX_FMT_RGB444LE
+                        || c->dstFormat==PIX_FMT_RGB565
+                        || c->dstFormat==PIX_FMT_RGB555
                         || c->dstFormat==PIX_FMT_RGB8
                         || c->dstFormat==PIX_FMT_RGB4
                         || c->dstFormat==PIX_FMT_RGB4_BYTE
                         || c->dstFormat==PIX_FMT_MONOBLACK;
-    const int isNotNe =    c->dstFormat==PIX_FMT_NE(RGB565LE,RGB565BE)
-                        || c->dstFormat==PIX_FMT_NE(RGB555LE,RGB555BE)
-                        || c->dstFormat==PIX_FMT_NE(RGB444LE,RGB444BE)
-                        || c->dstFormat==PIX_FMT_NE(BGR565LE,BGR565BE)
-                        || c->dstFormat==PIX_FMT_NE(BGR555LE,BGR555BE)
-                        || c->dstFormat==PIX_FMT_NE(BGR444LE,BGR444BE);
     const int bpp = c->dstFormatBpp;
     uint8_t *y_table;
     uint16_t *y_table16;
@@ -684,22 +635,6 @@
     cgv = (cgv*contrast * saturation) >> 32;
     oy -= 256*brightness;
 
-    c->uOffset=   0x0400040004000400LL;
-    c->vOffset=   0x0400040004000400LL;
-    c->yCoeff=    roundToInt16(cy *8192) * 0x0001000100010001ULL;
-    c->vrCoeff=   roundToInt16(crv*8192) * 0x0001000100010001ULL;
-    c->ubCoeff=   roundToInt16(cbu*8192) * 0x0001000100010001ULL;
-    c->vgCoeff=   roundToInt16(cgv*8192) * 0x0001000100010001ULL;
-    c->ugCoeff=   roundToInt16(cgu*8192) * 0x0001000100010001ULL;
-    c->yOffset=   roundToInt16(oy *   8) * 0x0001000100010001ULL;
-
-    c->yuv2rgb_y_coeff  = (int16_t)roundToInt16(cy <<13);
-    c->yuv2rgb_y_offset = (int16_t)roundToInt16(oy << 9);
-    c->yuv2rgb_v2r_coeff= (int16_t)roundToInt16(crv<<13);
-    c->yuv2rgb_v2g_coeff= (int16_t)roundToInt16(cgv<<13);
-    c->yuv2rgb_u2g_coeff= (int16_t)roundToInt16(cgu<<13);
-    c->yuv2rgb_u2b_coeff= (int16_t)roundToInt16(cbu<<13);
-
     //scale coefficients by cy
     crv = ((crv << 16) + 0x8000) / cy;
     cbu = ((cbu << 16) + 0x8000) / cy;
@@ -759,28 +694,6 @@
         fill_table(c->table_bU, 1, cbu, y_table + yoffs + 2048);
         fill_gv_table(c->table_gV, 1, cgv);
         break;
-    case 12:
-        rbase = isRgb ? 8 : 0;
-        gbase = 4;
-        bbase = isRgb ? 0 : 8;
-        c->yuvTable = av_malloc(1024*3*2);
-        y_table16 = c->yuvTable;
-        yb = -(384<<16) - oy;
-        for (i = 0; i < 1024; i++) {
-            uint8_t yval = av_clip_uint8((yb + 0x8000) >> 16);
-            y_table16[i     ] = (yval >> 4) << rbase;
-            y_table16[i+1024] = (yval >> 4) << gbase;
-            y_table16[i+2048] = (yval >> 4) << bbase;
-            yb += cy;
-        }
-        if (isNotNe)
-            for (i = 0; i < 1024*3; i++)
-                y_table16[i] = av_bswap16(y_table16[i]);
-        fill_table(c->table_rV, 2, crv, y_table16 + yoffs);
-        fill_table(c->table_gU, 2, cgu, y_table16 + yoffs + 1024);
-        fill_table(c->table_bU, 2, cbu, y_table16 + yoffs + 2048);
-        fill_gv_table(c->table_gV, 2, cgv);
-        break;
     case 15:
     case 16:
         rbase = isRgb ? bpp - 5 : 0;
@@ -796,9 +709,6 @@
             y_table16[i+2048] = (yval >> 3)          << bbase;
             yb += cy;
         }
-        if(isNotNe)
-            for (i = 0; i < 1024*3; i++)
-                y_table16[i] = av_bswap16(y_table16[i]);
         fill_table(c->table_rV, 2, crv, y_table16 + yoffs);
         fill_table(c->table_gU, 2, cgu, y_table16 + yoffs + 1024);
         fill_table(c->table_bU, 2, cbu, y_table16 + yoffs + 2048);
